diff -Nru eglibc-2.18/debian/changelog eglibc-2.18/debian/changelog
--- eglibc-2.18/debian/changelog	2014-01-10 23:06:22.000000000 +0000
+++ eglibc-2.18/debian/changelog	2014-01-17 08:22:05.000000000 +0000
@@ -1,3 +1,10 @@
+eglibc (2.18-1) experimental; urgency=low
+
+  * Non-maintainer upload.
+  * Or1k
+
+ -- Adam Conrad <bluecmd@openrisc-lab.c.bluecmd0.internal>  Fri, 17 Jan 2014 08:22:05 +0000
+
 eglibc (2.18-0experimental1) experimental; urgency=low
 
   [ Adam Conrad ]
diff -Nru eglibc-2.18/debian/control eglibc-2.18/debian/control
--- eglibc-2.18/debian/control	2014-01-03 14:02:39.000000000 +0000
+++ eglibc-2.18/debian/control	2014-01-17 08:18:25.000000000 +0000
@@ -4,12 +4,8 @@
 Build-Depends: gettext, dpkg-dev (>= 1.16.0), bzip2, xz-utils, file, quilt,
  autoconf, gawk, debhelper (>= 7.4.3), rdfind, symlinks, netbase,
  linux-libc-dev (>= 3.2.1) [linux-any], linux-libc-dev (>= 3.4) [amd64 i386 x32],
- libaudit-dev [linux-any], libcap-dev [linux-any], libselinux-dev [linux-any],
- mig (>= 1.3-2) [hurd-i386], hurd-dev (>= 20120520-2~) [hurd-i386], gnumach-dev (>= 2:1.4-2~) [hurd-i386],
- kfreebsd-kernel-headers [kfreebsd-any],
  binutils (>= 2.21),
  g++-4.8, g++-4.8-multilib [amd64 i386 kfreebsd-amd64 mips mipsel powerpc ppc64 s390x sparc sparc64 x32]
-Build-Depends-Indep: perl, po-debconf (>= 1.0)
 Maintainer: GNU Libc Maintainers <debian-glibc@lists.debian.org>
 Uploaders: Clint Adams <clint@debian.org>, Aurelien Jarno <aurel32@debian.org>, Adam Conrad <adconrad@0c3.net>
 Standards-Version: 3.9.4
diff -Nru eglibc-2.18/debian/patches/or1k/support.diff eglibc-2.18/debian/patches/or1k/support.diff
--- eglibc-2.18/debian/patches/or1k/support.diff	1970-01-01 00:00:00.000000000 +0000
+++ eglibc-2.18/debian/patches/or1k/support.diff	2014-01-17 08:20:56.000000000 +0000
@@ -0,0 +1,7528 @@
+Description: Or1k support
+ TODO: Put a short summary on the line above and replace this paragraph
+ with a longer explanation of this change. Complete the meta-information
+ with other relevant fields (see below for details). To make it easier, the
+ information below has been extracted from the changelog. Adjust it or drop
+ it.
+ .
+ eglibc (2.18-0experimental1) experimental; urgency=low
+ .
+   [ Adam Conrad ]
+   * debian/patches/i386/cvs-nonascii-case-strcmp.diff: Pull upstream patch
+     to fix LC_CTYPE nonascii-case fallback in i686 strcasecmp/strncasecmp.
+   * debian/testsuite-checking/*: Update 686 targets to match the 586 ones.
+   * Generate expected-results-powerpc64le-linux-gnu-libc for ppc64el port.
+   * debian/testsuite-checking/*: Normalize expected results for ARM ports.
+   * debian/patches/i386/cvs-sse42-strstr*: Backport upstream commits which
+     drop buggy SSE4.2 srtstr implementations in favour of an SSE2 version.
+   * debian/patches/any/cvs-ptrace_peeksiginfo_args.diff: Prepend __ prefix
+     to ptrace_peeksiginfo_args struct to prevent namespace clash w/ linux.
+   * debian/patches/powerpc/cvs-ppc64-vdso-ifunc.diff: Pull upstream fix to
+     squash undefined behaviour in PowerPC64 vDSO IFUNC symbol resolutions.
+   * debian/patches/powerpc/submitted-gettimeofday-vdso.diff: New diff from
+     Adhemerval Zanella at IBM to fix gettimeofday vDSO/IFUNC interactions.
+   * debian/patches/powerpc/submitted-gettimeofday-32.diff: Pull patch from
+     Adhemerval Zanella at IBM to fix 32-bit gettimeofday VSYSCALL lookups.
+   * debian/rules.d/build.mk, debian/sysdeps/{hurd,linux,kfreebsd}.mk: Make
+     pt_chown keyed off a new variable that we can use to enable or disable
+     it per kernel type rather than just the primary libc (Closes: #734607)
+   * debian/patches/kfreebsd/submitted-waitid.diff: On Linux, we must undef
+     waitflags before we define them or we'll conflict with kernel headers.
+ .
+   [ Aurelien Jarno ]
+   * debian/patches/any/cvs-vfscanf-0e+0.diff: new patch from upstream to
+     fix parsing of 0e+0.  Closes: #732993.
+   * debian/patches/mips/submitted-wordsize-clang.diff: drop now that clang
+     correctly defines_MIPS_SZPTR.
+ .
+   [ Samuel Thibault ]
+   * patches/hurd-i386/tg-nfds-poll.diff: New patch to fix poll call with big
+     array.
+   * patches/hurd-i386/tg-sigstate_locking.diff: New patch to fix sigstate
+     creation.
+   * patches/hurd-i386/tg-sigstate_thread_reference.diff: New patch to fix
+     sigstate thread reference counting.
+   * patches/hurd-i386/{libpthreadlibpthread_stubs,libpthread_hurd_cond_wait,
+     submitted-libpthread-elf,cvs-libpthread_lock,libpthread_cancellation,
+     libpthread_hurd_cond_timedwait,libpthread_ctypes,cvs-pthread_atfork,
+     cvs-tls-threadvar-threadself,cvs-libpthread-tls,
+     cvs-libpthread-userstack}.diff: Remove, replaced by...
+   * patches/hurd-i386/cvs-libpthread.diff: ... this git snapshot, and...
+   * patches/hurd-i386/libpthread_build.diff: ... these build fixes.
+   * patches/hurd-i386/tg-aio_misc.diff: New patch to fix aio build.
+   * control.d/main: Build-depend on newer gnumach-dev to get
+     thread_terminate_release RPC.
+   * libc0.3.symbols.hurd-i386: Add thread_terminate_release.
+Author: Adam Conrad <adconrad@0c3.net>
+Bug-Debian: http://bugs.debian.org/732993
+Bug-Debian: http://bugs.debian.org/734607
+
+---
+The information above should follow the Patch Tagging Guidelines, please
+checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
+are templates for supplementary fields that you might want to add:
+
+Origin: <vendor|upstream|other>, <url of original patch>
+Bug: <url in upstream bugtracker>
+Bug-Debian: http://bugs.debian.org/<bugnumber>
+Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
+Forwarded: <no|not-needed|url proving that it has been forwarded>
+Reviewed-By: <name and email of someone who approved the patch>
+Last-Update: <YYYY-MM-DD>
+
+--- eglibc-2.18.orig/elf/elf.h
++++ eglibc-2.18/elf/elf.h
+@@ -3269,6 +3269,42 @@ typedef Elf32_Addr Elf32_Conflict;
+ 
+ #define R_TILEGX_NUM		130
+ 
++/* OpenRISC 1000 specific relocs */
++#define R_OR1K_NONE            0
++#define R_OR1K_32              1
++#define R_OR1K_16              2
++#define R_OR1K_8               3
++#define R_OR1K_LO_16_IN_INSN   4
++#define R_OR1K_HI_16_IN_INSN   5
++#define R_OR1K_INSN_REL_26     6
++#define R_OR1K_GNU_VTENTRY     7
++#define R_OR1K_GNU_VTINHERIT   8
++#define R_OR1K_32_PCREL                9
++#define R_OR1K_16_PCREL                10
++#define R_OR1K_8_PCREL         11
++#define R_OR1K_GOTPC_HI16      12
++#define R_OR1K_GOTPC_LO16      13
++#define R_OR1K_GOT16           14
++#define R_OR1K_PLT26           15
++#define R_OR1K_GOTOFF_HI16     16
++#define R_OR1K_GOTOFF_LO16     17
++#define R_OR1K_COPY            18
++#define R_OR1K_GLOB_DAT                19
++#define R_OR1K_JMP_SLOT                20
++#define R_OR1K_RELATIVE                21
++#define R_OR1K_TLS_GD_HI16     22
++#define R_OR1K_TLS_GD_LO16     23
++#define R_OR1K_TLS_LDM_HI16    24
++#define R_OR1K_TLS_LDM_LO16    25
++#define R_OR1K_TLS_LDO_HI16    26
++#define R_OR1K_TLS_LDO_LO16    27
++#define R_OR1K_TLS_IE_HI16     28
++#define R_OR1K_TLS_IE_LO16     29
++#define R_OR1K_TLS_LE_HI16     30
++#define R_OR1K_TLS_LE_LO16     31
++#define R_OR1K_TLS_TPOFF       32
++#define R_OR1K_TLS_DTPOFF      33
++#define R_OR1K_TLS_DTPMOD      34
+ 
+ __END_DECLS
+ 
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sysdep.c
+@@ -0,0 +1,33 @@
++/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <sysdep.h>
++#include <errno.h>
++
++long __syscall_error (long err);
++hidden_proto (__syscall_error)
++
++/* This routine is jumped to by all the syscall handlers, to stash
++   an error number into errno.  */
++long
++__syscall_error (long err)
++{
++  __set_errno (- err);
++  return -1;
++}
++hidden_def (__syscall_error)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/clone.c
+@@ -0,0 +1,58 @@
++/* Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <stdarg.h>
++#include <sysdep.h>
++
++extern int __or1k_clone (int (*fn)(void *), void *child_stack,
++			 int flags, void *arg, pid_t *ptid,
++			 void *tls, pid_t *ctid);
++
++
++/* or1k ABI uses stack for varargs, syscall uses registers.
++ * This function moves from varargs to regs. */
++int
++__clone (int (*fn)(void *), void *child_stack,
++	 int flags, void *arg, ...
++	 /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ )
++{
++  void *ptid;
++  void *tls;
++  void *ctid;
++  va_list ap;
++  int err;
++
++  va_start (ap, arg);
++  ptid = va_arg (ap, void *);
++  tls = va_arg (ap, void *);
++  ctid = va_arg (ap, void *);
++  va_end (ap);
++
++  /* Sanity check the arguments */
++  err = -EINVAL;
++  if (!fn)
++    goto syscall_error;
++  if (!child_stack)
++    goto syscall_error;
++
++  return __or1k_clone (fn, child_stack, flags, arg, ptid, tls, ctid);
++
++syscall_error:
++  __set_errno (-err);
++  return -1;
++}
++weak_alias (__clone, clone)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/prctl.c
+@@ -0,0 +1,41 @@
++/* Copyright (C) 1995-1998,2000,2003,2006 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <stdarg.h>
++#include <sysdep.h>
++
++/* or1k ABI uses stack for varargs, syscall uses registers.
++ * This function moves from varargs to regs. */
++int
++__prctl (int __option, ...)
++{
++  va_list ap;
++  unsigned long arg2;
++  unsigned long arg3;
++  unsigned long arg4;
++  unsigned long arg5;
++
++  va_start (ap, __option);
++  arg2 = va_arg (ap, unsigned long);
++  arg3 = va_arg (ap, unsigned long);
++  arg4 = va_arg (ap, unsigned long);
++  arg5 = va_arg (ap, unsigned long);
++  va_end (ap);
++
++  return INLINE_SYSCALL (prctl, 5, __option, arg2, arg3, arg4, arg5);
++}
++weak_alias (__prctl, prctl)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sysdep.h
+@@ -0,0 +1,212 @@
++/* Copyright (C) 2011 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <asm/unistd.h>
++#include <sysdeps/or1k/sysdep.h>
++#include <sysdeps/unix/sysv/linux/generic/sysdep.h>
++#include <sys/syscall.h>
++
++#undef SYS_ify
++#define SYS_ify(syscall_name)	(__NR_##syscall_name)
++
++/* Or1k uses 0x2000 as page size */
++#define MMAP_PAGE_SHIFT 13
++
++/* Linux uses a negative return value to indicate syscall errors,
++   unlike most Unices, which use the condition codes' carry flag.
++
++   Since version 2.1 the return value of a system call might be
++   negative even if the call succeeded.  E.g., the `lseek' system call
++   might return a large offset.  Therefore we must not anymore test
++   for < 0, but test for a real error by making sure the value in R0
++   is a real error number.  Linus said he will make sure the no syscall
++   returns a value in -1 .. -4095 as a valid result so we can safely
++   test with -4095.  */
++
++#ifdef __ASSEMBLER__
++
++/* Macros used in syscall-template.S */
++#define ret          l.jr r9; l.nop
++#define ret_NOERRNO  l.jr r9; l.nop
++
++#undef DO_CALL
++#define DO_CALL(syscall_name) \
++    l.addi r11, r0, SYS_ify (syscall_name); \
++    l.sys 1; \
++    l.nop
++
++#define PSEUDO(name, syscall_name, args) \
++  ENTRY (name); \
++  DO_CALL(syscall_name); \
++  /* if -4096 < ret < 0 holds, it's an error */ \
++  l.sfgeui r11, 0xf001; \
++  l.bf 0f; \
++  l.nop
++
++#define PSEUDO_NOERRNO(name, syscall_name, args)  \
++  ENTRY (name);           \
++  DO_CALL(syscall_name)
++
++#define PSEUDO_END(name) \
++0: \
++  l.j SYSCALL_ERROR_NAME; \
++  l.ori r3,r11,0; \
++  END (name)
++
++#define PSEUDO_END_NOERRNO(name) \
++  END (name)
++
++#ifndef PIC
++/* For static code, on error jump to __syscall_error directly. */
++# define SYSCALL_ERROR_NAME __syscall_error
++#elif NOT_IN_libc
++/* Use the internal name for libc/libpthread shared objects. */
++# define SYSCALL_ERROR_NAME __GI___syscall_error
++#else
++/* Otherwise, on error do a full PLT jump. */
++# define SYSCALL_ERROR_NAME plt(__syscall_error)
++#endif
++
++#else /* not __ASSEMBLER__ */
++
++#include <errno.h>
++
++/* Pointer mangling is not yet supported for or1k.
++ * TODO: Implement pointer guards */
++#define PTR_MANGLE(var) (void) (var)
++#define PTR_DEMANGLE(var) (void) (var)
++
++#undef INLINE_SYSCALL
++#define INLINE_SYSCALL(name, nr, args...) \
++	({									\
++	 unsigned int resultvar = INTERNAL_SYSCALL (name, , nr, args);		\
++	 if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	\
++	   {									\
++	     __set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		\
++	     resultvar = 0xffffffff;						\
++	   }									\
++	 (int) resultvar; })
++
++#undef INTERNAL_SYSCALL
++#define INTERNAL_SYSCALL(name, err, nr, args...) \
++	({ unsigned long __sys_result;						\
++	  {									\
++	    register long __sc_ret __asm__ ("r11") = SYS_ify (name);		\
++	    LOAD_ARGS_##nr (args)						\
++	    __asm__ __volatile__ ("l.sys     1"					\
++					   : "=r" (__sc_ret) ASM_ARGS_OUT_##nr	\
++					   : "0" (__sc_ret) ASM_ARGS_IN_##nr	\
++			 : ASM_CLOBBERS_##nr					\
++			   "r12", "r13", "r15", "r17", "r19",			\
++			   "r21", "r23", "r25", "r27", "r29",			\
++			   "r31", "memory");					\
++	    __asm__ __volatile__ ("l.nop");					\
++	    __sys_result = __sc_ret;						\
++	  }									\
++	  (long) __sys_result; })
++
++/* The _NCS variant allows non-constant syscall numbers.  */
++#undef INTERNAL_SYSCALL_NCS
++#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
++	({ unsigned long __sys_result;						\
++	  {									\
++	    register long __sc_ret __asm__ ("r11") = name;			\
++	    LOAD_ARGS_##nr (args)						\
++	    __asm__ __volatile__ ("l.sys     1"					\
++					   : "=r" (__sc_ret) ASM_ARGS_OUT_##nr	\
++					   : "0" (__sc_ret) ASM_ARGS_IN_##nr	\
++			 : ASM_CLOBBERS_##nr					\
++			   "r12", "r13", "r15", "r17", "r19",			\
++			   "r21", "r23", "r25", "r27", "r29",			\
++			   "r31", "memory");					\
++	    __asm__ __volatile__ ("l.nop");					\
++	    __sys_result = __sc_ret;						\
++	  }									\
++	  (long) __sys_result; })
++
++/* INTERNAL_SYSCALL_DECL - Allows us to setup some function static
++   value to use within the context of the syscall.
++
++   We do not use it */
++#undef INTERNAL_SYSCALL_DECL
++#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
++
++/* INTERNAL_SYSCALL_ERROR_P - Returns 0 if it wasn't an error, 1 otherwise
++   You are allowed to use the syscall result (val) and the DECL error
++   variable to determine what went wrong. */
++#undef INTERNAL_SYSCALL_ERROR_P
++#define INTERNAL_SYSCALL_ERROR_P(val, err) \
++    ((unsigned int) (val) >= 0xfffff001u)
++
++
++/* INTERLAL_SYSCALL_ERRNO - Munges the val/err pair into the error number.
++   In our case we just flip the sign. */
++#undef INTERNAL_SYSCALL_ERRNO
++#define INTERNAL_SYSCALL_ERRNO(val, err)        (-(val))
++
++/* From here on we have nested macros that generate code for
++ * storing arguments to the syscall */
++
++#define LOAD_ARGS_0()
++
++#define ASM_ARGS_OUT_0
++#define ASM_ARGS_IN_0
++#define ASM_CLOBBERS_0  "r3", ASM_CLOBBERS_1
++
++#define LOAD_ARGS_1(a)        \
++    LOAD_ARGS_0 ()        \
++  register long __a __asm__ ("r3") = (long)(a);
++#define ASM_ARGS_OUT_1  ASM_ARGS_OUT_0, "=r" (__a)
++#define ASM_ARGS_IN_1 ASM_ARGS_IN_0, "1" (__a)
++#define ASM_CLOBBERS_1  "r4", ASM_CLOBBERS_2
++
++#define LOAD_ARGS_2(a, b)     \
++    LOAD_ARGS_1 (a)       \
++  register long __b __asm__ ("r4") = (long)(b);
++#define ASM_ARGS_OUT_2  ASM_ARGS_OUT_1, "=r" (__b)
++#define ASM_ARGS_IN_2 ASM_ARGS_IN_1, "2" (__b)
++#define ASM_CLOBBERS_2  "r5", ASM_CLOBBERS_3
++
++#define LOAD_ARGS_3(a, b, c)      \
++    LOAD_ARGS_2 (a, b)        \
++  register long __c __asm__ ("r5") = (long)(c);
++#define ASM_ARGS_OUT_3  ASM_ARGS_OUT_2, "=r" (__c)
++#define ASM_ARGS_IN_3 ASM_ARGS_IN_2, "3" (__c)
++#define ASM_CLOBBERS_3  "r6", ASM_CLOBBERS_4
++
++#define LOAD_ARGS_4(a, b, c, d)     \
++    LOAD_ARGS_3 (a, b, c)       \
++  register long __d __asm__ ("r6") = (long)(d);
++#define ASM_ARGS_OUT_4  ASM_ARGS_OUT_3, "=r" (__d)
++#define ASM_ARGS_IN_4 ASM_ARGS_IN_3, "4" (__d)
++#define ASM_CLOBBERS_4  "r7", ASM_CLOBBERS_5
++
++#define LOAD_ARGS_5(a, b, c, d, e)    \
++    LOAD_ARGS_4 (a, b, c, d)      \
++  register long __e __asm__ ("r7") = (long)(e);
++#define ASM_ARGS_OUT_5  ASM_ARGS_OUT_4, "=r" (__e)
++#define ASM_ARGS_IN_5 ASM_ARGS_IN_4, "5" (__e)
++#define ASM_CLOBBERS_5  "r8", ASM_CLOBBERS_6
++
++#define LOAD_ARGS_6(a, b, c, d, e, f)   \
++    LOAD_ARGS_5 (a, b, c, d, e)     \
++  register long __f __asm__ ("r8") = (long)(f);
++#define ASM_ARGS_OUT_6  ASM_ARGS_OUT_5, "=r" (__f)
++#define ASM_ARGS_IN_6 ASM_ARGS_IN_5, "6" (__f)
++#define ASM_CLOBBERS_6
++
++#endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/Makefile
+@@ -0,0 +1,8 @@
++ifeq ($(subdir),misc)
++  sysdep_routines += prctl or1k_clone
++endif
++
++# pull in __syscall_error routine
++libpthread-routines += sysdep
++librt-routines += sysdep
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/ioctl.c
+@@ -0,0 +1,38 @@
++/* Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <stdarg.h>
++#include <sysdep.h>
++
++/* or1k ABI uses stack for varargs, syscall uses registers.
++ * This function moves from varargs to regs. */
++int
++__ioctl (int fd, unsigned long int request, ...)
++{
++  void *arg;
++  va_list ap;
++  int result;
++
++  va_start (ap, request);
++  arg = va_arg (ap, void *);
++
++  result = INLINE_SYSCALL (ioctl, 3, fd, request, arg);
++  va_end (ap);
++
++  return result;
++}
++weak_alias (__ioctl, ioctl)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/semctl.c
+@@ -0,0 +1 @@
++#include <sysdeps/unix/sysv/linux/alpha/semctl.c>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/configure.in
+@@ -0,0 +1,4 @@
++GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
++# Local configure fragment for sysdeps/unix/sysv/linux/or1k.
++
++arch_minimum_kernel=3.4.0
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/kernel-features.h
+@@ -0,0 +1,39 @@
++/* Set flags signalling availability of kernel features based on given
++   kernel version number.
++
++   Copyright (C) 2009-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <linux/version.h>
++
++/* AArch64 support starts with 3.7.0, guaranteeing many kernel
++   features.  */
++
++#define __ASSUME_ACCEPT4                1
++#define __ASSUME_DUP3                   1
++#define __ASSUME_EVENTFD2		1
++#define __ASSUME_IN_NONBLOCK            1
++#define __ASSUME_O_CLOEXEC              1
++#define __ASSUME_PIPE2                  1
++#define __ASSUME_SIGNALFD4		1
++#define __ASSUME_SOCK_CLOEXEC           1
++#define __ASSUME_UTIMES                 1
++
++#include_next <kernel-features.h>
++
++#undef __ASSUME_SET_ROBUST_LIST
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/profil-counter.h
+@@ -0,0 +1,20 @@
++/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public License as
++   published by the Free Software Foundation; either version 2.1 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++/* We can use the ix86 version.  */
++#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/syscall.S
+@@ -0,0 +1,32 @@
++
++.globl syscall
++.type syscall,%function
++.align 4
++syscall: 
++  .cfi_sections .debug_frame
++  .cfi_startproc
++
++  l.ori r11, r3, 0
++  l.ori r3, r4, 0
++  l.ori r4, r5, 0
++  l.ori r5, r6, 0
++  l.ori r6, r7, 0
++  l.ori r7, r8, 0
++  l.lwz r8, 0(r1)
++  l.sys 1
++  l.nop
++
++  /* if -4096 < ret < 0 holds, it's an error */
++  l.sfgeui r11, 0xf001
++  l.bf 0f
++  l.nop
++
++  l.jr r9
++  l.nop
++
++0: 
++  l.j __syscall_error
++  l.ori r3,r11,0
++
++  .cfi_endproc
++  .size syscall,.-syscall
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/configure
+@@ -0,0 +1,3 @@
++# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
++
++arch_minimum_kernel=3.4.0
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/Implies
+@@ -0,0 +1,2 @@
++unix/sysv/linux/generic/wordsize-32
++unix/sysv/linux/generic
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/pthreadtypes.h
+@@ -0,0 +1,173 @@
++/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_PTHREADTYPES_H
++#define _BITS_PTHREADTYPES_H	1
++
++#include <bits/wordsize.h>
++
++/* TODO: fix these! */
++#define __SIZEOF_PTHREAD_ATTR_T 32
++#define __SIZEOF_PTHREAD_MUTEX_T 32
++#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
++#define __SIZEOF_PTHREAD_COND_T 48
++#define __SIZEOF_PTHREAD_CONDATTR_T 4
++#define __SIZEOF_PTHREAD_RWLOCK_T 44
++#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
++#define __SIZEOF_PTHREAD_BARRIER_T 20
++#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
++
++
++/* Thread identifiers.  The structure of the attribute type is not
++   exposed on purpose.  */
++typedef unsigned long int pthread_t;
++
++
++union pthread_attr_t
++{
++  char __size[__SIZEOF_PTHREAD_ATTR_T];
++  long int __align;
++};
++#ifndef __have_pthread_attr_t
++typedef union pthread_attr_t pthread_attr_t;
++# define __have_pthread_attr_t	1
++#endif
++
++
++typedef struct __pthread_internal_list
++{
++  struct __pthread_internal_list *__prev;
++  struct __pthread_internal_list *__next;
++} __pthread_list_t;
++
++/* Data structures for mutex handling.  The structure of the attribute
++   type is not exposed on purpose.  */
++typedef union
++{
++  struct __pthread_mutex_s
++  {
++    int __lock;
++    unsigned int __count;
++    int __owner;
++    unsigned int __nusers;
++    /* KIND must stay at this position in the structure to maintain
++       binary compatibility.  */
++    int __kind;
++    int __spins;
++    __pthread_list_t __list;
++# define __PTHREAD_MUTEX_HAVE_PREV	1
++  } __data;
++  char __size[__SIZEOF_PTHREAD_MUTEX_T];
++  long int __align;
++} pthread_mutex_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
++  int __align;
++} pthread_mutexattr_t;
++
++
++/* Data structure for conditional variable handling.  The structure of
++   the attribute type is not exposed on purpose.  */
++typedef union
++{
++  struct
++  {
++    int __lock;
++    unsigned int __futex;
++    __extension__ unsigned long long int __total_seq;
++    __extension__ unsigned long long int __wakeup_seq;
++    __extension__ unsigned long long int __woken_seq;
++    void *__mutex;
++    unsigned int __nwaiters;
++    unsigned int __broadcast_seq;
++  } __data;
++  char __size[__SIZEOF_PTHREAD_COND_T];
++  __extension__ long long int __align;
++} pthread_cond_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
++  int __align;
++} pthread_condattr_t;
++
++
++/* Keys for thread-specific data */
++typedef unsigned int pthread_key_t;
++
++
++/* Once-only execution */
++typedef int pthread_once_t;
++
++
++#if defined __USE_UNIX98 || defined __USE_XOPEN2K
++/* Data structure for read-write lock variable handling.  The
++   structure of the attribute type is not exposed on purpose.  */
++typedef union
++{
++  struct
++  {
++    int __lock;
++    unsigned int __nr_readers;
++    unsigned int __readers_wakeup;
++    unsigned int __writer_wakeup;
++    unsigned int __nr_readers_queued;
++    unsigned int __nr_writers_queued;
++    int __writer;
++    int __shared;
++    unsigned long int __pad1;
++    unsigned long int __pad2;
++    /* FLAGS must stay at this position in the structure to maintain
++       binary compatibility.  */
++    unsigned int __flags;
++# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
++  } __data;
++  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
++  long int __align;
++} pthread_rwlock_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
++  long int __align;
++} pthread_rwlockattr_t;
++#endif
++
++
++#ifdef __USE_XOPEN2K
++/* POSIX spinlock data type.  */
++typedef volatile int pthread_spinlock_t;
++
++
++/* POSIX barriers data type.  The structure of the type is
++   deliberately not exposed.  */
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_BARRIER_T];
++  long int __align;
++} pthread_barrier_t;
++
++typedef union
++{
++  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
++  int __align;
++} pthread_barrierattr_t;
++#endif
++
++#endif	/* bits/pthreadtypes.h */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/link.h
+@@ -0,0 +1,34 @@
++#ifndef _LINK_H
++# error "Never include <bits/link.h> directly; use <link.h> instead."
++#endif
++
++/* Registers for entry into PLT.  */
++typedef struct La_or1k_regs
++{
++  uint32_t lr_reg[31];
++} La_or1k_regs;
++
++/* Return values for calls from PLT.  */
++typedef struct La_or1k_retval
++{
++  uint32_t lr_r3;
++} La_or1k_retval;
++
++
++__BEGIN_DECLS
++
++extern ElfW(Addr) la_or1k_gnu_pltenter (ElfW(Sym) *__sym, unsigned int __ndx,
++                                        uintptr_t *__refcook,
++                                        uintptr_t *__defcook,
++                                        La_or1k_regs *__regs,
++                                        unsigned int *__flags,
++                                        const char *__symname,
++                                        long int *__framesizep);
++extern unsigned int la_or1k_gnu_pltexit (ElfW(Sym) *__sym, unsigned int __ndx,
++                                         uintptr_t *__refcook,
++                                         uintptr_t *__defcook,
++                                         const La_or1k_regs *__inregs,
++                                         La_or1k_retval *__outregs,
++                                         const char *__symname);
++
++__END_DECLS
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/statfs.h
+@@ -0,0 +1,83 @@
++/* Copyright (C) 2011 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _SYS_STATFS_H
++# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
++#endif
++
++#include <endian.h>
++#include <bits/types.h>
++#include <bits/wordsize.h>
++
++/* 64-bit libc uses the kernel's 'struct statfs', accessed via the
++   statfs() syscall; 32-bit libc uses the kernel's 'struct statfs64'
++   and accesses it via the statfs64() syscall.  All the various
++   APIs offered by libc use the kernel shape for their struct statfs
++   structure; the only difference is that 32-bit programs not
++   using __USE_FILE_OFFSET64 only see the low 32 bits of some
++   of the fields (the __fsblkcnt_t and __fsfilcnt_t fields).  */
++
++/* TODO: or1k gcc doesn't handle alignment as it should.
++ * when that is fixed, remove this file to use default */
++#if defined __USE_FILE_OFFSET64
++# define __field64(type, type64, name) type64 name
++#else
++# define __field64(type, type64, name) \
++  int __##name##_pad __attribute__((__aligned__(4))); type name
++#endif
++
++struct statfs
++  {
++    __SWORD_TYPE f_type;
++    __SWORD_TYPE f_bsize;
++    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_blocks);
++    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_bfree);
++    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_bavail);
++    __field64(__fsfilcnt_t, __fsfilcnt64_t, f_files);
++    __field64(__fsfilcnt_t, __fsfilcnt64_t, f_ffree);
++    __fsid_t f_fsid;
++    __SWORD_TYPE f_namelen;
++    __SWORD_TYPE f_frsize;
++    __SWORD_TYPE f_flags;
++    __SWORD_TYPE f_spare[4];
++  } __attribute__((__aligned__(4)));
++
++#undef __field64
++
++#ifdef __USE_LARGEFILE64
++struct statfs64
++  {
++    __SWORD_TYPE f_type;
++    __SWORD_TYPE f_bsize;
++    __fsblkcnt64_t f_blocks;
++    __fsblkcnt64_t f_bfree;
++    __fsblkcnt64_t f_bavail;
++    __fsfilcnt64_t f_files;
++    __fsfilcnt64_t f_ffree;
++    __fsid_t f_fsid;
++    __SWORD_TYPE f_namelen;
++    __SWORD_TYPE f_frsize;
++    __SWORD_TYPE f_flags;
++    __SWORD_TYPE f_spare[4];
++  } __attribute__((__aligned__(4)));
++#endif
++
++/* Tell code we have these members.  */
++#define _STATFS_F_NAMELEN
++#define _STATFS_F_FRSIZE
++#define _STATFS_F_FLAGS
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/fcntl.h
+@@ -0,0 +1,49 @@
++/* O_*, F_*, FD_* bit values for Linux.
++   Copyright (C) 2000-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef	_FCNTL_H
++# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
++#endif
++
++struct flock
++  {
++    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
++    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
++#ifndef __USE_FILE_OFFSET64
++    __off_t l_start;	/* Offset where the lock begins.  */
++    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
++#else
++    __off64_t l_start;	/* Offset where the lock begins.  */
++    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
++#endif
++    __pid_t l_pid;	/* Process holding the lock.  */
++  };
++
++#ifdef __USE_LARGEFILE64
++struct flock64
++  {
++    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
++    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
++    __off64_t l_start;	/* Offset where the lock begins.  */
++    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
++    __pid_t l_pid;	/* Process holding the lock.  */
++  };
++#endif
++
++/* Include generic Linux declarations.  */
++#include <bits/fcntl-linux.h>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/mman.h
+@@ -0,0 +1,116 @@
++/* Definitions for POSIX memory map interface.  Linux/AArch64 version.
++
++   Copyright (C) 1997-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _SYS_MMAN_H
++# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
++#endif
++
++/* The following definitions basically come from the kernel headers.
++   But the kernel header is not namespace clean.  */
++
++
++/* Protections are chosen from these bits, OR'd together.  The
++   implementation does not necessarily support PROT_EXEC or PROT_WRITE
++   without PROT_READ.  The only guarantees are that no writing will be
++   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
++
++#define PROT_READ       0x1             /* Page can be read.  */
++#define PROT_WRITE      0x2             /* Page can be written.  */
++#define PROT_EXEC       0x4             /* Page can be executed.  */
++#define PROT_SEM        0x8             /* Page may be used for atomic ops */
++#define PROT_NONE       0x0             /* Page can not be accessed.  */
++#define PROT_GROWSDOWN  0x01000000      /* Extend change to start of
++                                           growsdown vma (mprotect only).  */
++#define PROT_GROWSUP    0x02000000      /* Extend change to start of
++                                           growsup vma (mprotect only).  */
++
++/* Sharing types (must choose one and only one of these).  */
++#define MAP_SHARED      0x01            /* Share changes.  */
++#define MAP_PRIVATE     0x02            /* Changes are private.  */
++#ifdef __USE_MISC
++# define MAP_TYPE       0x0f            /* Mask for type of mapping.  */
++#endif
++
++/* Other flags.  */
++#define MAP_FIXED       0x10            /* Interpret addr exactly.  */
++#ifdef __USE_MISC
++# define MAP_FILE       0
++# define MAP_ANONYMOUS  0x20            /* Don't use a file.  */
++# define MAP_ANON       MAP_ANONYMOUS
++#endif
++
++#ifdef __USE_MISC
++/* These are Linux-specific.  */
++# define MAP_GROWSDOWN  0x00100         /* Stack-like segment.  */
++# define MAP_DENYWRITE  0x00800         /* ETXTBSY */
++# define MAP_EXECUTABLE 0x01000         /* Mark it as an executable.  */
++# define MAP_LOCKED     0x02000         /* Lock the mapping.  */
++# define MAP_NORESERVE  0x04000         /* Don't check for reservations.  */
++# define MAP_POPULATE   0x08000         /* Populate (prefault) pagetables.  */
++# define MAP_NONBLOCK   0x10000         /* Do not block on IO.  */
++# define MAP_STACK      0x20000         /* Allocation is for a stack.  */
++# define MAP_HUGETLB    0x40000         /* Create huge page mapping.  */
++#endif
++
++/* Flags to `msync'.  */
++#define MS_ASYNC        1               /* Sync memory asynchronously.  */
++#define MS_SYNC         4               /* Synchronous memory sync.  */
++#define MS_INVALIDATE   2               /* Invalidate the caches.  */
++
++/* Flags for `mlockall'.  */
++#define MCL_CURRENT     1               /* Lock all currently mapped pages.  */
++#define MCL_FUTURE      2               /* Lock all additions to address
++                                           space.  */
++
++/* Flags for `mremap'.  */
++#ifdef __USE_GNU
++# define MREMAP_MAYMOVE 1
++# define MREMAP_FIXED   2
++#endif
++
++/* Advice to `madvise'.  */
++#ifdef __USE_BSD
++# define MADV_NORMAL       0     /* No further special treatment.  */
++# define MADV_RANDOM       1     /* Expect random page references.  */
++# define MADV_SEQUENTIAL   2     /* Expect sequential page references.  */
++# define MADV_WILLNEED     3     /* Will need these pages.  */
++# define MADV_DONTNEED     4     /* Don't need these pages.  */
++# define MADV_REMOVE       9     /* Remove these pages and resources.  */
++# define MADV_DONTFORK     10    /* Do not inherit across fork.  */
++# define MADV_DOFORK       11    /* Do inherit across fork.  */
++# define MADV_MERGEABLE    12    /* KSM may merge identical pages.  */
++# define MADV_UNMERGEABLE  13    /* KSM may not merge identical pages.  */
++# define MADV_HUGEPAGE     14    /* Worth backing with hugepages.  */
++# define MADV_NOHUGEPAGE   15    /* Not worth backing with hugepages.  */
++# define MADV_DONTDUMP     16    /* Explicity exclude from the core dump,
++                                    overrides the coredump filter bits.  */
++# define MADV_DODUMP       17    /* Clear the MADV_DONTDUMP flag.  */
++# define MADV_HWPOISON     100   /* Poison a page for testing.  */
++# define MADV_SOFT_OFFLINE 101   /* Soft offline page for testing */
++#endif
++
++/* The POSIX people had to invent similar names for the same things.  */
++#ifdef __USE_XOPEN2K
++# define POSIX_MADV_NORMAL      0 /* No further special treatment.  */
++# define POSIX_MADV_RANDOM      1 /* Expect random page references.  */
++# define POSIX_MADV_SEQUENTIAL  2 /* Expect sequential page references.  */
++# define POSIX_MADV_WILLNEED    3 /* Will need these pages.  */
++# define POSIX_MADV_DONTNEED    4 /* Don't need these pages.  */
++#endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/siginfo.h
+@@ -0,0 +1,341 @@
++/* siginfo_t, sigevent and constants.  Linux x86-64 version.
++   Copyright (C) 2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#if !defined _SIGNAL_H && !defined __need_siginfo_t \
++    && !defined __need_sigevent_t
++# error "Never include this file directly.  Use <signal.h> instead"
++#endif
++
++#include <bits/wordsize.h>
++
++#if (!defined __have_sigval_t \
++     && (defined _SIGNAL_H || defined __need_siginfo_t \
++	 || defined __need_sigevent_t))
++# define __have_sigval_t	1
++
++/* Type for data associated with a signal.  */
++typedef union sigval
++  {
++    int sival_int;
++    void *sival_ptr;
++  } sigval_t;
++#endif
++
++#if (!defined __have_siginfo_t \
++     && (defined _SIGNAL_H || defined __need_siginfo_t))
++# define __have_siginfo_t	1
++
++# define __SI_MAX_SIZE     128
++# if __WORDSIZE == 64
++#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 4)
++# else
++#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
++# endif
++
++# if defined __x86_64__ && __WORDSIZE == 32
++/* si_utime and si_stime must be 4 byte aligned for x32 to match the
++   kernel.  We align siginfo_t to 8 bytes so that si_utime and si_stime
++   are actually aligned to 8 bytes since their offsets are multiple of
++   8 bytes.  */
++typedef __clock_t __attribute__ ((__aligned__ (4))) __sigchld_clock_t;
++#  define __SI_ALIGNMENT __attribute__ ((__aligned__ (8)))
++# else
++typedef __clock_t __sigchld_clock_t;
++#  define __SI_ALIGNMENT
++# endif
++
++typedef struct
++  {
++    int si_signo;		/* Signal number.  */
++    int si_errno;		/* If non-zero, an errno value associated with
++				   this signal, as defined in <errno.h>.  */
++    int si_code;		/* Signal code.  */
++
++    union
++      {
++	int _pad[__SI_PAD_SIZE];
++
++	 /* kill().  */
++	struct
++	  {
++	    __pid_t si_pid;	/* Sending process ID.  */
++	    __uid_t si_uid;	/* Real user ID of sending process.  */
++	  } _kill;
++
++	/* POSIX.1b timers.  */
++	struct
++	  {
++	    int si_tid;		/* Timer ID.  */
++	    int si_overrun;	/* Overrun count.  */
++	    sigval_t si_sigval;	/* Signal value.  */
++	  } _timer;
++
++	/* POSIX.1b signals.  */
++	struct
++	  {
++	    __pid_t si_pid;	/* Sending process ID.  */
++	    __uid_t si_uid;	/* Real user ID of sending process.  */
++	    sigval_t si_sigval;	/* Signal value.  */
++	  } _rt;
++
++	/* SIGCHLD.  */
++	struct
++	  {
++	    __pid_t si_pid;	/* Which child.  */
++	    __uid_t si_uid;	/* Real user ID of sending process.  */
++	    int si_status;	/* Exit value or signal.  */
++	    __sigchld_clock_t si_utime;
++	    __sigchld_clock_t si_stime;
++	  } _sigchld;
++
++	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
++	struct
++	  {
++	    void *si_addr;	/* Faulting insn/memory ref.  */
++	  } _sigfault;
++
++	/* SIGPOLL.  */
++	struct
++	  {
++	    long int si_band;	/* Band event for SIGPOLL.  */
++	    int si_fd;
++	  } _sigpoll;
++
++	/* SIGSYS.  */
++	struct
++	  {
++	    void *_call_addr;	/* Calling user insn.  */
++	    int _syscall;	/* Triggering system call number.  */
++	    unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
++	  } _sigsys;
++      } _sifields;
++  } siginfo_t __SI_ALIGNMENT;
++
++
++/* X/Open requires some more fields with fixed names.  */
++# define si_pid		_sifields._kill.si_pid
++# define si_uid		_sifields._kill.si_uid
++# define si_timerid	_sifields._timer.si_tid
++# define si_overrun	_sifields._timer.si_overrun
++# define si_status	_sifields._sigchld.si_status
++# define si_utime	_sifields._sigchld.si_utime
++# define si_stime	_sifields._sigchld.si_stime
++# define si_value	_sifields._rt.si_sigval
++# define si_int		_sifields._rt.si_sigval.sival_int
++# define si_ptr		_sifields._rt.si_sigval.sival_ptr
++# define si_addr	_sifields._sigfault.si_addr
++# define si_band	_sifields._sigpoll.si_band
++# define si_fd		_sifields._sigpoll.si_fd
++# define si_call_addr 	_sifields._sigsys._call_addr
++# define si_syscall	_sifields._sigsys._syscall
++# define si_arch	_sifields._sigsys._arch
++
++
++/* Values for `si_code'.  Positive values are reserved for kernel-generated
++   signals.  */
++enum
++{
++  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
++# define SI_ASYNCNL	SI_ASYNCNL
++  SI_TKILL = -6,		/* Sent by tkill.  */
++# define SI_TKILL	SI_TKILL
++  SI_SIGIO,			/* Sent by queued SIGIO. */
++# define SI_SIGIO	SI_SIGIO
++  SI_ASYNCIO,			/* Sent by AIO completion.  */
++# define SI_ASYNCIO	SI_ASYNCIO
++  SI_MESGQ,			/* Sent by real time mesq state change.  */
++# define SI_MESGQ	SI_MESGQ
++  SI_TIMER,			/* Sent by timer expiration.  */
++# define SI_TIMER	SI_TIMER
++  SI_QUEUE,			/* Sent by sigqueue.  */
++# define SI_QUEUE	SI_QUEUE
++  SI_USER,			/* Sent by kill, sigsend.  */
++# define SI_USER	SI_USER
++  SI_KERNEL = 0x80		/* Send by kernel.  */
++#define SI_KERNEL	SI_KERNEL
++};
++
++
++/* `si_code' values for SIGILL signal.  */
++enum
++{
++  ILL_ILLOPC = 1,		/* Illegal opcode.  */
++# define ILL_ILLOPC	ILL_ILLOPC
++  ILL_ILLOPN,			/* Illegal operand.  */
++# define ILL_ILLOPN	ILL_ILLOPN
++  ILL_ILLADR,			/* Illegal addressing mode.  */
++# define ILL_ILLADR	ILL_ILLADR
++  ILL_ILLTRP,			/* Illegal trap. */
++# define ILL_ILLTRP	ILL_ILLTRP
++  ILL_PRVOPC,			/* Privileged opcode.  */
++# define ILL_PRVOPC	ILL_PRVOPC
++  ILL_PRVREG,			/* Privileged register.  */
++# define ILL_PRVREG	ILL_PRVREG
++  ILL_COPROC,			/* Coprocessor error.  */
++# define ILL_COPROC	ILL_COPROC
++  ILL_BADSTK			/* Internal stack error.  */
++# define ILL_BADSTK	ILL_BADSTK
++};
++
++/* `si_code' values for SIGFPE signal.  */
++enum
++{
++  FPE_INTDIV = 1,		/* Integer divide by zero.  */
++# define FPE_INTDIV	FPE_INTDIV
++  FPE_INTOVF,			/* Integer overflow.  */
++# define FPE_INTOVF	FPE_INTOVF
++  FPE_FLTDIV,			/* Floating point divide by zero.  */
++# define FPE_FLTDIV	FPE_FLTDIV
++  FPE_FLTOVF,			/* Floating point overflow.  */
++# define FPE_FLTOVF	FPE_FLTOVF
++  FPE_FLTUND,			/* Floating point underflow.  */
++# define FPE_FLTUND	FPE_FLTUND
++  FPE_FLTRES,			/* Floating point inexact result.  */
++# define FPE_FLTRES	FPE_FLTRES
++  FPE_FLTINV,			/* Floating point invalid operation.  */
++# define FPE_FLTINV	FPE_FLTINV
++  FPE_FLTSUB			/* Subscript out of range.  */
++# define FPE_FLTSUB	FPE_FLTSUB
++};
++
++/* `si_code' values for SIGSEGV signal.  */
++enum
++{
++  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
++# define SEGV_MAPERR	SEGV_MAPERR
++  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
++# define SEGV_ACCERR	SEGV_ACCERR
++};
++
++/* `si_code' values for SIGBUS signal.  */
++enum
++{
++  BUS_ADRALN = 1,		/* Invalid address alignment.  */
++# define BUS_ADRALN	BUS_ADRALN
++  BUS_ADRERR,			/* Non-existant physical address.  */
++# define BUS_ADRERR	BUS_ADRERR
++  BUS_OBJERR			/* Object specific hardware error.  */
++# define BUS_OBJERR	BUS_OBJERR
++};
++
++/* `si_code' values for SIGTRAP signal.  */
++enum
++{
++  TRAP_BRKPT = 1,		/* Process breakpoint.  */
++# define TRAP_BRKPT	TRAP_BRKPT
++  TRAP_TRACE			/* Process trace trap.  */
++# define TRAP_TRACE	TRAP_TRACE
++};
++
++/* `si_code' values for SIGCHLD signal.  */
++enum
++{
++  CLD_EXITED = 1,		/* Child has exited.  */
++# define CLD_EXITED	CLD_EXITED
++  CLD_KILLED,			/* Child was killed.  */
++# define CLD_KILLED	CLD_KILLED
++  CLD_DUMPED,			/* Child terminated abnormally.  */
++# define CLD_DUMPED	CLD_DUMPED
++  CLD_TRAPPED,			/* Traced child has trapped.  */
++# define CLD_TRAPPED	CLD_TRAPPED
++  CLD_STOPPED,			/* Child has stopped.  */
++# define CLD_STOPPED	CLD_STOPPED
++  CLD_CONTINUED			/* Stopped child has continued.  */
++# define CLD_CONTINUED	CLD_CONTINUED
++};
++
++/* `si_code' values for SIGPOLL signal.  */
++enum
++{
++  POLL_IN = 1,			/* Data input available.  */
++# define POLL_IN	POLL_IN
++  POLL_OUT,			/* Output buffers available.  */
++# define POLL_OUT	POLL_OUT
++  POLL_MSG,			/* Input message available.   */
++# define POLL_MSG	POLL_MSG
++  POLL_ERR,			/* I/O error.  */
++# define POLL_ERR	POLL_ERR
++  POLL_PRI,			/* High priority input available.  */
++# define POLL_PRI	POLL_PRI
++  POLL_HUP			/* Device disconnected.  */
++# define POLL_HUP	POLL_HUP
++};
++
++# undef __need_siginfo_t
++#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
++
++
++#if (defined _SIGNAL_H || defined __need_sigevent_t) \
++    && !defined __have_sigevent_t
++# define __have_sigevent_t	1
++
++/* Structure to transport application-defined values with signals.  */
++# define __SIGEV_MAX_SIZE	64
++# if __WORDSIZE == 64
++#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)
++# else
++#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
++# endif
++
++/* Forward declaration.  */
++# ifndef __have_pthread_attr_t
++typedef union pthread_attr_t pthread_attr_t;
++#  define __have_pthread_attr_t	1
++# endif
++
++typedef struct sigevent
++  {
++    sigval_t sigev_value;
++    int sigev_signo;
++    int sigev_notify;
++
++    union
++      {
++	int _pad[__SIGEV_PAD_SIZE];
++
++	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
++	   thread to receive the signal.  */
++	__pid_t _tid;
++
++	struct
++	  {
++	    void (*_function) (sigval_t);	/* Function to start.  */
++	    pthread_attr_t *_attribute;		/* Thread attributes.  */
++	  } _sigev_thread;
++      } _sigev_un;
++  } sigevent_t;
++
++/* POSIX names to access some of the members.  */
++# define sigev_notify_function   _sigev_un._sigev_thread._function
++# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
++
++/* `sigev_notify' values.  */
++enum
++{
++  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
++# define SIGEV_SIGNAL	SIGEV_SIGNAL
++  SIGEV_NONE,			/* Other notification: meaningless.  */
++# define SIGEV_NONE	SIGEV_NONE
++  SIGEV_THREAD,			/* Deliver via thread creation.  */
++# define SIGEV_THREAD	SIGEV_THREAD
++
++  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
++#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
++};
++
++#endif	/* have _SIGNAL_H.  */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sys/user.h
+@@ -0,0 +1 @@
++/* This file is not needed, but in practice gdb might try to include it.  */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sys/procfs.h
+@@ -0,0 +1,118 @@
++/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _SYS_PROCFS_H
++#define _SYS_PROCFS_H	1
++
++/* This is somewhat modelled after the file of the same name on SVR4
++   systems.  It provides a definition of the core file format for ELF
++   used on Linux.  It doesn't have anything to do with the /proc file
++   system, even though Linux has one.
++
++   Anyway, the whole purpose of this file is for GDB and GDB only.
++   Don't read too much into it.  Don't use it for anything other than
++   GDB unless you know what you are doing.  */
++
++#include <features.h>
++#include <sys/time.h>
++#include <sys/types.h>
++#include <sys/user.h>
++#include <asm/elf.h>
++
++__BEGIN_DECLS
++
++/* Type for a general-purpose register.  */
++typedef unsigned long elf_greg_t;
++
++/* And the whole bunch of them.  We could have used `struct
++   user_regs' directly in the typedef, but tradition says that
++   the register set is an array, which does have some peculiar
++   semantics, so leave it that way.  */
++
++/* Signal info.  */
++struct elf_siginfo
++  {
++    int si_signo;			/* Signal number.  */
++    int si_code;			/* Extra code.  */
++    int si_errno;			/* Errno.  */
++  };
++
++/* Definitions to generate Intel SVR4-like core files.  These mostly
++   have the same names as the SVR4 types with "elf_" tacked on the
++   front to prevent clashes with Linux definitions, and the typedef
++   forms have been avoided.  This is mostly like the SVR4 structure,
++   but more Linuxy, with things that Linux does not support and which
++   GDB doesn't really use excluded.  */
++
++struct elf_prstatus
++  {
++    struct elf_siginfo pr_info;		/* Info associated with signal.  */
++    short int pr_cursig;		/* Current signal.  */
++    unsigned long int pr_sigpend;	/* Set of pending signals.  */
++    unsigned long int pr_sighold;	/* Set of held signals.  */
++    __pid_t pr_pid;
++    __pid_t pr_ppid;
++    __pid_t pr_pgrp;
++    __pid_t pr_sid;
++    struct timeval pr_utime;		/* User time.  */
++    struct timeval pr_stime;		/* System time.  */
++    struct timeval pr_cutime;		/* Cumulative user time.  */
++    struct timeval pr_cstime;		/* Cumulative system time.  */
++    elf_gregset_t pr_reg;		/* GP registers.  */
++    int pr_fpvalid;			/* True if math copro being used.  */
++  };
++
++
++#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
++
++struct elf_prpsinfo
++  {
++    char pr_state;			/* Numeric process state.  */
++    char pr_sname;			/* Char for pr_state.  */
++    char pr_zomb;			/* Zombie.  */
++    char pr_nice;			/* Nice val.  */
++    unsigned long int pr_flag;		/* Flags.  */
++    unsigned short int pr_uid;
++    unsigned short int pr_gid;
++    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
++    /* Lots missing */
++    char pr_fname[16];			/* Filename of executable.  */
++    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
++  };
++
++/* The rest of this file provides the types for emulation of the
++   Solaris <proc_service.h> interfaces that should be implemented by
++   users of libthread_db.  */
++
++/* Addresses.  */
++typedef void *psaddr_t;
++
++/* Register sets.  Linux has different names.  */
++typedef elf_gregset_t prgregset_t;
++typedef elf_fpregset_t prfpregset_t;
++
++/* We don't have any differences between processes and threads,
++   therefore have only one PID type.  */
++typedef __pid_t lwpid_t;
++
++/* Process status and info.  In the end we do provide typedefs for them.  */
++typedef struct elf_prstatus prstatus_t;
++typedef struct elf_prpsinfo prpsinfo_t;
++
++__END_DECLS
++
++#endif	/* sys/procfs.h */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/ld.abilist
+@@ -0,0 +1,18 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ __libc_memalign F
++ _r_debug D 0x14
++ calloc F
++ free F
++ malloc F
++ realloc F
++GLIBC_2.1
++ GLIBC_2.1 A
++ __libc_stack_end D 0x4
++ _dl_mcount F
++GLIBC_2.3
++ GLIBC_2.3 A
++ __tls_get_addr F
++GLIBC_2.4
++ GLIBC_2.4 A
++ __stack_chk_guard D 0x4
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/pt-vfork.c
+@@ -0,0 +1,30 @@
++/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <unistd.h>
++
++/* If we don't have vfork, fork is close enough.  */
++
++__pid_t
++__vfork (void)
++{
++  return __fork ();
++}
++libc_hidden_def (__vfork)
++
++weak_alias (__vfork, vfork)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libthread_db.abilist
+@@ -0,0 +1,48 @@
++GLIBC_2.1.3
++ GLIBC_2.1.3 A
++ td_init F
++ td_log F
++ td_ta_clear_event F
++ td_ta_delete F
++ td_ta_enable_stats F
++ td_ta_event_addr F
++ td_ta_event_getmsg F
++ td_ta_get_nthreads F
++ td_ta_get_ph F
++ td_ta_get_stats F
++ td_ta_map_id2thr F
++ td_ta_map_lwp2thr F
++ td_ta_new F
++ td_ta_reset_stats F
++ td_ta_set_event F
++ td_ta_setconcurrency F
++ td_ta_thr_iter F
++ td_ta_tsd_iter F
++ td_thr_clear_event F
++ td_thr_dbresume F
++ td_thr_dbsuspend F
++ td_thr_event_enable F
++ td_thr_event_getmsg F
++ td_thr_get_info F
++ td_thr_getfpregs F
++ td_thr_getgregs F
++ td_thr_getxregs F
++ td_thr_getxregsize F
++ td_thr_set_event F
++ td_thr_setfpregs F
++ td_thr_setgregs F
++ td_thr_setprio F
++ td_thr_setsigpending F
++ td_thr_setxregs F
++ td_thr_sigsetmask F
++ td_thr_tsd F
++ td_thr_validate F
++GLIBC_2.2.3
++ GLIBC_2.2.3 A
++ td_symbol_list F
++GLIBC_2.3
++ GLIBC_2.3 A
++ td_thr_tls_get_addr F
++GLIBC_2.3.3
++ GLIBC_2.3.3 A
++ td_thr_tlsbase F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/createthread.c
+@@ -0,0 +1,23 @@
++/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Jakub Jelinek <jakub@redhat.com>.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++/* Value passed to 'clone' for initialization of the thread register.  */
++#define TLS_VALUE ((char *) pd + TLS_PRE_TCB_SIZE + TLS_INIT_TCB_SIZE)
++
++/* Get the real implementation.	 */
++#include <nptl/sysdeps/pthread/createthread.c>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/c++-types.data
+@@ -0,0 +1,67 @@
++blkcnt64_t:x
++blkcnt_t:l
++blksize_t:l
++caddr_t:Pc
++clockid_t:i
++clock_t:l
++daddr_t:i
++dev_t:y
++fd_mask:l
++fsblkcnt64_t:y
++fsblkcnt_t:m
++fsfilcnt64_t:y
++fsfilcnt_t:m
++fsid_t:8__fsid_t
++gid_t:j
++id_t:j
++ino64_t:y
++ino_t:m
++int16_t:s
++int32_t:i
++int64_t:x
++int8_t:a
++intptr_t:i
++key_t:i
++loff_t:x
++mode_t:j
++nlink_t:j
++off64_t:x
++off_t:l
++pid_t:i
++pthread_attr_t:14pthread_attr_t
++pthread_barrier_t:17pthread_barrier_t
++pthread_barrierattr_t:21pthread_barrierattr_t
++pthread_cond_t:14pthread_cond_t
++pthread_condattr_t:18pthread_condattr_t
++pthread_key_t:j
++pthread_mutex_t:15pthread_mutex_t
++pthread_mutexattr_t:19pthread_mutexattr_t
++pthread_once_t:i
++pthread_rwlock_t:16pthread_rwlock_t
++pthread_rwlockattr_t:20pthread_rwlockattr_t
++pthread_spinlock_t:i
++pthread_t:m
++quad_t:x
++register_t:i
++rlim64_t:y
++rlim_t:m
++sigset_t:10__sigset_t
++size_t:j
++socklen_t:j
++ssize_t:i
++suseconds_t:l
++time_t:l
++u_char:h
++uid_t:j
++uint:j
++u_int:j
++u_int16_t:t
++u_int32_t:j
++u_int64_t:y
++u_int8_t:h
++ulong:m
++u_long:m
++u_quad_t:y
++useconds_t:j
++ushort:t
++u_short:t
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libresolv.abilist
+@@ -0,0 +1,104 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ __b64_ntop F
++ __b64_pton F
++ __dn_comp F
++ __dn_count_labels F
++ __dn_skipname F
++ __fp_nquery F
++ __fp_query F
++ __fp_resstat F
++ __hostalias F
++ __loc_aton F
++ __loc_ntoa F
++ __p_cdname F
++ __p_cdnname F
++ __p_class F
++ __p_class_syms D 0x54
++ __p_fqname F
++ __p_fqnname F
++ __p_option F
++ __p_query F
++ __p_secstodate F
++ __p_time F
++ __p_type F
++ __p_type_syms D 0x228
++ __putlong F
++ __putshort F
++ __res_close F
++ __res_dnok F
++ __res_hnok F
++ __res_isourserver F
++ __res_mailok F
++ __res_nameinquery F
++ __res_ownok F
++ __res_queriesmatch F
++ __res_send F
++ __sym_ntop F
++ __sym_ntos F
++ __sym_ston F
++ _gethtbyaddr F
++ _gethtbyname F
++ _gethtbyname2 F
++ _gethtent F
++ _getlong F
++ _getshort F
++ _res_opcodes D 0x40
++ _sethtent F
++ dn_expand F
++ inet_net_ntop F
++ inet_net_pton F
++ inet_neta F
++ res_gethostbyaddr F
++ res_gethostbyname F
++ res_gethostbyname2 F
++ res_mkquery F
++ res_query F
++ res_querydomain F
++ res_search F
++ res_send_setqhook F
++ res_send_setrhook F
++GLIBC_2.2
++ GLIBC_2.2 A
++ __dn_expand F
++ __res_hostalias F
++ __res_mkquery F
++ __res_nmkquery F
++ __res_nquery F
++ __res_nquerydomain F
++ __res_nsearch F
++ __res_nsend F
++ __res_query F
++ __res_querydomain F
++ __res_search F
++GLIBC_2.3.2
++ GLIBC_2.3.2 A
++ __p_rcode F
++GLIBC_2.9
++ GLIBC_2.9 A
++ ns_datetosecs F
++ ns_format_ttl F
++ ns_get16 F
++ ns_get32 F
++ ns_initparse F
++ ns_makecanon F
++ ns_msg_getflag F
++ ns_name_compress F
++ ns_name_ntol F
++ ns_name_ntop F
++ ns_name_pack F
++ ns_name_pton F
++ ns_name_rollback F
++ ns_name_skip F
++ ns_name_uncompress F
++ ns_name_unpack F
++ ns_parse_ttl F
++ ns_parserr F
++ ns_put16 F
++ ns_put32 F
++ ns_samedomain F
++ ns_samename F
++ ns_skiprr F
++ ns_sprintrr F
++ ns_sprintrrf F
++ ns_subdomain F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/or1k_clone.S
+@@ -0,0 +1,92 @@
++#include <sysdep.h>
++#include <linux/sched.h>
++#include <tls.h>
++
++.text
++ENTRY(__or1k_clone)
++
++	/* To handle GCC varargs we need to use our __clone wrapper to pop
++	   everything from the stack for us.
++	   Now everything is placed in the registers which saves us a lot 
++	   of trouble.
++
++	   The userland implementation is:
++		  int clone (int (*fn)(void *), void *child_stack,
++			    int flags, void *arg, pid_t *ptid,
++			    struct user_desc *tls, pid_t *ctid);
++
++	     The kernel entry is:
++		  int clone (long flags, void *child_stack, int *parent_tid,
++			  int *child_tid, struct void *tls)
++	     NB: tls isn't really an argument, it is read from r7 directly.
++	*/
++
++	/* Put 'fn', 'arg' and 'flags' on child stack */
++	l.sw  -4(r4), r3
++	l.sw  -8(r4), r6
++	l.sw  -12(r4), r5
++
++	/* Set all arguments */
++	l.ori r3, r5, 0
++	/* child_stack is already in r4 */
++	l.ori r5, r7, 0
++	l.lwz r6, 0(r1)
++	l.ori r7, r8, 0
++
++	DO_CALL (clone)
++
++	l.sfgeui r11, 0xf001
++	l.bf .Lerror
++	l.nop
++
++	/* If we are not the child, return the pid */
++	l.sfeqi r11, 0
++	l.bf .Lchild
++	l.nop
++
++	l.jr r9
++	l.nop
++
++.Lchild:
++	/* Load flags */
++	l.lwz r3, -12(r1)
++
++	/* Update PID, but only if we do not share the same PID 
++	   as our parent */
++	l.srli  r4, r3, 16
++	l.andi r4, r4, hi(CLONE_THREAD)
++	l.sfnei r4, 0
++	l.bf .Loldpid
++
++	/* If we share the same memory space, reset the PID/TID values.
++	   Apparently getpid caches, so we want to make sure it's flushed */
++	l.ori r11, r0, -1
++	l.andi r4, r3, CLONE_VM
++	l.sfnei r4, 0
++	l.bf .Lsetpid
++	l.nop
++
++	/* Else we update them */
++	DO_CALL (getpid)
++
++.Lsetpid:
++	l.addi r3, r10, TP_TO_PTHREAD_OFFSET
++	l.sw PTHREAD_PID_OFFSET(r3), r11
++	l.sw PTHREAD_TID_OFFSET(r3), r11
++	
++
++.Loldpid:
++	/* Load function from stack */
++	l.lwz r9, -4(r1)
++	l.jr r9
++	l.lwz r3, -8(r1)
++
++	/* Exit the child thread */
++	l.jal HIDDEN_JUMPTARGET(_exit)
++	l.ori r3, r11, 0
++
++.Lerror:
++	l.j SYSCALL_ERROR_NAME
++	l.ori r3,r11,0
++
++PSEUDO_END (__or1k_clone)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libBrokenLocale.abilist
+@@ -0,0 +1,3 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ __ctype_get_mb_cur_max F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libm.abilist
+@@ -0,0 +1,383 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ _LIB_VERSION D 0x4
++ acos F
++ acosf F
++ acosh F
++ acoshf F
++ acoshl F
++ acosl F
++ asin F
++ asinf F
++ asinh F
++ asinhf F
++ asinhl F
++ asinl F
++ atan F
++ atan2 F
++ atan2f F
++ atan2l F
++ atanf F
++ atanh F
++ atanhf F
++ atanhl F
++ atanl F
++ cbrt F
++ cbrtf F
++ cbrtl F
++ ceil F
++ ceilf F
++ ceill F
++ copysign F
++ copysignf F
++ copysignl F
++ cos F
++ cosf F
++ cosh F
++ coshf F
++ coshl F
++ cosl F
++ drem F
++ dremf F
++ dreml F
++ erf F
++ erfc F
++ erfcf F
++ erfcl F
++ erff F
++ erfl F
++ exp F
++ expf F
++ expl F
++ expm1 F
++ expm1f F
++ expm1l F
++ fabs F
++ fabsf F
++ fabsl F
++ finite F
++ finitef F
++ finitel F
++ floor F
++ floorf F
++ floorl F
++ fmod F
++ fmodf F
++ fmodl F
++ frexp F
++ frexpf F
++ frexpl F
++ gamma F
++ gammaf F
++ gammal F
++ hypot F
++ hypotf F
++ hypotl F
++ ilogb F
++ ilogbf F
++ ilogbl F
++ j0 F
++ j0f F
++ j0l F
++ j1 F
++ j1f F
++ j1l F
++ jn F
++ jnf F
++ jnl F
++ ldexp F
++ ldexpf F
++ ldexpl F
++ lgamma F
++ lgamma_r F
++ lgammaf F
++ lgammaf_r F
++ lgammal F
++ lgammal_r F
++ log F
++ log10 F
++ log10f F
++ log10l F
++ log1p F
++ log1pf F
++ log1pl F
++ logb F
++ logbf F
++ logbl F
++ logf F
++ logl F
++ matherr F
++ modf F
++ modff F
++ modfl F
++ nextafter F
++ nextafterf F
++ nextafterl F
++ pow F
++ powf F
++ powl F
++ remainder F
++ remainderf F
++ remainderl F
++ rint F
++ rintf F
++ rintl F
++ scalb F
++ scalbf F
++ scalbl F
++ scalbn F
++ scalbnf F
++ scalbnl F
++ signgam D 0x4
++ significand F
++ significandf F
++ significandl F
++ sin F
++ sinf F
++ sinh F
++ sinhf F
++ sinhl F
++ sinl F
++ sqrt F
++ sqrtf F
++ sqrtl F
++ tan F
++ tanf F
++ tanh F
++ tanhf F
++ tanhl F
++ tanl F
++ y0 F
++ y0f F
++ y0l F
++ y1 F
++ y1f F
++ y1l F
++ yn F
++ ynf F
++ ynl F
++GLIBC_2.1
++ GLIBC_2.1 A
++ __clog10 F
++ __clog10f F
++ __clog10l F
++ __finite F
++ __finitef F
++ __finitel F
++ __fpclassify F
++ __fpclassifyf F
++ __signbit F
++ __signbitf F
++ cabs F
++ cabsf F
++ cabsl F
++ cacos F
++ cacosf F
++ cacosh F
++ cacoshf F
++ cacoshl F
++ cacosl F
++ carg F
++ cargf F
++ cargl F
++ casin F
++ casinf F
++ casinh F
++ casinhf F
++ casinhl F
++ casinl F
++ catan F
++ catanf F
++ catanh F
++ catanhf F
++ catanhl F
++ catanl F
++ ccos F
++ ccosf F
++ ccosh F
++ ccoshf F
++ ccoshl F
++ ccosl F
++ cexp F
++ cexpf F
++ cexpl F
++ cimag F
++ cimagf F
++ cimagl F
++ clog F
++ clog10 F
++ clog10f F
++ clog10l F
++ clogf F
++ clogl F
++ conj F
++ conjf F
++ conjl F
++ cpow F
++ cpowf F
++ cpowl F
++ cproj F
++ cprojf F
++ cprojl F
++ creal F
++ crealf F
++ creall F
++ csin F
++ csinf F
++ csinh F
++ csinhf F
++ csinhl F
++ csinl F
++ csqrt F
++ csqrtf F
++ csqrtl F
++ ctan F
++ ctanf F
++ ctanh F
++ ctanhf F
++ ctanhl F
++ ctanl F
++ exp10 F
++ exp10f F
++ exp10l F
++ exp2 F
++ exp2f F
++ fdim F
++ fdimf F
++ fdiml F
++ feclearexcept F
++ fegetenv F
++ fegetexceptflag F
++ fegetround F
++ feholdexcept F
++ feraiseexcept F
++ fesetenv F
++ fesetexceptflag F
++ fesetround F
++ fetestexcept F
++ feupdateenv F
++ fma F
++ fmaf F
++ fmal F
++ fmax F
++ fmaxf F
++ fmaxl F
++ fmin F
++ fminf F
++ fminl F
++ llrint F
++ llrintf F
++ llrintl F
++ llround F
++ llroundf F
++ llroundl F
++ log2 F
++ log2f F
++ log2l F
++ lrint F
++ lrintf F
++ lrintl F
++ lround F
++ lroundf F
++ lroundl F
++ nan F
++ nanf F
++ nanl F
++ nearbyint F
++ nearbyintf F
++ nearbyintl F
++ nexttoward F
++ nexttowardf F
++ nexttowardl F
++ pow10 F
++ pow10f F
++ pow10l F
++ remquo F
++ remquof F
++ remquol F
++ round F
++ roundf F
++ roundl F
++ scalbln F
++ scalblnf F
++ scalblnl F
++ sincos F
++ sincosf F
++ sincosl F
++ tgamma F
++ tgammaf F
++ tgammal F
++ trunc F
++ truncf F
++ truncl F
++GLIBC_2.15
++ GLIBC_2.15 A
++ __acos_finite F
++ __acosf_finite F
++ __acosh_finite F
++ __acoshf_finite F
++ __asin_finite F
++ __asinf_finite F
++ __atan2_finite F
++ __atan2f_finite F
++ __atanh_finite F
++ __atanhf_finite F
++ __cosh_finite F
++ __coshf_finite F
++ __exp10_finite F
++ __exp10f_finite F
++ __exp2_finite F
++ __exp2f_finite F
++ __exp_finite F
++ __expf_finite F
++ __fmod_finite F
++ __fmodf_finite F
++ __gamma_r_finite F
++ __gammaf_r_finite F
++ __hypot_finite F
++ __hypotf_finite F
++ __j0_finite F
++ __j0f_finite F
++ __j1_finite F
++ __j1f_finite F
++ __jn_finite F
++ __jnf_finite F
++ __lgamma_r_finite F
++ __lgammaf_r_finite F
++ __log10_finite F
++ __log10f_finite F
++ __log2_finite F
++ __log2f_finite F
++ __log_finite F
++ __logf_finite F
++ __pow_finite F
++ __powf_finite F
++ __remainder_finite F
++ __remainderf_finite F
++ __scalb_finite F
++ __scalbf_finite F
++ __sinh_finite F
++ __sinhf_finite F
++ __sqrt_finite F
++ __sqrtf_finite F
++ __y0_finite F
++ __y0f_finite F
++ __y1_finite F
++ __y1f_finite F
++ __yn_finite F
++ __ynf_finite F
++GLIBC_2.2
++ GLIBC_2.2 A
++ feclearexcept F
++ fedisableexcept F
++ feenableexcept F
++ fegetenv F
++ fegetexcept F
++ fegetexceptflag F
++ feraiseexcept F
++ fesetenv F
++ fesetexceptflag F
++ feupdateenv F
++GLIBC_2.4
++ GLIBC_2.4 A
++ exp2l F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/vfork.c
+@@ -0,0 +1,30 @@
++/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <errno.h>
++#include <unistd.h>
++
++/* If we don't have vfork, fork is close enough.  */
++
++__pid_t
++__vfork (void)
++{
++  return __fork ();
++}
++libc_hidden_def (__vfork)
++
++weak_alias (__vfork, vfork)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libpthread.abilist
+@@ -0,0 +1,267 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ _IO_flockfile F
++ _IO_ftrylockfile F
++ _IO_funlockfile F
++ __close F
++ __connect F
++ __errno_location F
++ __fcntl F
++ __fork F
++ __h_errno_location F
++ __lseek F
++ __open F
++ __pthread_getspecific F
++ __pthread_key_create F
++ __pthread_mutex_destroy F
++ __pthread_mutex_init F
++ __pthread_mutex_lock F
++ __pthread_mutex_trylock F
++ __pthread_mutex_unlock F
++ __pthread_mutexattr_destroy F
++ __pthread_mutexattr_init F
++ __pthread_mutexattr_settype F
++ __pthread_once F
++ __pthread_setspecific F
++ __read F
++ __send F
++ __sigaction F
++ __wait F
++ __write F
++ _pthread_cleanup_pop F
++ _pthread_cleanup_pop_restore F
++ _pthread_cleanup_push F
++ _pthread_cleanup_push_defer F
++ accept F
++ close F
++ connect F
++ fcntl F
++ flockfile F
++ fork F
++ fsync F
++ ftrylockfile F
++ funlockfile F
++ longjmp F
++ lseek F
++ msync F
++ nanosleep F
++ open F
++ pause F
++ pthread_atfork F
++ pthread_attr_destroy F
++ pthread_attr_getdetachstate F
++ pthread_attr_getinheritsched F
++ pthread_attr_getschedparam F
++ pthread_attr_getschedpolicy F
++ pthread_attr_getscope F
++ pthread_attr_init F
++ pthread_attr_setdetachstate F
++ pthread_attr_setinheritsched F
++ pthread_attr_setschedparam F
++ pthread_attr_setschedpolicy F
++ pthread_attr_setscope F
++ pthread_cancel F
++ pthread_cond_broadcast F
++ pthread_cond_destroy F
++ pthread_cond_init F
++ pthread_cond_signal F
++ pthread_cond_timedwait F
++ pthread_cond_wait F
++ pthread_condattr_destroy F
++ pthread_condattr_init F
++ pthread_create F
++ pthread_detach F
++ pthread_equal F
++ pthread_exit F
++ pthread_getschedparam F
++ pthread_getspecific F
++ pthread_join F
++ pthread_key_create F
++ pthread_key_delete F
++ pthread_kill F
++ pthread_kill_other_threads_np F
++ pthread_mutex_destroy F
++ pthread_mutex_init F
++ pthread_mutex_lock F
++ pthread_mutex_trylock F
++ pthread_mutex_unlock F
++ pthread_mutexattr_destroy F
++ pthread_mutexattr_getkind_np F
++ pthread_mutexattr_init F
++ pthread_mutexattr_setkind_np F
++ pthread_once F
++ pthread_self F
++ pthread_setcancelstate F
++ pthread_setcanceltype F
++ pthread_setschedparam F
++ pthread_setspecific F
++ pthread_sigmask F
++ pthread_testcancel F
++ raise F
++ read F
++ recv F
++ recvfrom F
++ recvmsg F
++ sem_destroy F
++ sem_getvalue F
++ sem_init F
++ sem_post F
++ sem_trywait F
++ sem_wait F
++ send F
++ sendmsg F
++ sendto F
++ sigaction F
++ siglongjmp F
++ sigwait F
++ system F
++ tcdrain F
++ vfork F
++ wait F
++ waitpid F
++ write F
++GLIBC_2.1
++ GLIBC_2.1 A
++ __libc_allocate_rtsig F
++ __libc_current_sigrtmax F
++ __libc_current_sigrtmin F
++ pthread_attr_getguardsize F
++ pthread_attr_getstackaddr F
++ pthread_attr_getstacksize F
++ pthread_attr_init F
++ pthread_attr_setguardsize F
++ pthread_attr_setstackaddr F
++ pthread_attr_setstacksize F
++ pthread_create F
++ pthread_getconcurrency F
++ pthread_mutexattr_gettype F
++ pthread_mutexattr_settype F
++ pthread_rwlock_destroy F
++ pthread_rwlock_init F
++ pthread_rwlock_rdlock F
++ pthread_rwlock_tryrdlock F
++ pthread_rwlock_trywrlock F
++ pthread_rwlock_unlock F
++ pthread_rwlock_wrlock F
++ pthread_rwlockattr_destroy F
++ pthread_rwlockattr_getkind_np F
++ pthread_rwlockattr_getpshared F
++ pthread_rwlockattr_init F
++ pthread_rwlockattr_setkind_np F
++ pthread_rwlockattr_setpshared F
++ pthread_setconcurrency F
++ sem_destroy F
++ sem_getvalue F
++ sem_init F
++ sem_post F
++ sem_trywait F
++ sem_wait F
++GLIBC_2.1.1
++ GLIBC_2.1.1 A
++ sem_close F
++ sem_open F
++ sem_unlink F
++GLIBC_2.1.2
++ GLIBC_2.1.2 A
++ __vfork F
++GLIBC_2.11
++ GLIBC_2.11 A
++ pthread_sigqueue F
++GLIBC_2.12
++ GLIBC_2.12 A
++ pthread_getname_np F
++ pthread_mutex_consistent F
++ pthread_mutexattr_getrobust F
++ pthread_mutexattr_setrobust F
++ pthread_setname_np F
++GLIBC_2.2
++ GLIBC_2.2 A
++ __open64 F
++ __pread64 F
++ __pthread_rwlock_destroy F
++ __pthread_rwlock_init F
++ __pthread_rwlock_rdlock F
++ __pthread_rwlock_tryrdlock F
++ __pthread_rwlock_trywrlock F
++ __pthread_rwlock_unlock F
++ __pthread_rwlock_wrlock F
++ __pwrite64 F
++ __res_state F
++ lseek64 F
++ open64 F
++ pread F
++ pread64 F
++ pthread_attr_getstack F
++ pthread_attr_setstack F
++ pthread_barrier_destroy F
++ pthread_barrier_init F
++ pthread_barrier_wait F
++ pthread_barrierattr_destroy F
++ pthread_barrierattr_init F
++ pthread_barrierattr_setpshared F
++ pthread_condattr_getpshared F
++ pthread_condattr_setpshared F
++ pthread_getcpuclockid F
++ pthread_mutex_timedlock F
++ pthread_mutexattr_getpshared F
++ pthread_mutexattr_setpshared F
++ pthread_rwlock_timedrdlock F
++ pthread_rwlock_timedwrlock F
++ pthread_spin_destroy F
++ pthread_spin_init F
++ pthread_spin_lock F
++ pthread_spin_trylock F
++ pthread_spin_unlock F
++ pthread_yield F
++ pwrite F
++ pwrite64 F
++ sem_timedwait F
++GLIBC_2.2.3
++ GLIBC_2.2.3 A
++ pthread_getattr_np F
++GLIBC_2.2.6
++ GLIBC_2.2.6 A
++ __nanosleep F
++GLIBC_2.3.2
++ GLIBC_2.3.2 A
++ pthread_cond_broadcast F
++ pthread_cond_destroy F
++ pthread_cond_init F
++ pthread_cond_signal F
++ pthread_cond_timedwait F
++ pthread_cond_wait F
++GLIBC_2.3.3
++ GLIBC_2.3.3 A
++ __pthread_cleanup_routine F
++ __pthread_register_cancel F
++ __pthread_register_cancel_defer F
++ __pthread_unregister_cancel F
++ __pthread_unregister_cancel_restore F
++ __pthread_unwind_next F
++ pthread_attr_getaffinity_np F
++ pthread_attr_setaffinity_np F
++ pthread_barrierattr_getpshared F
++ pthread_condattr_getclock F
++ pthread_condattr_setclock F
++ pthread_getaffinity_np F
++ pthread_setaffinity_np F
++ pthread_timedjoin_np F
++ pthread_tryjoin_np F
++GLIBC_2.3.4
++ GLIBC_2.3.4 A
++ pthread_attr_getaffinity_np F
++ pthread_attr_setaffinity_np F
++ pthread_getaffinity_np F
++ pthread_setaffinity_np F
++ pthread_setschedprio F
++GLIBC_2.4
++ GLIBC_2.4 A
++ pthread_mutex_consistent_np F
++ pthread_mutex_getprioceiling F
++ pthread_mutex_setprioceiling F
++ pthread_mutexattr_getprioceiling F
++ pthread_mutexattr_getprotocol F
++ pthread_mutexattr_getrobust_np F
++ pthread_mutexattr_setprioceiling F
++ pthread_mutexattr_setprotocol F
++ pthread_mutexattr_setrobust_np F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/pthread_once.c
+@@ -0,0 +1,94 @@
++/* Copyright (C) 2011-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
++   Based on work contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <nptl/pthreadP.h>
++#include <lowlevellock.h>
++
++
++unsigned long int __fork_generation attribute_hidden;
++
++
++static void
++clear_once_control (void *arg)
++{
++  pthread_once_t *once_control = (pthread_once_t *) arg;
++
++  *once_control = 0;
++  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
++}
++
++
++int
++__pthread_once (once_control, init_routine)
++     pthread_once_t *once_control;
++     void (*init_routine) (void);
++{
++  while (1)
++    {
++      int oldval, val, newval;
++
++      val = *once_control;
++      do
++	{
++	  /* Check if the initialized has already been done.  */
++	  if ((val & 2) != 0)
++	    return 0;
++
++	  oldval = val;
++	  newval = (oldval & 3) | __fork_generation | 1;
++	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
++						     oldval);
++	}
++      while (__builtin_expect (val != oldval, 0));
++
++      /* Check if another thread already runs the initializer.	*/
++      if ((oldval & 1) != 0)
++	{
++	  /* Check whether the initializer execution was interrupted
++	     by a fork.	 */
++	  if (((oldval ^ newval) & -4) == 0)
++	    {
++	      /* Same generation, some other thread was faster. Wait.  */
++	      lll_futex_wait (once_control, newval, LLL_PRIVATE);
++	      continue;
++	    }
++	}
++
++      /* This thread is the first here.  Do the initialization.
++	 Register a cleanup handler so that in case the thread gets
++	 interrupted the initialization can be restarted.  */
++      pthread_cleanup_push (clear_once_control, once_control);
++
++      init_routine ();
++
++      pthread_cleanup_pop (0);
++
++
++      /* Add one to *once_control.  */
++      atomic_increment (once_control);
++
++      /* Wake up all other threads.  */
++      lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
++      break;
++    }
++
++  return 0;
++}
++weak_alias (__pthread_once, pthread_once)
++hidden_def (__pthread_once)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libc.abilist
+@@ -0,0 +1,2253 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ _IO_adjust_column F
++ _IO_default_doallocate F
++ _IO_default_finish F
++ _IO_default_pbackfail F
++ _IO_default_uflow F
++ _IO_default_xsgetn F
++ _IO_default_xsputn F
++ _IO_do_write F
++ _IO_doallocbuf F
++ _IO_fclose F
++ _IO_fdopen F
++ _IO_feof F
++ _IO_ferror F
++ _IO_fflush F
++ _IO_fgetpos F
++ _IO_fgets F
++ _IO_file_attach F
++ _IO_file_close F
++ _IO_file_close_it F
++ _IO_file_doallocate F
++ _IO_file_fopen F
++ _IO_file_init F
++ _IO_file_jumps D 0x54
++ _IO_file_open F
++ _IO_file_overflow F
++ _IO_file_read F
++ _IO_file_seek F
++ _IO_file_seekoff F
++ _IO_file_setbuf F
++ _IO_file_stat F
++ _IO_file_sync F
++ _IO_file_underflow F
++ _IO_file_write F
++ _IO_file_xsputn F
++ _IO_flockfile F
++ _IO_flush_all F
++ _IO_flush_all_linebuffered F
++ _IO_fopen F
++ _IO_fprintf F
++ _IO_fputs F
++ _IO_fread F
++ _IO_free_backup_area F
++ _IO_fsetpos F
++ _IO_ftell F
++ _IO_ftrylockfile F
++ _IO_funlockfile F
++ _IO_fwrite F
++ _IO_getc F
++ _IO_getline F
++ _IO_gets F
++ _IO_init F
++ _IO_init_marker F
++ _IO_link_in F
++ _IO_list_all D 0x4
++ _IO_marker_delta F
++ _IO_marker_difference F
++ _IO_padn F
++ _IO_peekc_locked F
++ _IO_popen F
++ _IO_printf F
++ _IO_proc_close F
++ _IO_proc_open F
++ _IO_putc F
++ _IO_puts F
++ _IO_remove_marker F
++ _IO_seekmark F
++ _IO_seekoff F
++ _IO_seekpos F
++ _IO_setb F
++ _IO_setbuffer F
++ _IO_setvbuf F
++ _IO_sgetn F
++ _IO_sprintf F
++ _IO_sputbackc F
++ _IO_sscanf F
++ _IO_stderr_ D 0x50
++ _IO_stdin_ D 0x50
++ _IO_stdout_ D 0x50
++ _IO_str_init_readonly F
++ _IO_str_init_static F
++ _IO_str_overflow F
++ _IO_str_pbackfail F
++ _IO_str_seekoff F
++ _IO_str_underflow F
++ _IO_sungetc F
++ _IO_switch_to_get_mode F
++ _IO_un_link F
++ _IO_ungetc F
++ _IO_unsave_markers F
++ _IO_vfprintf F
++ _IO_vfscanf F
++ _IO_vsprintf F
++ ___brk_addr D 0x4
++ __adjtimex F
++ __after_morecore_hook D 0x4
++ __argz_count F
++ __argz_next F
++ __argz_stringify F
++ __assert_fail F
++ __assert_perror_fail F
++ __bsd_getpgrp F
++ __bzero F
++ __check_rhosts_file D 0x4
++ __clone F
++ __close F
++ __cmsg_nxthdr F
++ __connect F
++ __ctype32_b D 0x4
++ __ctype_b D 0x4
++ __ctype_get_mb_cur_max F
++ __ctype_tolower D 0x4
++ __ctype_toupper D 0x4
++ __curbrk D 0x4
++ __daylight D 0x4
++ __dcgettext F
++ __default_morecore F
++ __dgettext F
++ __dup2 F
++ __environ D 0x4
++ __errno_location F
++ __fcntl F
++ __ffs F
++ __finite F
++ __finitef F
++ __finitel F
++ __fork F
++ __fpu_control D 0x4
++ __free_hook D 0x4
++ __fxstat F
++ __getdelim F
++ __getpagesize F
++ __getpgid F
++ __getpid F
++ __gettimeofday F
++ __gmtime_r F
++ __h_errno_location F
++ __isinf F
++ __isinff F
++ __isinfl F
++ __isnan F
++ __isnanf F
++ __isnanl F
++ __iswctype F
++ __ivaliduser F
++ __libc_calloc F
++ __libc_free F
++ __libc_init_first F
++ __libc_mallinfo F
++ __libc_malloc F
++ __libc_mallopt F
++ __libc_memalign F
++ __libc_pvalloc F
++ __libc_realloc F
++ __libc_start_main F
++ __libc_valloc F
++ __lseek F
++ __lxstat F
++ __malloc_hook D 0x4
++ __malloc_initialize_hook D 0x4
++ __mbrlen F
++ __mbrtowc F
++ __memalign_hook D 0x4
++ __mempcpy F
++ __monstartup F
++ __morecore D 0x4
++ __nss_configure_lookup F
++ __nss_database_lookup F
++ __nss_group_lookup F
++ __nss_hosts_lookup F
++ __nss_next F
++ __nss_passwd_lookup F
++ __open F
++ __overflow F
++ __pipe F
++ __printf_fp F
++ __profile_frequency F
++ __progname D 0x4
++ __progname_full D 0x4
++ __rcmd_errstr D 0x4
++ __read F
++ __realloc_hook D 0x4
++ __res_randomid F
++ __sbrk F
++ __sched_get_priority_max F
++ __sched_get_priority_min F
++ __sched_getparam F
++ __sched_getscheduler F
++ __sched_setscheduler F
++ __sched_yield F
++ __secure_getenv F
++ __select F
++ __setpgid F
++ __sigaction F
++ __sigaddset F
++ __sigdelset F
++ __sigismember F
++ __sigpause F
++ __sigsetjmp F
++ __stpcpy F
++ __stpncpy F
++ __strcasecmp F
++ __strdup F
++ __strerror_r F
++ __strtod_internal F
++ __strtof_internal F
++ __strtok_r F
++ __strtol_internal F
++ __strtold_internal F
++ __strtoll_internal F
++ __strtoq_internal F
++ __strtoul_internal F
++ __strtoull_internal F
++ __strtouq_internal F
++ __sysv_signal F
++ __timezone D 0x4
++ __tzname D 0x8
++ __uflow F
++ __underflow F
++ __vfscanf F
++ __vsnprintf F
++ __vsscanf F
++ __wait F
++ __waitpid F
++ __wcstod_internal F
++ __wcstof_internal F
++ __wcstol_internal F
++ __wcstold_internal F
++ __wcstoll_internal F
++ __wcstoul_internal F
++ __wcstoull_internal F
++ __write F
++ __xmknod F
++ __xpg_basename F
++ __xstat F
++ _environ D 0x4
++ _exit F
++ _libc_intl_domainname D 0x5
++ _longjmp F
++ _mcleanup F
++ _mcount F
++ _nl_default_dirname D 0x12
++ _nl_domain_bindings D 0x4
++ _nl_msg_cat_cntr D 0x4
++ _null_auth D 0xc
++ _obstack D 0x4
++ _obstack_allocated_p F
++ _obstack_begin F
++ _obstack_begin_1 F
++ _obstack_free F
++ _obstack_memory_used F
++ _obstack_newchunk F
++ _res D 0x200
++ _rpc_dtablesize F
++ _seterr_reply F
++ _setjmp F
++ _sys_errlist D 0x1ec
++ _sys_nerr D 0x4
++ _sys_siglist D 0x80
++ _tolower F
++ _toupper F
++ a64l F
++ abort F
++ abs F
++ accept F
++ access F
++ acct F
++ addmntent F
++ adjtime F
++ adjtimex F
++ advance F
++ alarm F
++ alphasort F
++ argz_add F
++ argz_add_sep F
++ argz_append F
++ argz_count F
++ argz_create F
++ argz_create_sep F
++ argz_delete F
++ argz_extract F
++ argz_insert F
++ argz_next F
++ argz_replace F
++ argz_stringify F
++ asctime F
++ asctime_r F
++ asprintf F
++ atexit F
++ atof F
++ atoi F
++ atol F
++ atoll F
++ authnone_create F
++ authunix_create F
++ authunix_create_default F
++ basename F
++ bcmp F
++ bcopy F
++ bdflush F
++ bind F
++ bindresvport F
++ bindtextdomain F
++ brk F
++ bsd_signal F
++ bsearch F
++ btowc F
++ bzero F
++ calloc F
++ callrpc F
++ canonicalize_file_name F
++ catclose F
++ catgets F
++ catopen F
++ cfgetispeed F
++ cfgetospeed F
++ cfmakeraw F
++ cfree F
++ cfsetispeed F
++ cfsetospeed F
++ cfsetspeed F
++ chdir F
++ chflags F
++ chmod F
++ chown F
++ chroot F
++ clearenv F
++ clearerr F
++ clearerr_unlocked F
++ clnt_broadcast F
++ clnt_create F
++ clnt_pcreateerror F
++ clnt_perrno F
++ clnt_perror F
++ clnt_spcreateerror F
++ clnt_sperrno F
++ clnt_sperror F
++ clntraw_create F
++ clnttcp_create F
++ clntudp_bufcreate F
++ clntudp_create F
++ clock F
++ clone F
++ close F
++ closedir F
++ closelog F
++ confstr F
++ connect F
++ copysign F
++ copysignf F
++ copysignl F
++ creat F
++ create_module F
++ ctermid F
++ ctime F
++ ctime_r F
++ cuserid F
++ daemon F
++ daylight D 0x4
++ dcgettext F
++ delete_module F
++ dgettext F
++ difftime F
++ dirfd F
++ dirname F
++ div F
++ dprintf F
++ drand48 F
++ drand48_r F
++ dup F
++ dup2 F
++ dysize F
++ ecvt F
++ ecvt_r F
++ endaliasent F
++ endfsent F
++ endgrent F
++ endhostent F
++ endmntent F
++ endnetent F
++ endnetgrent F
++ endprotoent F
++ endpwent F
++ endrpcent F
++ endservent F
++ endspent F
++ endttyent F
++ endusershell F
++ endutent F
++ environ D 0x4
++ envz_add F
++ envz_entry F
++ envz_get F
++ envz_merge F
++ envz_remove F
++ envz_strip F
++ erand48 F
++ erand48_r F
++ err F
++ error F
++ error_at_line F
++ error_message_count D 0x4
++ error_one_per_line D 0x4
++ error_print_progname D 0x4
++ errx F
++ ether_aton F
++ ether_aton_r F
++ ether_hostton F
++ ether_line F
++ ether_ntoa F
++ ether_ntoa_r F
++ ether_ntohost F
++ euidaccess F
++ execl F
++ execle F
++ execlp F
++ execv F
++ execve F
++ execvp F
++ exit F
++ fchdir F
++ fchflags F
++ fchmod F
++ fchown F
++ fclose F
++ fcloseall F
++ fcntl F
++ fcvt F
++ fcvt_r F
++ fdatasync F
++ fdopen F
++ feof F
++ feof_unlocked F
++ ferror F
++ ferror_unlocked F
++ fexecve F
++ fflush F
++ fflush_unlocked F
++ ffs F
++ fgetc F
++ fgetgrent F
++ fgetgrent_r F
++ fgetpos F
++ fgetpwent F
++ fgetpwent_r F
++ fgets F
++ fgetspent F
++ fgetspent_r F
++ fileno F
++ fileno_unlocked F
++ finite F
++ finitef F
++ finitel F
++ flock F
++ flockfile F
++ fnmatch F
++ fopen F
++ fopencookie F
++ fork F
++ fpathconf F
++ fprintf F
++ fputc F
++ fputc_unlocked F
++ fputs F
++ fread F
++ free F
++ freeaddrinfo F
++ freopen F
++ frexp F
++ frexpf F
++ frexpl F
++ fscanf F
++ fseek F
++ fsetpos F
++ fstatfs F
++ fsync F
++ ftell F
++ ftime F
++ ftok F
++ ftruncate F
++ ftrylockfile F
++ fts_children F
++ fts_close F
++ fts_open F
++ fts_read F
++ fts_set F
++ ftw F
++ funlockfile F
++ fwrite F
++ gcvt F
++ get_avphys_pages F
++ get_current_dir_name F
++ get_kernel_syms F
++ get_myaddress F
++ get_nprocs F
++ get_nprocs_conf F
++ get_phys_pages F
++ getaddrinfo F
++ getaliasbyname F
++ getaliasbyname_r F
++ getaliasent F
++ getaliasent_r F
++ getc F
++ getc_unlocked F
++ getchar F
++ getchar_unlocked F
++ getcwd F
++ getdelim F
++ getdirentries F
++ getdomainname F
++ getdtablesize F
++ getegid F
++ getenv F
++ geteuid F
++ getfsent F
++ getfsfile F
++ getfsspec F
++ getgid F
++ getgrent F
++ getgrent_r F
++ getgrgid F
++ getgrgid_r F
++ getgrnam F
++ getgrnam_r F
++ getgroups F
++ gethostbyaddr F
++ gethostbyaddr_r F
++ gethostbyname F
++ gethostbyname2 F
++ gethostbyname2_r F
++ gethostbyname_r F
++ gethostent F
++ gethostent_r F
++ gethostid F
++ gethostname F
++ getitimer F
++ getline F
++ getlogin F
++ getlogin_r F
++ getmntent F
++ getmntent_r F
++ getnetbyaddr F
++ getnetbyaddr_r F
++ getnetbyname F
++ getnetbyname_r F
++ getnetent F
++ getnetent_r F
++ getnetgrent F
++ getnetgrent_r F
++ getopt F
++ getopt_long F
++ getopt_long_only F
++ getpagesize F
++ getpass F
++ getpeername F
++ getpgid F
++ getpgrp F
++ getpid F
++ getppid F
++ getpriority F
++ getprotobyname F
++ getprotobyname_r F
++ getprotobynumber F
++ getprotobynumber_r F
++ getprotoent F
++ getprotoent_r F
++ getpublickey F
++ getpw F
++ getpwent F
++ getpwent_r F
++ getpwnam F
++ getpwnam_r F
++ getpwuid F
++ getpwuid_r F
++ getresgid F
++ getresuid F
++ getrlimit F
++ getrpcbyname F
++ getrpcbyname_r F
++ getrpcbynumber F
++ getrpcbynumber_r F
++ getrpcent F
++ getrpcent_r F
++ getrpcport F
++ getrusage F
++ gets F
++ getsecretkey F
++ getservbyname F
++ getservbyname_r F
++ getservbyport F
++ getservbyport_r F
++ getservent F
++ getservent_r F
++ getsid F
++ getsockname F
++ getsockopt F
++ getspent F
++ getspent_r F
++ getspnam F
++ getspnam_r F
++ getsubopt F
++ gettext F
++ gettimeofday F
++ getttyent F
++ getttynam F
++ getuid F
++ getusershell F
++ getutent F
++ getutent_r F
++ getutid F
++ getutid_r F
++ getutline F
++ getutline_r F
++ getw F
++ getwd F
++ glob F
++ glob_pattern_p F
++ globfree F
++ gmtime F
++ gmtime_r F
++ group_member F
++ gsignal F
++ gtty F
++ h_errlist D 0x14
++ h_nerr D 0x4
++ hasmntopt F
++ hcreate F
++ hcreate_r F
++ hdestroy F
++ hdestroy_r F
++ herror F
++ hsearch F
++ hsearch_r F
++ hstrerror F
++ htonl F
++ htons F
++ index F
++ inet_addr F
++ inet_aton F
++ inet_lnaof F
++ inet_makeaddr F
++ inet_netof F
++ inet_network F
++ inet_nsap_addr F
++ inet_nsap_ntoa F
++ inet_ntoa F
++ inet_ntop F
++ inet_pton F
++ init_module F
++ initgroups F
++ initstate F
++ initstate_r F
++ innetgr F
++ insque F
++ ioctl F
++ iruserok F
++ isalnum F
++ isalpha F
++ isascii F
++ isatty F
++ isblank F
++ iscntrl F
++ isdigit F
++ isfdtype F
++ isgraph F
++ isinf F
++ isinff F
++ isinfl F
++ islower F
++ isnan F
++ isnanf F
++ isnanl F
++ isprint F
++ ispunct F
++ isspace F
++ isupper F
++ iswalnum F
++ iswalpha F
++ iswcntrl F
++ iswctype F
++ iswdigit F
++ iswgraph F
++ iswlower F
++ iswprint F
++ iswpunct F
++ iswspace F
++ iswupper F
++ iswxdigit F
++ isxdigit F
++ jrand48 F
++ jrand48_r F
++ kill F
++ killpg F
++ klogctl F
++ l64a F
++ labs F
++ lchown F
++ lckpwdf F
++ lcong48 F
++ lcong48_r F
++ ldexp F
++ ldexpf F
++ ldexpl F
++ ldiv F
++ lfind F
++ link F
++ listen F
++ llabs F
++ lldiv F
++ llseek F
++ loc1 D 0x4
++ loc2 D 0x4
++ localeconv F
++ localtime F
++ localtime_r F
++ lockf F
++ locs D 0x4
++ longjmp F
++ lrand48 F
++ lrand48_r F
++ lsearch F
++ lseek F
++ madvise F
++ mallinfo F
++ malloc F
++ malloc_get_state F
++ malloc_set_state F
++ malloc_stats F
++ malloc_trim F
++ malloc_usable_size F
++ mallopt F
++ mallwatch D 0x4
++ mblen F
++ mbrlen F
++ mbrtowc F
++ mbsinit F
++ mbsnrtowcs F
++ mbsrtowcs F
++ mbstowcs F
++ mbtowc F
++ mcheck F
++ mcount F
++ memalign F
++ memccpy F
++ memchr F
++ memcmp F
++ memcpy F
++ memfrob F
++ memmem F
++ memmove F
++ memset F
++ mkdir F
++ mkfifo F
++ mkstemp F
++ mktemp F
++ mktime F
++ mlock F
++ mlockall F
++ mmap F
++ modf F
++ modff F
++ modfl F
++ monstartup F
++ mount F
++ mprobe F
++ mprotect F
++ mrand48 F
++ mrand48_r F
++ mremap F
++ msgctl F
++ msgget F
++ msgrcv F
++ msgsnd F
++ msync F
++ mtrace F
++ munlock F
++ munlockall F
++ munmap F
++ muntrace F
++ nanosleep F
++ nfsservctl F
++ nice F
++ nl_langinfo F
++ nrand48 F
++ nrand48_r F
++ ntohl F
++ ntohs F
++ obstack_alloc_failed_handler D 0x4
++ obstack_exit_failure D 0x4
++ obstack_free F
++ obstack_printf F
++ obstack_vprintf F
++ on_exit F
++ open F
++ open_memstream F
++ opendir F
++ openlog F
++ optarg D 0x4
++ opterr D 0x4
++ optind D 0x4
++ optopt D 0x4
++ parse_printf_format F
++ pathconf F
++ pause F
++ pclose F
++ perror F
++ personality F
++ pipe F
++ pmap_getmaps F
++ pmap_getport F
++ pmap_rmtcall F
++ pmap_set F
++ pmap_unset F
++ poll F
++ popen F
++ prctl F
++ printf F
++ profil F
++ program_invocation_name D 0x4
++ program_invocation_short_name D 0x4
++ pselect F
++ psignal F
++ pthread_attr_destroy F
++ pthread_attr_getdetachstate F
++ pthread_attr_getinheritsched F
++ pthread_attr_getschedparam F
++ pthread_attr_getschedpolicy F
++ pthread_attr_getscope F
++ pthread_attr_init F
++ pthread_attr_setdetachstate F
++ pthread_attr_setinheritsched F
++ pthread_attr_setschedparam F
++ pthread_attr_setschedpolicy F
++ pthread_attr_setscope F
++ pthread_cond_broadcast F
++ pthread_cond_destroy F
++ pthread_cond_init F
++ pthread_cond_signal F
++ pthread_cond_timedwait F
++ pthread_cond_wait F
++ pthread_condattr_destroy F
++ pthread_condattr_init F
++ pthread_equal F
++ pthread_exit F
++ pthread_getschedparam F
++ pthread_mutex_destroy F
++ pthread_mutex_init F
++ pthread_mutex_lock F
++ pthread_mutex_unlock F
++ pthread_self F
++ pthread_setcancelstate F
++ pthread_setcanceltype F
++ pthread_setschedparam F
++ ptrace F
++ putc F
++ putc_unlocked F
++ putchar F
++ putchar_unlocked F
++ putenv F
++ putpwent F
++ puts F
++ putspent F
++ pututline F
++ putw F
++ pvalloc F
++ qecvt F
++ qecvt_r F
++ qfcvt F
++ qfcvt_r F
++ qgcvt F
++ qsort F
++ query_module F
++ quotactl F
++ raise F
++ rand F
++ rand_r F
++ random F
++ random_r F
++ rcmd F
++ re_comp F
++ re_compile_fastmap F
++ re_compile_pattern F
++ re_exec F
++ re_match F
++ re_match_2 F
++ re_max_failures D 0x4
++ re_search F
++ re_search_2 F
++ re_set_registers F
++ re_set_syntax F
++ re_syntax_options D 0x4
++ read F
++ readdir F
++ readdir_r F
++ readlink F
++ readv F
++ realloc F
++ realpath F
++ reboot F
++ recv F
++ recvfrom F
++ recvmsg F
++ regcomp F
++ regerror F
++ regexec F
++ regfree F
++ register_printf_function F
++ registerrpc F
++ remove F
++ remque F
++ rename F
++ res_init F
++ revoke F
++ rewind F
++ rewinddir F
++ rexec F
++ rexecoptions D 0x4
++ rindex F
++ rmdir F
++ rpc_createerr D 0x10
++ rpmatch F
++ rresvport F
++ ruserok F
++ ruserpass F
++ sbrk F
++ scalbn F
++ scalbnf F
++ scalbnl F
++ scandir F
++ scanf F
++ sched_get_priority_max F
++ sched_get_priority_min F
++ sched_getparam F
++ sched_getscheduler F
++ sched_rr_get_interval F
++ sched_setparam F
++ sched_setscheduler F
++ sched_yield F
++ seed48 F
++ seed48_r F
++ seekdir F
++ select F
++ semget F
++ semop F
++ send F
++ sendmsg F
++ sendto F
++ setaliasent F
++ setbuf F
++ setbuffer F
++ setcontext F
++ setdomainname F
++ setegid F
++ setenv F
++ seteuid F
++ setfsent F
++ setfsgid F
++ setfsuid F
++ setgid F
++ setgrent F
++ setgroups F
++ sethostent F
++ sethostid F
++ sethostname F
++ setitimer F
++ setjmp F
++ setlinebuf F
++ setlocale F
++ setlogin F
++ setlogmask F
++ setmntent F
++ setnetent F
++ setnetgrent F
++ setpgid F
++ setpgrp F
++ setpriority F
++ setprotoent F
++ setpwent F
++ setregid F
++ setresgid F
++ setresuid F
++ setreuid F
++ setrlimit F
++ setrpcent F
++ setservent F
++ setsid F
++ setsockopt F
++ setspent F
++ setstate F
++ setstate_r F
++ settimeofday F
++ setttyent F
++ setuid F
++ setusershell F
++ setutent F
++ setvbuf F
++ sgetspent F
++ sgetspent_r F
++ shmat F
++ shmctl F
++ shmdt F
++ shmget F
++ shutdown F
++ sigaction F
++ sigaddset F
++ sigaltstack F
++ sigandset F
++ sigblock F
++ sigdelset F
++ sigemptyset F
++ sigfillset F
++ siggetmask F
++ siginterrupt F
++ sigisemptyset F
++ sigismember F
++ siglongjmp F
++ signal F
++ sigorset F
++ sigpause F
++ sigpending F
++ sigprocmask F
++ sigreturn F
++ sigsetmask F
++ sigstack F
++ sigsuspend F
++ sigvec F
++ sigwait F
++ sleep F
++ snprintf F
++ socket F
++ socketpair F
++ sprintf F
++ srand F
++ srand48 F
++ srand48_r F
++ srandom F
++ srandom_r F
++ sscanf F
++ ssignal F
++ sstk F
++ statfs F
++ stderr D 0x4
++ stdin D 0x4
++ stdout D 0x4
++ step F
++ stime F
++ stpcpy F
++ stpncpy F
++ strcasecmp F
++ strcat F
++ strchr F
++ strcmp F
++ strcoll F
++ strcpy F
++ strcspn F
++ strdup F
++ strerror F
++ strerror_r F
++ strfmon F
++ strfry F
++ strftime F
++ strlen F
++ strncasecmp F
++ strncat F
++ strncmp F
++ strncpy F
++ strndup F
++ strnlen F
++ strpbrk F
++ strptime F
++ strrchr F
++ strsep F
++ strsignal F
++ strspn F
++ strstr F
++ strtod F
++ strtof F
++ strtok F
++ strtok_r F
++ strtol F
++ strtold F
++ strtoll F
++ strtoq F
++ strtoul F
++ strtoull F
++ strtouq F
++ strxfrm F
++ stty F
++ svc_exit F
++ svc_fdset D 0x80
++ svc_getreq F
++ svc_getreqset F
++ svc_register F
++ svc_run F
++ svc_sendreply F
++ svc_unregister F
++ svcauthdes_stats D 0xc
++ svcerr_auth F
++ svcerr_decode F
++ svcerr_noproc F
++ svcerr_noprog F
++ svcerr_progvers F
++ svcerr_systemerr F
++ svcerr_weakauth F
++ svcfd_create F
++ svcraw_create F
++ svctcp_create F
++ svcudp_bufcreate F
++ svcudp_create F
++ svcudp_enablecache F
++ swab F
++ swapoff F
++ swapon F
++ symlink F
++ sync F
++ sys_errlist D 0x1ec
++ sys_nerr D 0x4
++ sys_sigabbrev D 0x80
++ sys_siglist D 0x80
++ syscall F
++ sysconf F
++ sysctl F
++ sysinfo F
++ syslog F
++ system F
++ tcdrain F
++ tcflow F
++ tcflush F
++ tcgetattr F
++ tcgetpgrp F
++ tcsendbreak F
++ tcsetattr F
++ tcsetpgrp F
++ tdelete F
++ telldir F
++ tempnam F
++ textdomain F
++ tfind F
++ time F
++ timegm F
++ timelocal F
++ times F
++ timezone D 0x4
++ tmpfile F
++ tmpnam F
++ tmpnam_r F
++ toascii F
++ tolower F
++ toupper F
++ towctrans F
++ towlower F
++ towupper F
++ tr_break F
++ truncate F
++ tsearch F
++ ttyname F
++ ttyname_r F
++ ttyslot F
++ twalk F
++ tzname D 0x8
++ tzset F
++ ualarm F
++ ulckpwdf F
++ ulimit F
++ umask F
++ umount F
++ uname F
++ ungetc F
++ unlink F
++ unsetenv F
++ updwtmp F
++ uselib F
++ usleep F
++ ustat F
++ utime F
++ utimes F
++ utmpname F
++ valloc F
++ vasprintf F
++ vdprintf F
++ verr F
++ verrx F
++ vfork F
++ vfprintf F
++ vfscanf F
++ vhangup F
++ vlimit F
++ vprintf F
++ vscanf F
++ vsnprintf F
++ vsprintf F
++ vsscanf F
++ vsyslog F
++ vtimes F
++ vwarn F
++ vwarnx F
++ wait F
++ wait3 F
++ wait4 F
++ waitpid F
++ warn F
++ warnx F
++ wcpcpy F
++ wcpncpy F
++ wcrtomb F
++ wcscat F
++ wcschr F
++ wcscmp F
++ wcscoll F
++ wcscpy F
++ wcscspn F
++ wcsdup F
++ wcslen F
++ wcsncat F
++ wcsncmp F
++ wcsncpy F
++ wcsnrtombs F
++ wcspbrk F
++ wcsrchr F
++ wcsrtombs F
++ wcsspn F
++ wcsstr F
++ wcstod F
++ wcstof F
++ wcstok F
++ wcstol F
++ wcstold F
++ wcstombs F
++ wcstoq F
++ wcstoul F
++ wcstouq F
++ wcswidth F
++ wcsxfrm F
++ wctob F
++ wctomb F
++ wctrans F
++ wctype F
++ wcwidth F
++ wmemchr F
++ wmemcmp F
++ wmemcpy F
++ wmemmove F
++ wmemset F
++ write F
++ writev F
++ xdr_accepted_reply F
++ xdr_array F
++ xdr_authunix_parms F
++ xdr_bool F
++ xdr_bytes F
++ xdr_callhdr F
++ xdr_callmsg F
++ xdr_char F
++ xdr_cryptkeyarg F
++ xdr_cryptkeyarg2 F
++ xdr_cryptkeyres F
++ xdr_des_block F
++ xdr_double F
++ xdr_enum F
++ xdr_float F
++ xdr_free F
++ xdr_int F
++ xdr_key_netstarg F
++ xdr_key_netstres F
++ xdr_keybuf F
++ xdr_keystatus F
++ xdr_long F
++ xdr_netobj F
++ xdr_opaque F
++ xdr_opaque_auth F
++ xdr_pmap F
++ xdr_pmaplist F
++ xdr_pointer F
++ xdr_reference F
++ xdr_rejected_reply F
++ xdr_replymsg F
++ xdr_rmtcall_args F
++ xdr_rmtcallres F
++ xdr_short F
++ xdr_string F
++ xdr_u_char F
++ xdr_u_int F
++ xdr_u_long F
++ xdr_u_short F
++ xdr_union F
++ xdr_vector F
++ xdr_void F
++ xdr_wrapstring F
++ xdrmem_create F
++ xdrrec_create F
++ xdrrec_endofrecord F
++ xdrrec_eof F
++ xdrrec_skiprecord F
++ xdrstdio_create F
++ xencrypt F
++ xprt_register F
++ xprt_unregister F
++GLIBC_2.1
++ GLIBC_2.1 A
++ _IO_2_1_stderr_ D 0x98
++ _IO_2_1_stdin_ D 0x98
++ _IO_2_1_stdout_ D 0x98
++ _IO_do_write F
++ _IO_fclose F
++ _IO_fdopen F
++ _IO_fgetpos64 F
++ _IO_file_attach F
++ _IO_file_close_it F
++ _IO_file_finish F
++ _IO_file_fopen F
++ _IO_file_init F
++ _IO_file_overflow F
++ _IO_file_seekoff F
++ _IO_file_setbuf F
++ _IO_file_sync F
++ _IO_file_underflow F
++ _IO_file_write F
++ _IO_file_xsputn F
++ _IO_fopen F
++ _IO_fsetpos64 F
++ _IO_getline_info F
++ _IO_popen F
++ _IO_proc_close F
++ _IO_proc_open F
++ __asprintf F
++ __backtrace F
++ __backtrace_symbols F
++ __backtrace_symbols_fd F
++ __duplocale F
++ __freelocale F
++ __fxstat64 F
++ __isalnum_l F
++ __isalpha_l F
++ __isascii_l F
++ __isblank_l F
++ __iscntrl_l F
++ __isdigit_l F
++ __isgraph_l F
++ __islower_l F
++ __isprint_l F
++ __ispunct_l F
++ __isspace_l F
++ __isupper_l F
++ __iswalnum_l F
++ __iswalpha_l F
++ __iswblank_l F
++ __iswcntrl_l F
++ __iswctype_l F
++ __iswdigit_l F
++ __iswgraph_l F
++ __iswlower_l F
++ __iswprint_l F
++ __iswpunct_l F
++ __iswspace_l F
++ __iswupper_l F
++ __iswxdigit_l F
++ __isxdigit_l F
++ __key_decryptsession_pk_LOCAL D 0x4
++ __key_encryptsession_pk_LOCAL D 0x4
++ __key_gendes_LOCAL D 0x4
++ __libc_allocate_rtsig F
++ __libc_current_sigrtmax F
++ __libc_current_sigrtmin F
++ __libc_freeres F
++ __libc_sa_len F
++ __lxstat64 F
++ __newlocale F
++ __poll F
++ __pread64 F
++ __pwrite64 F
++ __rawmemchr F
++ __signbit F
++ __signbitf F
++ __strcasecmp_l F
++ __strcasestr F
++ __strcoll_l F
++ __strfmon_l F
++ __strncasecmp_l F
++ __strtod_l F
++ __strtof_l F
++ __strtol_l F
++ __strtold_l F
++ __strtoll_l F
++ __strtoul_l F
++ __strtoull_l F
++ __strxfrm_l F
++ __toascii_l F
++ __tolower_l F
++ __toupper_l F
++ __towctrans F
++ __towctrans_l F
++ __towlower_l F
++ __towupper_l F
++ __wcscasecmp_l F
++ __wcscoll_l F
++ __wcsncasecmp_l F
++ __wcstod_l F
++ __wcstof_l F
++ __wcstol_l F
++ __wcstold_l F
++ __wcstoll_l F
++ __wcstoul_l F
++ __wcstoull_l F
++ __wcsxfrm_l F
++ __wctype_l F
++ __xstat64 F
++ _authenticate F
++ _dl_mcount_wrapper F
++ _dl_mcount_wrapper_check F
++ _sys_errlist D 0x1f4
++ _sys_nerr D 0x4
++ _sys_siglist D 0x100
++ addseverity F
++ alphasort64 F
++ argp_err_exit_status D 0x4
++ argp_error F
++ argp_failure F
++ argp_help F
++ argp_parse F
++ argp_program_bug_address D 0x4
++ argp_program_version D 0x4
++ argp_program_version_hook D 0x4
++ argp_state_help F
++ argp_usage F
++ authdes_create F
++ authdes_getucred F
++ authdes_pk_create F
++ backtrace F
++ backtrace_symbols F
++ backtrace_symbols_fd F
++ capget F
++ capset F
++ cbc_crypt F
++ clntunix_create F
++ creat64 F
++ des_setparity F
++ ecb_crypt F
++ endutxent F
++ fattach F
++ fclose F
++ fdetach F
++ fdopen F
++ ffsl F
++ ffsll F
++ fgetc_unlocked F
++ fgetpos64 F
++ fgets_unlocked F
++ fmtmsg F
++ fopen F
++ fopen64 F
++ fputs_unlocked F
++ fread_unlocked F
++ freopen64 F
++ fseeko F
++ fseeko64 F
++ fsetpos64 F
++ fstatfs64 F
++ fstatvfs F
++ fstatvfs64 F
++ ftello F
++ ftello64 F
++ ftruncate64 F
++ ftw64 F
++ fwrite_unlocked F
++ gai_strerror F
++ getcontext F
++ getdate F
++ getdate_err D 0x4
++ getdate_r F
++ getmsg F
++ getnameinfo F
++ getnetname F
++ getpmsg F
++ getpt F
++ getrlimit64 F
++ getutxent F
++ getutxid F
++ getutxline F
++ glob64 F
++ globfree64 F
++ gnu_get_libc_release F
++ gnu_get_libc_version F
++ grantpt F
++ host2netname F
++ iconv F
++ iconv_close F
++ iconv_open F
++ if_freenameindex F
++ if_indextoname F
++ if_nameindex F
++ if_nametoindex F
++ in6addr_any D 0x10
++ in6addr_loopback D 0x10
++ isastream F
++ iswblank F
++ key_decryptsession F
++ key_decryptsession_pk F
++ key_encryptsession F
++ key_encryptsession_pk F
++ key_gendes F
++ key_get_conv F
++ key_secretkey_is_set F
++ key_setnet F
++ key_setsecret F
++ lockf64 F
++ lseek64 F
++ makecontext F
++ mempcpy F
++ mmap64 F
++ netname2host F
++ netname2user F
++ nftw F
++ nftw64 F
++ ntp_adjtime F
++ ntp_gettime F
++ open64 F
++ passwd2des F
++ pclose F
++ popen F
++ pread F
++ pread64 F
++ printf_size F
++ printf_size_info F
++ pthread_attr_init F
++ ptsname F
++ ptsname_r F
++ putgrent F
++ putmsg F
++ putpmsg F
++ pututxline F
++ pwrite F
++ pwrite64 F
++ rawmemchr F
++ readdir64 F
++ readdir64_r F
++ rtime F
++ scandir64 F
++ sendfile F
++ setrlimit64 F
++ setutxent F
++ sighold F
++ sigignore F
++ sigqueue F
++ sigrelse F
++ sigset F
++ sigtimedwait F
++ sigwaitinfo F
++ statfs64 F
++ statvfs F
++ statvfs64 F
++ strcasestr F
++ strtoimax F
++ strtoumax F
++ strverscmp F
++ svcunix_create F
++ svcunixfd_create F
++ swapcontext F
++ sys_errlist D 0x1f4
++ sys_nerr D 0x4
++ sys_sigabbrev D 0x100
++ sys_siglist D 0x100
++ sysv_signal F
++ tcgetsid F
++ tdestroy F
++ tmpfile F
++ tmpfile64 F
++ truncate64 F
++ umount2 F
++ unlockpt F
++ updwtmpx F
++ user2netname F
++ utmpxname F
++ versionsort F
++ versionsort64 F
++ waitid F
++ wcscasecmp F
++ wcsncasecmp F
++ wcsnlen F
++ wcstoimax F
++ wcstoll F
++ wcstoull F
++ wcstoumax F
++ wcswcs F
++ wordexp F
++ wordfree F
++ xdecrypt F
++ xdr_authdes_cred F
++ xdr_authdes_verf F
++ xdr_getcredres F
++ xdr_int16_t F
++ xdr_int32_t F
++ xdr_int8_t F
++ xdr_netnamestr F
++ xdr_sizeof F
++ xdr_uint16_t F
++ xdr_uint32_t F
++ xdr_uint8_t F
++ xdr_unixcred F
++GLIBC_2.1.1
++ GLIBC_2.1.1 A
++ _Exit F
++ __mempcpy_small F
++ __stpcpy_small F
++ __strcpy_small F
++ __strcspn_c1 F
++ __strcspn_c2 F
++ __strcspn_c3 F
++ __strpbrk_c2 F
++ __strpbrk_c3 F
++ __strsep_1c F
++ __strsep_2c F
++ __strsep_3c F
++ __strsep_g F
++ __strspn_c1 F
++ __strspn_c2 F
++ __strspn_c3 F
++ __strtok_r_1c F
++ __strverscmp F
++ getutmp F
++ getutmpx F
++ imaxabs F
++ imaxdiv F
++ strchrnul F
++ xdr_hyper F
++ xdr_int64_t F
++ xdr_longlong_t F
++ xdr_u_hyper F
++ xdr_u_longlong_t F
++ xdr_uint64_t F
++GLIBC_2.1.2
++ GLIBC_2.1.2 A
++ __vfork F
++ getaliasbyname_r F
++ getaliasent_r F
++ getgrent_r F
++ getgrgid_r F
++ getgrnam_r F
++ gethostbyaddr_r F
++ gethostbyname2_r F
++ gethostbyname_r F
++ gethostent_r F
++ getnetbyaddr_r F
++ getnetbyname_r F
++ getnetent_r F
++ getprotobyname_r F
++ getprotobynumber_r F
++ getprotoent_r F
++ getpwent_r F
++ getpwnam_r F
++ getpwuid_r F
++ getrpcbyname_r F
++ getrpcbynumber_r F
++ getrpcent_r F
++ getservbyname_r F
++ getservbyport_r F
++ getservent_r F
++ getspent_r F
++ getspnam_r F
++GLIBC_2.1.3
++ GLIBC_2.1.3 A
++ __cxa_atexit F
++ __cxa_finalize F
++ __sigsuspend F
++GLIBC_2.10
++ GLIBC_2.10 A
++ __cxa_at_quick_exit F
++ __posix_getopt F
++ accept4 F
++ endsgent F
++ fallocate F
++ fgetsgent F
++ fgetsgent_r F
++ getsgent F
++ getsgent_r F
++ getsgnam F
++ getsgnam_r F
++ malloc_info F
++ preadv F
++ preadv64 F
++ psiginfo F
++ putsgent F
++ pwritev F
++ pwritev64 F
++ quick_exit F
++ register_printf_modifier F
++ register_printf_specifier F
++ register_printf_type F
++ setsgent F
++ sgetsgent F
++ sgetsgent_r F
++GLIBC_2.11
++ GLIBC_2.11 A
++ __longjmp_chk F
++ execvpe F
++ mkostemps F
++ mkostemps64 F
++ mkstemps F
++ mkstemps64 F
++GLIBC_2.12
++ GLIBC_2.12 A
++ _sys_errlist D 0x21c
++ _sys_nerr D 0x4
++ ntp_gettimex F
++ recvmmsg F
++ sys_errlist D 0x21c
++ sys_nerr D 0x4
++GLIBC_2.13
++ GLIBC_2.13 A
++ fanotify_init F
++ fanotify_mark F
++ prlimit F
++ prlimit64 F
++GLIBC_2.14
++ GLIBC_2.14 A
++ clock_adjtime F
++ name_to_handle_at F
++ open_by_handle_at F
++ sendmmsg F
++ setns F
++ syncfs F
++GLIBC_2.15
++ GLIBC_2.15 A
++ __fdelt_chk F
++ __fdelt_warn F
++ fallocate64 F
++ posix_spawn F
++ posix_spawnp F
++ process_vm_readv F
++ process_vm_writev F
++ scandirat F
++ scandirat64 F
++GLIBC_2.16
++ GLIBC_2.16 A
++ __getauxval F
++ __poll_chk F
++ __ppoll_chk F
++ aligned_alloc F
++ c16rtomb F
++ c32rtomb F
++ getauxval F
++ mbrtoc16 F
++ mbrtoc32 F
++ timespec_get F
++GLIBC_2.17
++ GLIBC_2.17 A
++ clock_getcpuclockid F
++ clock_getres F
++ clock_gettime F
++ clock_nanosleep F
++ clock_settime F
++ secure_getenv F
++GLIBC_2.2
++ GLIBC_2.2 A
++ _IO_adjust_wcolumn F
++ _IO_fgetpos F
++ _IO_fgetpos64 F
++ _IO_free_wbackup_area F
++ _IO_fsetpos F
++ _IO_fsetpos64 F
++ _IO_init_wmarker F
++ _IO_iter_begin F
++ _IO_iter_end F
++ _IO_iter_file F
++ _IO_iter_next F
++ _IO_least_wmarker F
++ _IO_list_lock F
++ _IO_list_resetlock F
++ _IO_list_unlock F
++ _IO_seekwmark F
++ _IO_sputbackwc F
++ _IO_sungetwc F
++ _IO_switch_to_main_wget_area F
++ _IO_switch_to_wbackup_area F
++ _IO_switch_to_wget_mode F
++ _IO_unsave_wmarkers F
++ _IO_wdefault_doallocate F
++ _IO_wdefault_finish F
++ _IO_wdefault_pbackfail F
++ _IO_wdefault_uflow F
++ _IO_wdefault_xsgetn F
++ _IO_wdefault_xsputn F
++ _IO_wdo_write F
++ _IO_wdoallocbuf F
++ _IO_wfile_jumps D 0x54
++ _IO_wfile_overflow F
++ _IO_wfile_seekoff F
++ _IO_wfile_sync F
++ _IO_wfile_underflow F
++ _IO_wfile_xsputn F
++ _IO_wmarker_delta F
++ _IO_wsetb F
++ __assert F
++ __ctype32_tolower D 0x4
++ __ctype32_toupper D 0x4
++ __cyg_profile_func_enter F
++ __cyg_profile_func_exit F
++ __endmntent F
++ __fbufsize F
++ __flbf F
++ __fpending F
++ __fpurge F
++ __freadable F
++ __freading F
++ __fsetlocking F
++ __fwritable F
++ __fwriting F
++ __fxstat64 F
++ __getmntent_r F
++ __nl_langinfo_l F
++ __open64 F
++ __res_init F
++ __res_nclose F
++ __res_ninit F
++ __res_state F
++ __setmntent F
++ __statfs F
++ __strndup F
++ __sysconf F
++ __wctrans_l F
++ __woverflow F
++ __wuflow F
++ __wunderflow F
++ __xpg_sigpause F
++ _flushlbf F
++ _res_hconf D 0x30
++ bind_textdomain_codeset F
++ dcngettext F
++ dngettext F
++ fgetpos F
++ fgetpos64 F
++ fgetwc F
++ fgetwc_unlocked F
++ fgetws F
++ fgetws_unlocked F
++ fmemopen F
++ fopencookie F
++ fputwc F
++ fputwc_unlocked F
++ fputws F
++ fputws_unlocked F
++ fsetpos F
++ fsetpos64 F
++ fwide F
++ fwprintf F
++ fwscanf F
++ getdirentries64 F
++ getloadavg F
++ getwc F
++ getwc_unlocked F
++ getwchar F
++ getwchar_unlocked F
++ iruserok_af F
++ localeconv F
++ mcheck_check_all F
++ mcheck_pedantic F
++ memrchr F
++ mincore F
++ mkdtemp F
++ mkstemp64 F
++ moncontrol F
++ ngettext F
++ posix_fadvise F
++ posix_fadvise64 F
++ posix_fallocate F
++ posix_fallocate64 F
++ posix_madvise F
++ posix_memalign F
++ posix_spawn F
++ posix_spawn_file_actions_addclose F
++ posix_spawn_file_actions_adddup2 F
++ posix_spawn_file_actions_addopen F
++ posix_spawn_file_actions_destroy F
++ posix_spawn_file_actions_init F
++ posix_spawnattr_destroy F
++ posix_spawnattr_getflags F
++ posix_spawnattr_getpgroup F
++ posix_spawnattr_getschedparam F
++ posix_spawnattr_getschedpolicy F
++ posix_spawnattr_getsigdefault F
++ posix_spawnattr_getsigmask F
++ posix_spawnattr_init F
++ posix_spawnattr_setflags F
++ posix_spawnattr_setpgroup F
++ posix_spawnattr_setschedparam F
++ posix_spawnattr_setschedpolicy F
++ posix_spawnattr_setsigdefault F
++ posix_spawnattr_setsigmask F
++ posix_spawnp F
++ putwc F
++ putwc_unlocked F
++ putwchar F
++ putwchar_unlocked F
++ rcmd_af F
++ rexec_af F
++ rresvport_af F
++ ruserok_af F
++ semctl F
++ svc_getreq_common F
++ svc_getreq_poll F
++ svc_max_pollfd D 0x4
++ svc_pollfd D 0x4
++ swprintf F
++ swscanf F
++ ungetwc F
++ vfwprintf F
++ vfwscanf F
++ vswprintf F
++ vswscanf F
++ vwprintf F
++ vwscanf F
++ wcschrnul F
++ wcsftime F
++ wmempcpy F
++ wprintf F
++ wscanf F
++GLIBC_2.2.1
++ GLIBC_2.2.1 A
++ pivot_root F
++ posix_openpt F
++GLIBC_2.2.2
++ GLIBC_2.2.2 A
++ __nss_hostname_digits_dots F
++GLIBC_2.2.3
++ GLIBC_2.2.3 A
++ __rpc_thread_createerr F
++ __rpc_thread_svc_fdset F
++ __rpc_thread_svc_max_pollfd F
++ __rpc_thread_svc_pollfd F
++ fnmatch F
++ sprofil F
++GLIBC_2.2.4
++ GLIBC_2.2.4 A
++ dl_iterate_phdr F
++ getgrouplist F
++ sockatmark F
++GLIBC_2.2.6
++ GLIBC_2.2.6 A
++ __nanosleep F
++GLIBC_2.3
++ GLIBC_2.3 A
++ __ctype_b_loc F
++ __ctype_tolower_loc F
++ __ctype_toupper_loc F
++ __isctype F
++ __strftime_l F
++ __uselocale F
++ __wcsftime_l F
++ _sys_errlist D 0x1f8
++ _sys_nerr D 0x4
++ duplocale F
++ fgetxattr F
++ flistxattr F
++ freeifaddrs F
++ freelocale F
++ fremovexattr F
++ fsetxattr F
++ futimes F
++ getifaddrs F
++ getxattr F
++ isalnum_l F
++ isalpha_l F
++ isblank_l F
++ iscntrl_l F
++ isctype F
++ isdigit_l F
++ isgraph_l F
++ islower_l F
++ isprint_l F
++ ispunct_l F
++ isspace_l F
++ isupper_l F
++ iswalnum_l F
++ iswalpha_l F
++ iswblank_l F
++ iswcntrl_l F
++ iswctype_l F
++ iswdigit_l F
++ iswgraph_l F
++ iswlower_l F
++ iswprint_l F
++ iswpunct_l F
++ iswspace_l F
++ iswupper_l F
++ iswxdigit_l F
++ isxdigit_l F
++ lgetxattr F
++ listxattr F
++ llistxattr F
++ lremovexattr F
++ lsetxattr F
++ lutimes F
++ newlocale F
++ nl_langinfo_l F
++ readahead F
++ realpath F
++ removexattr F
++ sendfile64 F
++ setxattr F
++ strcasecmp_l F
++ strcoll_l F
++ strfmon_l F
++ strftime_l F
++ strncasecmp_l F
++ strtod_l F
++ strtof_l F
++ strtol_l F
++ strtold_l F
++ strtoll_l F
++ strtoul_l F
++ strtoull_l F
++ strxfrm_l F
++ sys_errlist D 0x1f8
++ sys_nerr D 0x4
++ tolower_l F
++ toupper_l F
++ towctrans_l F
++ towlower_l F
++ towupper_l F
++ uselocale F
++ wcscasecmp_l F
++ wcscoll_l F
++ wcsftime_l F
++ wcsncasecmp_l F
++ wcstod_l F
++ wcstof_l F
++ wcstol_l F
++ wcstold_l F
++ wcstoll_l F
++ wcstoul_l F
++ wcstoull_l F
++ wcsxfrm_l F
++ wctrans_l F
++ wctype_l F
++GLIBC_2.3.2
++ GLIBC_2.3.2 A
++ __register_atfork F
++ epoll_create F
++ epoll_ctl F
++ epoll_wait F
++ lchmod F
++ pthread_cond_broadcast F
++ pthread_cond_destroy F
++ pthread_cond_init F
++ pthread_cond_signal F
++ pthread_cond_timedwait F
++ pthread_cond_wait F
++ strptime_l F
++GLIBC_2.3.3
++ GLIBC_2.3.3 A
++ _sys_siglist D 0x104
++ gnu_dev_major F
++ gnu_dev_makedev F
++ gnu_dev_minor F
++ inet6_option_alloc F
++ inet6_option_append F
++ inet6_option_find F
++ inet6_option_init F
++ inet6_option_next F
++ inet6_option_space F
++ nftw F
++ nftw64 F
++ posix_fadvise64 F
++ posix_fallocate64 F
++ remap_file_pages F
++ sched_getaffinity F
++ sched_setaffinity F
++ semtimedop F
++ sys_sigabbrev D 0x104
++ sys_siglist D 0x104
++GLIBC_2.3.4
++ GLIBC_2.3.4 A
++ __chk_fail F
++ __fprintf_chk F
++ __gets_chk F
++ __memcpy_chk F
++ __memmove_chk F
++ __mempcpy_chk F
++ __memset_chk F
++ __printf_chk F
++ __snprintf_chk F
++ __sprintf_chk F
++ __stpcpy_chk F
++ __strcat_chk F
++ __strcpy_chk F
++ __strncat_chk F
++ __strncpy_chk F
++ __vfprintf_chk F
++ __vprintf_chk F
++ __vsnprintf_chk F
++ __vsprintf_chk F
++ __xpg_strerror_r F
++ getipv4sourcefilter F
++ getsourcefilter F
++ regexec F
++ sched_getaffinity F
++ sched_setaffinity F
++ setipv4sourcefilter F
++ setsourcefilter F
++ xdr_quad_t F
++ xdr_u_quad_t F
++GLIBC_2.4
++ GLIBC_2.4 A
++ __confstr_chk F
++ __fgets_chk F
++ __fgets_unlocked_chk F
++ __fgetws_chk F
++ __fgetws_unlocked_chk F
++ __fwprintf_chk F
++ __fxstatat F
++ __fxstatat64 F
++ __getcwd_chk F
++ __getdomainname_chk F
++ __getgroups_chk F
++ __gethostname_chk F
++ __getlogin_r_chk F
++ __getwd_chk F
++ __mbsnrtowcs_chk F
++ __mbsrtowcs_chk F
++ __mbstowcs_chk F
++ __pread64_chk F
++ __pread_chk F
++ __ptsname_r_chk F
++ __read_chk F
++ __readlink_chk F
++ __realpath_chk F
++ __recv_chk F
++ __recvfrom_chk F
++ __stack_chk_fail F
++ __stpncpy_chk F
++ __swprintf_chk F
++ __syslog_chk F
++ __ttyname_r_chk F
++ __vfwprintf_chk F
++ __vswprintf_chk F
++ __vsyslog_chk F
++ __vwprintf_chk F
++ __wcpcpy_chk F
++ __wcpncpy_chk F
++ __wcrtomb_chk F
++ __wcscat_chk F
++ __wcscpy_chk F
++ __wcsncat_chk F
++ __wcsncpy_chk F
++ __wcsnrtombs_chk F
++ __wcsrtombs_chk F
++ __wcstombs_chk F
++ __wctomb_chk F
++ __wmemcpy_chk F
++ __wmemmove_chk F
++ __wmempcpy_chk F
++ __wmemset_chk F
++ __wprintf_chk F
++ __xmknodat F
++ _sys_errlist D 0x210
++ _sys_nerr D 0x4
++ eaccess F
++ faccessat F
++ fchmodat F
++ fchownat F
++ fdopendir F
++ futimesat F
++ inotify_add_watch F
++ inotify_init F
++ inotify_rm_watch F
++ linkat F
++ mkdirat F
++ mkfifoat F
++ open_wmemstream F
++ openat F
++ openat64 F
++ ppoll F
++ readlinkat F
++ renameat F
++ symlinkat F
++ sys_errlist D 0x210
++ sys_nerr D 0x4
++ unlinkat F
++ unshare F
++GLIBC_2.5
++ GLIBC_2.5 A
++ __readlinkat_chk F
++ inet6_opt_append F
++ inet6_opt_find F
++ inet6_opt_finish F
++ inet6_opt_get_val F
++ inet6_opt_init F
++ inet6_opt_next F
++ inet6_opt_set_val F
++ inet6_rth_add F
++ inet6_rth_getaddr F
++ inet6_rth_init F
++ inet6_rth_reverse F
++ inet6_rth_segments F
++ inet6_rth_space F
++ splice F
++ tee F
++ vmsplice F
++GLIBC_2.6
++ GLIBC_2.6 A
++ __sched_cpucount F
++ epoll_pwait F
++ futimens F
++ sched_getcpu F
++ strerror_l F
++ sync_file_range F
++ utimensat F
++GLIBC_2.7
++ GLIBC_2.7 A
++ __fread_chk F
++ __fread_unlocked_chk F
++ __isoc99_fscanf F
++ __isoc99_fwscanf F
++ __isoc99_scanf F
++ __isoc99_sscanf F
++ __isoc99_swscanf F
++ __isoc99_vfscanf F
++ __isoc99_vfwscanf F
++ __isoc99_vscanf F
++ __isoc99_vsscanf F
++ __isoc99_vswscanf F
++ __isoc99_vwscanf F
++ __isoc99_wscanf F
++ __open64_2 F
++ __open_2 F
++ __openat64_2 F
++ __openat_2 F
++ __sched_cpualloc F
++ __sched_cpufree F
++ eventfd F
++ eventfd_read F
++ eventfd_write F
++ mkostemp F
++ mkostemp64 F
++ signalfd F
++GLIBC_2.8
++ GLIBC_2.8 A
++ __asprintf_chk F
++ __dprintf_chk F
++ __obstack_printf_chk F
++ __obstack_vprintf_chk F
++ __vasprintf_chk F
++ __vdprintf_chk F
++ qsort_r F
++ timerfd_create F
++ timerfd_gettime F
++ timerfd_settime F
++GLIBC_2.9
++ GLIBC_2.9 A
++ dup3 F
++ epoll_create1 F
++ inotify_init1 F
++ pipe2 F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libcrypt.abilist
+@@ -0,0 +1,9 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ crypt F
++ crypt_r F
++ encrypt F
++ encrypt_r F
++ fcrypt F
++ setkey F
++ setkey_r F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/localplt.data
+@@ -0,0 +1,7 @@
++libc.so: _Unwind_Find_FDE
++libc.so: calloc
++libc.so: free
++libc.so: malloc
++libc.so: memalign
++libc.so: realloc
++libm.so: matherr
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/lowlevellock.h
+@@ -0,0 +1,280 @@
++/* Copyright (C) 2011 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _LOWLEVELLOCK_H
++#define _LOWLEVELLOCK_H	1
++
++#include <time.h>
++#include <sys/param.h>
++#include <bits/pthreadtypes.h>
++#include <atomic.h>
++#include <sysdep.h>
++#include <kernel-features.h>
++
++
++#define FUTEX_WAIT		0
++#define FUTEX_WAKE		1
++#define FUTEX_REQUEUE		3
++#define FUTEX_CMP_REQUEUE	4
++#define FUTEX_WAKE_OP		5
++#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
++#define FUTEX_LOCK_PI		6
++#define FUTEX_UNLOCK_PI		7
++#define FUTEX_TRYLOCK_PI	8
++#define FUTEX_WAIT_BITSET	9
++#define FUTEX_WAKE_BITSET	10
++#define FUTEX_PRIVATE_FLAG	128
++#define FUTEX_CLOCK_REALTIME	256
++
++#define FUTEX_BITSET_MATCH_ANY	0xffffffff
++
++/* Values for 'private' parameter of locking macros.  Yes, the
++   definition seems to be backwards.  But it is not.  The bit will be
++   reversed before passing to the system call.  */
++#define LLL_PRIVATE	0
++#define LLL_SHARED	FUTEX_PRIVATE_FLAG
++
++
++#if !defined NOT_IN_libc || defined IS_IN_rtld
++/* In libc.so or ld.so all futexes are private.  */
++# ifdef __ASSUME_PRIVATE_FUTEX
++#  define __lll_private_flag(fl, private) \
++  ((fl) | FUTEX_PRIVATE_FLAG)
++# else
++#  define __lll_private_flag(fl, private) \
++  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
++# endif
++#else
++# ifdef __ASSUME_PRIVATE_FUTEX
++#  define __lll_private_flag(fl, private) \
++  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
++# else
++#  define __lll_private_flag(fl, private) \
++  (__builtin_constant_p (private)					      \
++   ? ((private) == 0							      \
++      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
++      : (fl))								      \
++   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
++	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
++# endif
++#endif
++
++
++#define lll_futex_wait(futexp, val, private) \
++  lll_futex_timed_wait (futexp, val, NULL, private)
++
++#define lll_futex_timed_wait(futexp, val, timespec, private) \
++  ({									      \
++    INTERNAL_SYSCALL_DECL (__err);					      \
++    INTERNAL_SYSCALL (futex, __err, 4, (futexp),			      \
++			      __lll_private_flag (FUTEX_WAIT, private),	      \
++			      (val), (timespec));			      \
++  })
++
++#define lll_futex_wake(futexp, nr, private) \
++  ({									      \
++    INTERNAL_SYSCALL_DECL (__err);					      \
++    INTERNAL_SYSCALL (futex, __err, 4, (futexp),			      \
++			      __lll_private_flag (FUTEX_WAKE, private),	      \
++			      (nr), 0);					      \
++  })
++
++#define lll_robust_dead(futexv, private) \
++  do									      \
++    {									      \
++      int *__futexp = &(futexv);					      \
++      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
++      lll_futex_wake (__futexp, 1, private);				      \
++    }									      \
++  while (0)
++
++/* Returns non-zero if error happened, zero if success.  */
++#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
++  ({									      \
++    INTERNAL_SYSCALL_DECL (__err);					      \
++    long int __ret;							      \
++    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
++			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
++			      (nr_wake), (nr_move), (mutex), (val));	      \
++    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
++  })
++
++/* Returns non-zero if error happened, zero if success.  */
++#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
++  ({									      \
++    INTERNAL_SYSCALL_DECL (__err);					      \
++    long int __ret;							      \
++    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
++			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
++			      (nr_wake), (nr_wake2), (futexp2),		      \
++			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
++    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
++  })
++
++
++
++
++static inline int __attribute__ ((always_inline))
++__lll_trylock (int *futex)
++{
++  return atomic_compare_and_exchange_val_acq (futex, 1, 0) != 0;
++}
++#define lll_trylock(lock)	__lll_trylock (&(lock))
++
++
++static inline int __attribute__ ((always_inline))
++__lll_cond_trylock (int *futex)
++{
++  return atomic_compare_and_exchange_val_acq (futex, 2, 0) != 0;
++}
++#define lll_cond_trylock(lock)	__lll_cond_trylock (&(lock))
++
++
++static inline int __attribute__ ((always_inline))
++__lll_robust_trylock (int *futex, int id)
++{
++  return atomic_compare_and_exchange_val_acq (futex, id, 0) != 0;
++}
++#define lll_robust_trylock(lock, id) \
++  __lll_robust_trylock (&(lock), id)
++
++extern void __lll_lock_wait_private (int *futex) attribute_hidden;
++extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
++extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
++
++static inline void __attribute__ ((always_inline))
++__lll_lock (int *futex, int private)
++{
++  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
++    {
++      if (__builtin_constant_p (private) && private == LLL_PRIVATE)
++	__lll_lock_wait_private (futex);
++      else
++	__lll_lock_wait (futex, private);
++    }
++}
++#define lll_lock(futex, private) __lll_lock (&(futex), private)
++
++
++static inline int __attribute__ ((always_inline))
++__lll_robust_lock (int *futex, int id, int private)
++{
++  int result = 0;
++  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
++    result = __lll_robust_lock_wait (futex, private);
++  return result;
++}
++#define lll_robust_lock(futex, id, private) \
++  __lll_robust_lock (&(futex), id, private)
++
++
++static inline void __attribute__ ((always_inline))
++__lll_cond_lock (int *futex, int private)
++{
++  if (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0)
++    __lll_lock_wait (futex, private);
++}
++#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
++
++
++#define lll_robust_cond_lock(futex, id, private) \
++  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
++
++
++extern int __lll_timedlock_wait (int *futex, const struct timespec *,
++				 int private) attribute_hidden;
++extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
++					int private) attribute_hidden;
++
++static inline int __attribute__ ((always_inline))
++__lll_timedlock (int *futex, const struct timespec *abstime, int private)
++{
++  int result = 0;
++  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
++    result = __lll_timedlock_wait (futex, abstime, private);
++  return result;
++}
++#define lll_timedlock(futex, abstime, private) \
++  __lll_timedlock (&(futex), abstime, private)
++
++
++static inline int __attribute__ ((always_inline))
++__lll_robust_timedlock (int *futex, const struct timespec *abstime,
++			int id, int private)
++{
++  int result = 0;
++  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
++    result = __lll_robust_timedlock_wait (futex, abstime, private);
++  return result;
++}
++#define lll_robust_timedlock(futex, abstime, id, private) \
++  __lll_robust_timedlock (&(futex), abstime, id, private)
++
++
++#define __lll_unlock(futex, private) \
++  (void)							\
++    ({ int *__futex = (futex);					\
++       int __oldval = atomic_exchange_rel (__futex, 0);		\
++       if (__builtin_expect (__oldval > 1, 0))			\
++	 lll_futex_wake (__futex, 1, private);			\
++    })
++#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
++
++
++#define __lll_robust_unlock(futex, private) \
++  (void)							\
++    ({ int *__futex = (futex);					\
++       int __oldval = atomic_exchange_rel (__futex, 0);		\
++       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
++	 lll_futex_wake (__futex, 1, private);			\
++    })
++#define lll_robust_unlock(futex, private) \
++  __lll_robust_unlock(&(futex), private)
++
++
++#define lll_islocked(futex) \
++  (futex != 0)
++
++/* Initializers for lock.  */
++#define LLL_LOCK_INITIALIZER		(0)
++#define LLL_LOCK_INITIALIZER_LOCKED	(1)
++
++
++/* The kernel notifies a process which uses CLONE_CHILD_CLEARTID via futex
++   wakeup when the clone terminates.  The memory location contains the
++   thread ID while the clone is running and is reset to zero
++   afterwards.	*/
++#define lll_wait_tid(tid) \
++  do {							\
++    __typeof (tid) __tid;				\
++    while ((__tid = (tid)) != 0)			\
++      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
++  } while (0)
++
++extern int __lll_timedwait_tid (int *, const struct timespec *)
++  attribute_hidden;
++
++#define lll_timedwait_tid(tid, abstime) \
++  ({							\
++    int __res = 0;					\
++    if ((tid) != 0)					\
++      __res = __lll_timedwait_tid (&(tid), (abstime));	\
++    __res;						\
++  })
++
++#endif /* lowlevellock.h */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libdl.abilist
+@@ -0,0 +1,18 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ dladdr F
++ dlclose F
++ dlerror F
++ dlopen F
++ dlsym F
++GLIBC_2.1
++ GLIBC_2.1 A
++ dlopen F
++ dlvsym F
++GLIBC_2.3.3
++ GLIBC_2.3.3 A
++ dladdr1 F
++ dlinfo F
++GLIBC_2.3.4
++ GLIBC_2.3.4 A
++ dlmopen F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libnsl.abilist
+@@ -0,0 +1,127 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ __yp_check F
++ xdr_domainname F
++ xdr_keydat F
++ xdr_mapname F
++ xdr_peername F
++ xdr_valdat F
++ xdr_yp_buf F
++ xdr_ypbind_binding F
++ xdr_ypbind_resp F
++ xdr_ypbind_resptype F
++ xdr_ypbind_setdom F
++ xdr_ypdelete_args F
++ xdr_ypmap_parms F
++ xdr_ypmaplist F
++ xdr_yppush_status F
++ xdr_yppushresp_xfr F
++ xdr_ypreq_key F
++ xdr_ypreq_nokey F
++ xdr_ypreq_xfr F
++ xdr_ypresp_all F
++ xdr_ypresp_key_val F
++ xdr_ypresp_maplist F
++ xdr_ypresp_master F
++ xdr_ypresp_order F
++ xdr_ypresp_val F
++ xdr_ypresp_xfr F
++ xdr_ypstat F
++ xdr_ypupdate_args F
++ xdr_ypxfrstat F
++ yp_all F
++ yp_bind F
++ yp_first F
++ yp_get_default_domain F
++ yp_maplist F
++ yp_master F
++ yp_match F
++ yp_next F
++ yp_order F
++ yp_unbind F
++ yp_update F
++ ypbinderr_string F
++ yperr_string F
++ ypprot_err F
++GLIBC_2.1
++ GLIBC_2.1 A
++ __free_fdresult F
++ __nis_default_access F
++ __nis_default_group F
++ __nis_default_owner F
++ __nis_default_ttl F
++ __nis_finddirectory F
++ __nis_hash F
++ __nisbind_connect F
++ __nisbind_create F
++ __nisbind_destroy F
++ __nisbind_next F
++ nis_add F
++ nis_add_entry F
++ nis_addmember F
++ nis_checkpoint F
++ nis_clone_directory F
++ nis_clone_object F
++ nis_clone_result F
++ nis_creategroup F
++ nis_destroy_object F
++ nis_destroygroup F
++ nis_dir_cmp F
++ nis_domain_of F
++ nis_domain_of_r F
++ nis_first_entry F
++ nis_free_directory F
++ nis_free_object F
++ nis_free_request F
++ nis_freenames F
++ nis_freeresult F
++ nis_freeservlist F
++ nis_freetags F
++ nis_getnames F
++ nis_getservlist F
++ nis_ismember F
++ nis_leaf_of F
++ nis_leaf_of_r F
++ nis_lerror F
++ nis_list F
++ nis_local_directory F
++ nis_local_group F
++ nis_local_host F
++ nis_local_principal F
++ nis_lookup F
++ nis_mkdir F
++ nis_modify F
++ nis_modify_entry F
++ nis_name_of F
++ nis_name_of_r F
++ nis_next_entry F
++ nis_perror F
++ nis_ping F
++ nis_print_directory F
++ nis_print_entry F
++ nis_print_group F
++ nis_print_group_entry F
++ nis_print_link F
++ nis_print_object F
++ nis_print_result F
++ nis_print_rights F
++ nis_print_table F
++ nis_read_obj F
++ nis_remove F
++ nis_remove_entry F
++ nis_removemember F
++ nis_rmdir F
++ nis_servstate F
++ nis_sperrno F
++ nis_sperror F
++ nis_sperror_r F
++ nis_stats F
++ nis_verifygroup F
++ nis_write_obj F
++ readColdStartFile F
++ writeColdStartFile F
++ xdr_cback_data F
++ xdr_obj_p F
++GLIBC_2.2
++ GLIBC_2.2 A
++ xdr_ypall F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/fork.c
+@@ -0,0 +1,30 @@
++/* Copyright (C) 2005 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Phil Blundell <pb@nexus.co.uk>, 2005
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <sched.h>
++#include <signal.h>
++#include <sysdep.h>
++#include <tls.h>
++
++
++#define ARCH_FORK()							\
++  INLINE_SYSCALL (clone, 5,						\
++		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
++		  NULL, NULL, &THREAD_SELF->tid, NULL)
++
++#include <nptl/sysdeps/unix/sysv/linux/fork.c>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libanl.abilist
+@@ -0,0 +1,6 @@
++GLIBC_2.2.3
++ GLIBC_2.2.3 A
++ gai_cancel F
++ gai_error F
++ gai_suspend F
++ getaddrinfo_a F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/librt.abilist
+@@ -0,0 +1,52 @@
++GLIBC_2.1
++ GLIBC_2.1 A
++ aio_cancel F
++ aio_cancel64 F
++ aio_error F
++ aio_error64 F
++ aio_fsync F
++ aio_fsync64 F
++ aio_init F
++ aio_read F
++ aio_read64 F
++ aio_return F
++ aio_return64 F
++ aio_suspend F
++ aio_suspend64 F
++ aio_write F
++ aio_write64 F
++ lio_listio F
++ lio_listio64 F
++GLIBC_2.2
++ GLIBC_2.2 A
++ clock_getcpuclockid F
++ clock_getres F
++ clock_gettime F
++ clock_nanosleep F
++ clock_settime F
++ shm_open F
++ shm_unlink F
++ timer_create F
++ timer_delete F
++ timer_getoverrun F
++ timer_gettime F
++ timer_settime F
++GLIBC_2.3.4
++ GLIBC_2.3.4 A
++ mq_close F
++ mq_getattr F
++ mq_notify F
++ mq_open F
++ mq_receive F
++ mq_send F
++ mq_setattr F
++ mq_timedreceive F
++ mq_timedsend F
++ mq_unlink F
++GLIBC_2.4
++ GLIBC_2.4 A
++ lio_listio F
++ lio_listio64 F
++GLIBC_2.7
++ GLIBC_2.7 A
++ __mq_open_2 F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libutil.abilist
+@@ -0,0 +1,8 @@
++GLIBC_2.0
++ GLIBC_2.0 A
++ forkpty F
++ login F
++ login_tty F
++ logout F
++ logwtmp F
++ openpty F
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/bits/atomic.h
+@@ -0,0 +1,128 @@
++/* Copyright (C) 2010-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++   Contributed by Maxim Kuvyrkov <maxim@codesourcery.com>, 2010.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _BITS_ATOMIC_H
++#define _BITS_ATOMIC_H	1
++
++#include <stdint.h>
++
++/* This is needed to break a depencency loop, we do not need errno anyway */
++#ifndef _ERRNO_H
++# define _ERRNO_H
++# include <sysdep.h>
++# undef _ERRNO_H
++#else
++# include <sysdep.h>
++#endif
++
++/* Or1k has no atomic compare-and-exchange operation, but the
++   kernel provides userspace atomicity operations.  Use them.  */
++
++typedef int32_t atomic32_t;
++typedef uint32_t uatomic32_t;
++typedef int_fast32_t atomic_fast32_t;
++typedef uint_fast32_t uatomic_fast32_t;
++
++typedef intptr_t atomicptr_t;
++typedef uintptr_t uatomicptr_t;
++typedef intmax_t atomic_max_t;
++typedef uintmax_t uatomic_max_t;
++
++/* TODO: Move these to a kernel header */
++#define OR1K_ATOMIC_SWAP	1
++#define OR1K_ATOMIC_CMPXCHG	2
++#define OR1K_ATOMIC_XCHG	3
++#define OR1K_ATOMIC_ADD		4
++#define OR1K_ATOMIC_DECPOS	5
++#define OR1K_ATOMIC_AND		6
++#define OR1K_ATOMIC_OR		7
++#define OR1K_ATOMIC_UMAX	8
++#define OR1K_ATOMIC_UMIN	9
++
++#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 4, \
++	    OR1K_ATOMIC_CMPXCHG, mem, oldval, newval) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_exchange_acq(mem, newval) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_XCHG, mem, newval) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_exchange_and_add_acq(mem, val) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_ADD, mem, val) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_decrement_if_positive(mem) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 2, \
++	    OR1K_ATOMIC_DECPOS, mem) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_and_val(mem, mask) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_AND, mem, mask) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_or_val(mem, mask) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_OR, mem, mask) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_max_val(mem, val) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_UMAX, mem, val) \
++	 : __atomic_error_bad_argument_size ()))
++
++#define atomic_min_val(mem, val) \
++  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
++	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
++	    OR1K_ATOMIC_UMIN, mem, val) \
++	 : __atomic_error_bad_argument_size ()))
++
++
++/* atomic_bit_test_set in terms of atomic_or_val. */
++#define atomic_bit_test_set(mem, bit)                                    \
++    ({ __typeof (*(mem)) __att0_mask = ((__typeof (*(mem))) 1 << (bit)); \
++         atomic_or_val ((mem), __att0_mask) & __att0_mask; })
++
++/* Various macros that should just be synonyms. */
++#define catomic_exchange_and_add atomic_exchange_and_add
++#define atomic_and(mem, mask) ((void) atomic_and_val ((mem), (mask)))
++#define catomic_and atomic_and
++#define atomic_or(mem, mask) ((void) atomic_or_val ((mem), (mask)))
++#define catomic_or atomic_or
++#define atomic_max(mem, val) ((void)atomic_max_val ((mem), (val)))
++#define catomic_max atomic_max
++#define atomic_min(mem, val) ((void)atomic_min_val ((mem), (val)))
++#define catomic_min atomic_min
++/*
++ * This non-existent symbol is called for unsupporrted sizes,
++ * indicating a bug in the caller.
++ */
++extern int __atomic_error_bad_argument_size(void)
++    __attribute__ ((error ("bad sizeof atomic argument")));
++
++#endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/bits/semaphore.h
+@@ -0,0 +1,34 @@
++/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _SEMAPHORE_H
++# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
++#endif
++
++
++#define __SIZEOF_SEM_T	16
++
++
++/* Value returned if `sem_open' failed.  */
++#define SEM_FAILED      ((sem_t *) 0)
++
++
++typedef union
++{
++  char __size[__SIZEOF_SEM_T];
++  long int __align;
++} sem_t;
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/setjmp.S
+@@ -0,0 +1,80 @@
++/* setjmp for or1k
++
++   Based on:
++   setjmp for PowerPC.
++   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <sysdep.h>
++#define _ASM
++#define _SETJMP_H
++#include <bits/setjmp.h>
++
++ENTRY (_setjmp)
++	l.addi	r4,r0,0			/* Set second argument to 0.  */
++	l.j	.Local__sigsetjmp
++	l.nop
++END (_setjmp)
++libc_hidden_def (_setjmp)
++
++ENTRY (setjmp)
++	l.addi	r4,r0,1			/* Set second argument to 1.  */
++	l.j	.Local__sigsetjmp
++	l.nop
++END (setjmp)
++
++ENTRY (__sigsetjmp)
++.Local__sigsetjmp:
++#	l.mfspr	r11,r0,SPR_SR
++#	l.sw    (JB_SR*4)(r3),r11
++	l.sw    ((JB_GPRS+0)*4)(r3),r1
++	l.sw    ((JB_GPRS+1)*4)(r3),r2
++/*	l.sw    ((JB_GPRS+2)*4)(r3),r3*/
++	l.sw    ((JB_GPRS+3)*4)(r3),r4
++	l.sw    ((JB_GPRS+4)*4)(r3),r5
++	l.sw    ((JB_GPRS+5)*4)(r3),r6
++	l.sw    ((JB_GPRS+6)*4)(r3),r7
++	l.sw    ((JB_GPRS+7)*4)(r3),r8
++	l.sw    ((JB_GPRS+8)*4)(r3),r9
++	l.sw    ((JB_GPRS+9)*4)(r3),r10
++	l.sw    ((JB_GPRS+10)*4)(r3),r11
++	l.sw    ((JB_GPRS+11)*4)(r3),r12
++	l.sw    ((JB_GPRS+12)*4)(r3),r13
++	l.sw    ((JB_GPRS+13)*4)(r3),r14
++	l.sw    ((JB_GPRS+14)*4)(r3),r15
++	l.sw    ((JB_GPRS+15)*4)(r3),r16
++	l.sw    ((JB_GPRS+16)*4)(r3),r17
++	l.sw    ((JB_GPRS+17)*4)(r3),r18
++	l.sw    ((JB_GPRS+18)*4)(r3),r19
++	l.sw    ((JB_GPRS+19)*4)(r3),r20
++	l.sw    ((JB_GPRS+20)*4)(r3),r21
++	l.sw    ((JB_GPRS+21)*4)(r3),r22
++	l.sw    ((JB_GPRS+22)*4)(r3),r23
++	l.sw    ((JB_GPRS+23)*4)(r3),r24
++	l.sw    ((JB_GPRS+24)*4)(r3),r25
++	l.sw    ((JB_GPRS+25)*4)(r3),r26
++	l.sw    ((JB_GPRS+26)*4)(r3),r27
++	l.sw    ((JB_GPRS+27)*4)(r3),r28
++	l.sw    ((JB_GPRS+28)*4)(r3),r29
++	l.sw    ((JB_GPRS+29)*4)(r3),r30
++	l.sw    ((JB_GPRS+30)*4)(r3),r31
++	l.j	__sigjmp_save
++	l.nop
++END (__sigsetjmp)
++hidden_def (__sigsetjmp)
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/sysdep.h
+@@ -0,0 +1,88 @@
++/* Assembler macros for OR1k.
++   Copyright (C) 1997, 1998, 2003, 2009, 2010, 2012
++   Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <sysdeps/generic/sysdep.h>
++#include <features.h>
++
++/* TODO: clean up this file */
++#ifdef	__ASSEMBLER__
++
++/* Syntactic details of assembler.  */
++
++#define ALIGNARG(log2) log2
++#define ASM_SIZE_DIRECTIVE(name) .size name,.-name
++
++#define PLTJMP(_x)	_x##(PLT)
++
++#define RETINSTR(cond, reg)	\
++	mov##cond	pc, reg
++#define DO_RET(_reg)		\
++	.jr _reg
++
++/* Define an entry point visible from C.  */
++#define	ENTRY(name)							      \
++  .globl C_SYMBOL_NAME(name);						      \
++  .type C_SYMBOL_NAME(name),%function;					      \
++  .align ALIGNARG(4);							      \
++  C_LABEL(name)								      \
++  .cfi_sections .debug_frame;						      \
++  cfi_startproc;							      \
++  CALL_MCOUNT
++
++#undef	END
++#define END(name)							      \
++  cfi_endproc;								      \
++  ASM_SIZE_DIRECTIVE(name)
++
++/* If compiled for profiling, call `mcount' at the start of each function.  */
++#ifdef	PROF
++/* Call __gnu_mcount_nc if GCC >= 4.4.  */
++#if __GNUC_PREREQ(4,4)
++#define CALL_MCOUNT \
++  str	lr,[sp, #-4]!; \
++  cfi_adjust_cfa_offset (4); \
++  cfi_rel_offset (lr, 0); \
++  bl PLTJMP(mcount); \
++  cfi_adjust_cfa_offset (-4); \
++  cfi_restore (lr)
++#else /* else call _mcount */
++#define CALL_MCOUNT \
++  str	lr,[sp, #-4]!; \
++  cfi_adjust_cfa_offset (4); \
++  cfi_rel_offset (lr, 0); \
++  bl PLTJMP(mcount); \
++  ldr lr, [sp], #4; \
++  cfi_adjust_cfa_offset (-4); \
++  cfi_restore (lr)
++#endif
++#else
++#define CALL_MCOUNT		/* Do nothing.  */
++#endif
++
++/* Since C identifiers are not normally prefixed with an underscore
++   on this system, the asm identifier `syscall_error' intrudes on the
++   C name space.  Make sure we use an innocuous name.  */
++#define	syscall_error	__syscall_error
++#if __GNUC_PREREQ(4,4)
++#define mcount		__gnu_mcount_nc
++#else
++#define mcount		_mcount
++#endif
++
++#endif	/* __ASSEMBLER__ */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/Makefile
+@@ -0,0 +1,7 @@
++ASFLAGS-.os += -fPIC
++
++ifeq ($(subdir),elf)
++# Extra shared linker files to link only into dl-allobjs.so.
++sysdep-rtld-routines += dl-start
++endif
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/stackinfo.h
+@@ -0,0 +1,33 @@
++/* Copyright (C) 2013 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++/* This file contains a bit of information about the stack allocation
++   of the processor.  */
++
++#ifndef _STACKINFO_H
++#define _STACKINFO_H	1
++
++#include <elf.h>
++
++/* On or1k the stack grows down.  */
++#define _STACK_GROWS_DOWN	1
++
++/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
++ * present, but it is presumed absent.  */
++#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
++
++#endif /* stackinfo.h */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/dl-tls.h
+@@ -0,0 +1,30 @@
++/* Copyright (C) 2005-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public License as
++   published by the Free Software Foundation; either version 2.1 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++/* Type used for the representation of TLS information in the GOT.  */
++typedef struct
++{
++  unsigned long int ti_module;
++  unsigned long int ti_offset;
++} tls_index;
++
++
++extern void *__tls_get_addr (tls_index *ti);
++
++/* Value used for dtv entries for which the allocation is delayed.  */
++#define TLS_DTV_UNALLOCATED ((void *) -1l)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/crtn.S
+@@ -0,0 +1,35 @@
++# End .init and .fini sections.
++# Copyright (C) 2010 Embecosm Limited
++# 
++# This file is free software; you can redistribute it and/or modify it
++# under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 3, or (at your option)
++# any later version.
++# 
++# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
++# WARRANTY; without even the implied warranty of MERCHANTABILITY or
++# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++# for more details.
++# 
++# Under Section 7 of GPL version 3, you are granted additional
++# permissions described in the GCC Runtime Library Exception, version
++# 3.1, as published by the Free Software Foundation.
++#
++# You should have received a copy of the GNU General Public License and
++# a copy of the GCC Runtime Library Exception along with this program;
++# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
++# <http://www.gnu.org/licenses/>.
++
++  .section .init
++__init:
++  l.lwz r9,0(r1)
++  l.lwz r16,4(r1)
++  l.jr  r9
++  l.addi  r1,r1,8
++
++  .section .fini
++__fini:
++  l.lwz r9,0(r1)
++  l.jr  r9
++  l.addi  r1,r1,4
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/preconfigure
+@@ -0,0 +1,36 @@
++#
++# This is free and unencumbered software released into the public domain.
++# 
++# Anyone is free to copy, modify, publish, use, compile, sell, or
++# distribute this software, either in source code form or as a compiled
++# binary, for any purpose, commercial or non-commercial, and by any
++# means.
++# 
++# In jurisdictions that recognize copyright laws, the author or authors
++# of this software dedicate any and all copyright interest in the
++# software to the public domain. We make this dedication for the benefit
++# of the public at large and to the detriment of our heirs and
++# successors. We intend this dedication to be an overt act of
++# relinquishment in perpetuity of all present and future rights to this
++# software under copyright law.
++# 
++# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
++# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
++# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
++# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++# OTHER DEALINGS IN THE SOFTWARE.
++#
++
++case "$machine" in
++or1k*)
++  base_machine=or1k
++  machine=or1k
++
++  # Needed for relro detection
++  libc_commonpagesize=0x2000
++  libc_relro_required=yes
++  ;;
++esac
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/dl-trampoline.S
+@@ -0,0 +1,81 @@
++/*
++   Based on the or1k version from uClibc.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* This code is used to call _dl_linux_resolver (dl-runtime.c).
++
++   We assume that R11 contain relocation offset and R12 contains
++   link_map (_DYNAMIC). This must be consistent with the JUMP_SLOT
++   layout generated by binutils. */
++
++        .section .text
++        .align 4
++
++.global _dl_runtime_resolve
++.type  _dl_runtime_resolve, @function
++
++_dl_runtime_resolve:
++        .cfi_startproc
++        l.sw    -4(r1), r9
++        l.sw    -8(r1), r1
++
++        /* save function arguments */
++        l.sw    -12(r1), r3
++        l.sw    -16(r1), r4
++        l.sw    -20(r1), r5
++        l.sw    -24(r1), r6
++        l.sw    -28(r1), r7
++        l.sw    -32(r1), r8
++
++        .cfi_offset 9, -4
++        .cfi_offset 1, -8
++        .cfi_offset 3, -12
++        .cfi_offset 4, -16
++        .cfi_offset 5, -20
++        .cfi_offset 6, -24
++        .cfi_offset 7, -28
++        .cfi_offset 8, -32
++
++        l.addi  r1,r1, -32
++        .cfi_def_cfa_offset 32
++
++        l.ori   r3, r12, 0
++        l.ori   r4, r11, 0
++
++        l.jal   _dl_fixup
++        l.nop
++
++        /* restore function arguments */
++        l.addi  r1,r1, 32
++        l.lwz   r8, -32(r1)
++        l.lwz   r7, -28(r1)
++        l.lwz   r6, -24(r1)
++        l.lwz   r5, -20(r1)
++        l.lwz   r4, -16(r1)
++        l.lwz   r3, -12(r1)
++
++        /* restore return address */
++        l.lwz   r9, -4(r1)
++
++        l.jr    r11
++        l.nop
++
++        .cfi_endproc
++        .size _dl_runtime_resolve, . - _dl_runtime_resolve
++
++/* TODO: _dl_runtime_profile */
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/memusage.h
+@@ -0,0 +1,20 @@
++/* Copyright (C) 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#define GETSP() ({ register uintptr_t stack_ptr asm ("r1"); stack_ptr; })
++
++#include <sysdeps/generic/memusage.h>
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/bsd-setjmp.S
+@@ -0,0 +1 @@
++/* setjmp is in setjmp.S  */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/ldsodefs.h
+@@ -0,0 +1,40 @@
++/* Run-time dynamic linker data structures for loaded ELF shared objects.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef	_SH_LDSODEFS_H
++#define	_SH_LDSODEFS_H	1
++
++#include <elf.h>
++
++struct La_or1k_regs;
++struct La_or1k_retval;
++
++#define ARCH_PLTENTER_MEMBERS						\
++    uintptr_t (*or1k_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *, \
++				  uintptr_t *, struct La_or1k_regs *, \
++				  unsigned int *, const char *name,	\
++				  long int *framesizep)
++
++#define ARCH_PLTEXIT_MEMBERS						\
++    unsigned int (*or1k_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *, \
++				    uintptr_t *, const struct La_or1k_regs *, \
++				    struct La_or1k_retval *, const char *)
++
++#include_next <ldsodefs.h>
++
++#endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/dl-start.S
+@@ -0,0 +1,104 @@
++/* Machine-dependent ELF startup code.  or1k version.
++   Copyright (C) 1995-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <sysdep.h>
++
++/* Initial entry point code for the dynamic linker.
++   The C function `_dl_start' is the real entry point;
++   its return value is the user program's entry point. */
++ENTRY(_start)
++  /* Count arguments in r11 */
++  l.ori r3, r1, 0
++  l.movhi r11, 0
++1:
++  l.addi  r3, r3, 4
++  l.lwz r12, 0(r3)
++  l.sfnei r12, 0
++  l.addi  r11, r11, 1
++  l.bf  1b
++  l.nop
++  l.addi  r11, r11, -1
++  /* store argument counter to stack */
++  l.sw  0(r1), r11
++
++  l.jal .LPC0
++  l.nop
++  /* Load the PIC register */
++.LPC0:
++  l.movhi r16, gotpchi(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
++  l.ori r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
++  l.add r16, r16, r9
++
++  l.ori r3, r1, 0
++
++  l.jal _dl_start
++  l.nop
++  /* Save user entry in a call saved reg */
++  l.ori r22, r11, 0
++  /* Fall through to _dl_start_user */
++
++_dl_start_user:
++
++  /* Set up for _dl_init. */
++
++  /* Load _rtld_local (a.k.a _dl_loaded) */
++  l.lwz r12, got(_rtld_local)(r16)
++  l.lwz r3, 0(r12)
++
++  /* Load argc */
++  l.lwz r18, got(_dl_argc)(r16)
++  l.lwz r4, 0(r18)
++
++  /* Load argv */
++  l.lwz r20, got(INTUSE(_dl_argv))(r16)
++  l.lwz r5, 0(r20)
++
++  /* Load envp = &argv[argc + 1] */
++  l.slli r6, r4, 2
++  l.addi r6, r6, 4
++  l.add r6, r6, r5
++
++  l.jal plt(_dl_init_internal)
++  l.nop
++
++  /* Now set up for user entry.
++     The already defined ABI loads argc and argv from the stack.
++
++     argc = 0(r1)
++     argv = r1 + 4
++
++     Also, uClibc code sets r9 to _dl_fini, so we continue to do so.
++  */
++
++  /* Load SP as argv - 4*/
++  l.lwz r3, 0(r20)
++  l.addi r1, r3, -4
++
++  /* Save argc */
++  l.lwz r3, 0(r18)
++  l.sw 0(r1), r3
++
++  /* Load termination function address */
++  l.movhi r9, gotoffhi(_dl_fini)
++  l.ori r9, r9, gotofflo(_dl_fini)
++  l.add r9, r9, r16
++
++  l.jr  r22
++  l.nop
++
++END(_start)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/crti.S
+@@ -0,0 +1,74 @@
++# Start .init and .fini sections.
++# Copyright (C) 2010 Embecosm Limited
++# 
++# This file is free software; you can redistribute it and/or modify it
++# under the terms of the GNU General Public License as published by
++# the Free Software Foundation; either version 3, or (at your option)
++# any later version.
++# 
++# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
++# WARRANTY; without even the implied warranty of MERCHANTABILITY or
++# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++# for more details.
++# 
++# Under Section 7 of GPL version 3, you are granted additional
++# permissions described in the GCC Runtime Library Exception, version
++# 3.1, as published by the Free Software Foundation.
++#
++# You should have received a copy of the GNU General Public License and
++# a copy of the GCC Runtime Library Exception along with this program;
++# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
++# <http://www.gnu.org/licenses/>.
++
++#include <libc-symbols.h>
++#include <sysdep.h>
++
++#ifndef PREINIT_FUNCTION
++# define PREINIT_FUNCTION __gmon_start__
++#endif
++
++#ifndef PREINIT_FUNCTION_WEAK
++# define PREINIT_FUNCTION_WEAK 1
++#endif
++
++#if PREINIT_FUNCTION_WEAK
++	weak_extern (PREINIT_FUNCTION)
++#else
++	.hidden PREINIT_FUNCTION
++#endif
++
++	.section .init
++	.global _init
++_init:
++	l.addi  r1,r1,-8
++	l.sw  0(r1),r9
++	l.sw  4(r1),r16
++
++#if PREINIT_FUNCTION_WEAK
++	l.jal 8
++
++	/* Check if PREINIT_FUNCTION is loaded in GOT */
++	l.movhi  r16,gotpchi(_GLOBAL_OFFSET_TABLE_-4)
++	l.ori    r16,r16,gotpclo(_GLOBAL_OFFSET_TABLE_+0)
++	l.add    r16,r16,r9
++	l.lwz    r9,got(PREINIT_FUNCTION)(r16)
++	l.sfeqi  r9,0
++	l.bf     .Lno_weak_fn
++	l.nop
++
++	l.jal    plt(PREINIT_FUNCTION)
++	l.nop
++
++.Lno_weak_fn:
++#else
++	l.jal PREINIT_FUNCTION
++	l.nop
++
++#endif
++
++	.section .fini
++	.global _fini
++_fini:
++	l.addi  r1,r1,-4
++	l.sw    0(r1),r9
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/__longjmp.S
+@@ -0,0 +1,75 @@
++/* longjmp for or1k
++
++   Based on:
++   longjmp for PowerPC.
++   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++#include <features.h>
++#define _ASM
++#define _SETJMP_H
++#include <bits/setjmp.h>
++
++.globl     __longjmp;
++.type      __longjmp,@function;
++.align     2;
++
++__longjmp:    
++  l.lwz   r1,((JB_GPRS+0)*4)(r3)
++  l.lwz   r2,((JB_GPRS+1)*4)(r3)
++
++  /* if r4 is 0, something wrong, so set it to 1 */
++  l.sfeqi r4, 0x0
++  l.bnf   1f /* r4 != 0, longjmp value sensible */
++  l.nop
++  l.ori   r4, r0, 0x1 /* make nonzero */
++1:
++  l.addi  r11, r4, 0
++  l.lwz   r4,((JB_GPRS+3)*4)(r3)
++  l.lwz   r5,((JB_GPRS+4)*4)(r3)
++  l.lwz   r6,((JB_GPRS+5)*4)(r3)
++  l.lwz   r7,((JB_GPRS+6)*4)(r3)
++  l.lwz   r8,((JB_GPRS+7)*4)(r3)
++  l.lwz   r9,((JB_GPRS+8)*4)(r3)
++  l.lwz   r10,((JB_GPRS+9)*4)(r3)
++  l.lwz   r12,((JB_GPRS+11)*4)(r3)
++  l.lwz   r13,((JB_GPRS+12)*4)(r3)
++  l.lwz   r14,((JB_GPRS+13)*4)(r3)
++  l.lwz   r15,((JB_GPRS+14)*4)(r3)
++  l.lwz   r16,((JB_GPRS+15)*4)(r3)
++  l.lwz   r17,((JB_GPRS+16)*4)(r3)
++  l.lwz   r18,((JB_GPRS+17)*4)(r3)
++  l.lwz   r19,((JB_GPRS+18)*4)(r3)
++  l.lwz   r20,((JB_GPRS+19)*4)(r3)
++  l.lwz   r21,((JB_GPRS+20)*4)(r3)
++  l.lwz   r22,((JB_GPRS+21)*4)(r3)
++  l.lwz   r23,((JB_GPRS+22)*4)(r3)
++  l.lwz   r24,((JB_GPRS+23)*4)(r3)
++  l.lwz   r25,((JB_GPRS+24)*4)(r3)
++  l.lwz   r26,((JB_GPRS+25)*4)(r3)
++  l.lwz   r27,((JB_GPRS+26)*4)(r3)
++  l.lwz   r28,((JB_GPRS+27)*4)(r3)
++  l.lwz   r29,((JB_GPRS+28)*4)(r3)
++  l.lwz   r30,((JB_GPRS+29)*4)(r3)
++  l.lwz   r31,((JB_GPRS+30)*4)(r3)
++  l.jr  r9
++  l.nop
++.size     __longjmp,.-__longjmp
++
++libc_hidden_def(__longjmp)
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/jmpbuf-offsets.h
+@@ -0,0 +1,23 @@
++/* Private macros for accessing __jmp_buf contents.  ARM EABI version.
++   Copyright (C) 2007 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#define __JMP_BUF_SP		1
++
++/* Helper for generic ____longjmp_chk(). */
++#define JB_FRAME_ADDRESS(buf) \
++    ((void *) (unsigned long) (buf[__JMP_BUF_SP]))
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/start.S
+@@ -0,0 +1,144 @@
++/* Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002, 2005
++   Free Software Foundation, Inc.
++
++   Copyright (C) 2010 Embecosm Limited
++
++   Contributor  Jeremy Bennett <jeremy.bennett@embecosm.com>
++   Contributor  Joern Rennecke <joern.rennecke@embecosm.com>
++   With other contributions from the OpenCores community.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   In addition to the permissions in the GNU Lesser General Public
++   License, the Free Software Foundation gives you unlimited
++   permission to link the compiled version of this file with other
++   programs, and to distribute those programs without any restriction
++   coming from the use of this file. (The GNU Lesser General Public
++   License restrictions do apply in other respects; for example, they
++   cover modification of the file, and distribution when not linked
++   into another program.)
++
++   Note that people who make modified versions of this file are not
++   obligated to grant this special exception for their modified
++   versions; it is their choice whether to do so. The GNU Lesser
++   General Public License gives permission to release a modified
++   version without this exception; this exception also makes it
++   possible to release a modified version which carries forward this
++   exception.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* Stick in a dummy reference to main(), so that if an application
++ * is linking when the main() function is in a static library (.a)
++ * we can be sure that main() actually gets linked in */
++.type main,%function
++
++/* This is the canonical entry point, usually the first thing in the text
++   segment.
++
++   sp   The stack contains the arguments and environment:
++    0(sp)     argc
++    4(sp)     argv[0]
++    ...
++    (4*argc)(sp)    NULL
++    (4*(argc+1))(sp)  envp[0]
++    ...
++          NULL
++*/
++
++#include <features.h>
++
++.text
++  .globl  _start
++  .type _start,%function
++
++.global _start
++_start:
++
++#ifdef __PIC__
++  /* Obtain a pointer to .got in r16 */
++  l.jal .LPC0
++#ifndef __OR1K_NODELAY__
++  l.nop
++#endif
++.LPC0:
++  l.movhi r16, gotpchi(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
++  l.ori r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
++  l.add r16, r16, r9
++#endif
++
++  /* Push stack limit onto the stack */
++  /* Provides highest stack address to user code (as stack grows
++   * downwards
++   * This is the seventh argument to __libc_start_main and thus needs to
++   * be passed on the stack
++   */
++  l.sw  -4(r1),r1
++
++  /* Take values for argc and argv off the stack.
++   * These will be passed as arguments two and three to __uClibc_main
++   * and thus go in registers r4 and r5, respectively
++   */
++  l.lwz  r4,0(r1)
++  l.addi r5,r1,4
++
++#ifdef __PIC__
++  l.lwz r3,got(main)(r16)
++#else
++  l.movhi r3,hi(main)
++  l.ori   r3,r3,lo(main)
++#endif
++
++  /* Put the constructor and destructor initialization as args four and
++     five into r6 and r7 */
++#ifdef __PIC__
++  l.lwz r6, got(__libc_csu_init)(r16)
++  l.lwz r7, got(__libc_csu_fini)(r16)
++#else
++  l.movhi r6,hi(__libc_csu_init)
++  l.ori r6,r6,lo(__libc_csu_init)
++  l.movhi r7,hi(__libc_csu_fini)
++  l.ori r7,r7,lo(__libc_csu_fini)
++#endif
++
++  /* rtld_fini = NULL */
++  l.movhi r8, 0
++
++  /* Adjust stack to account for a total of 7 args (i.e. the last one is
++     on the stack. */
++  l.addi  r1,r1,-4
++
++  /* Clear the frame pointer and link register since this is the
++   * outermost frame.
++   */
++  l.add r2,r0,r0
++  l.add r9,r0,r0
++
++  /* Let the libc call main and exit with its return code.  */
++#ifdef __PIC__
++  l.j plt(__libc_start_main)
++#else
++  l.j __libc_start_main
++#endif
++   l.nop
++
++/* Define a symbol for the first piece of initialized data.  */
++  .data
++  .globl __data_start
++__data_start:
++  .long 0
++  .weak data_start
++  data_start = __data_start
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/libc-tls.c
+@@ -0,0 +1,32 @@
++/* Copyright (C) 2005-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public License as
++   published by the Free Software Foundation; either version 2.1 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <csu/libc-tls.c>
++#include <dl-tls.h>
++
++/* On AArch64, linker optimizations are not required, so __tls_get_addr
++   can be called even in statically linked binaries.  In this case module
++   must be always 1 and PT_TLS segment exist in the binary, otherwise it
++   would not link.  */
++
++void *
++__tls_get_addr (tls_index *ti)
++{
++  dtv_t *dtv = THREAD_DTV ();
++  return (char *) dtv[1].pointer.val + ti->ti_offset;
++}
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/jmpbuf-unwind.h
+@@ -0,0 +1,35 @@
++/* Copyright (C) 2005,2006 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#include <setjmp.h>
++#include <jmpbuf-offsets.h>
++#include <stdint.h>
++#include <unwind.h>
++
++/* Test if longjmp to JMPBUF would unwind the frame
++   containing a local variable at ADDRESS.  */
++#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
++  ((void *) (address) < (void *) demangle (jmpbuf[__JMP_BUF_SP]))
++
++#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
++  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
++
++#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
++  ((uintptr_t) (_address) - (_adj) < (uintptr_t) (_jmpbuf)[__JMP_BUF_SP] - (_adj))
++
++/* We use the normal longjmp for unwinding.  */
++#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/bsd-_setjmp.S
+@@ -0,0 +1 @@
++/* _setjmp is in setjmp.S  */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/dl-machine.h
+@@ -0,0 +1,317 @@
++/* Machine-dependent ELF dynamic relocation inline functions.  SH version.
++   Copyright (C) 1999-2012 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef dl_machine_h
++#define dl_machine_h
++
++#define ELF_MACHINE_NAME "or1k"
++
++#include <sys/param.h>
++#include <tls.h>
++#include <dl-irel.h>
++#include <assert.h>
++
++/* All relocs are Rela, no Rel */
++#define ELF_MACHINE_NO_REL 1
++
++/* Return nonzero iff ELF header is compatible with the running host.  */
++static inline int __attribute__ ((unused))
++elf_machine_matches_host (const Elf32_Ehdr *ehdr)
++{
++  return ehdr->e_machine == EM_OPENRISC;
++}
++
++static inline Elf32_Addr *
++or1k_get_got (void)
++{
++  Elf32_Addr *got;
++  Elf32_Addr linkreg;
++  __asm__("l.ori   %0, r9, 0\n"
++    "l.jal  8\n"
++    "l.movhi  %1, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\n"
++    "l.ori  %1, %1, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\n"
++    "l.add  %1, %1, r9\n"
++    "l.ori  r9, %0, 0\n"
++    : "=r" (linkreg), "=r" (got));
++
++  return got;
++}
++
++/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
++   first element of the GOT. */
++static inline Elf32_Addr
++elf_machine_dynamic (void)
++{
++  Elf32_Addr *got = or1k_get_got();
++  return *got;
++}
++
++
++/* Return the run-time load address of the shared object.  */
++static inline Elf32_Addr
++elf_machine_load_address (void)
++{
++  /* Compute the difference between the runtime address of _DYNAMIC as seen
++     by a GOTOFF reference, and the link-time address found in the special
++     unrelocated first GOT entry.  */
++  Elf32_Addr dyn;
++  Elf32_Addr *got = or1k_get_got();
++
++  __asm__ __volatile__ (
++    "l.movhi %0, gotoffhi(_DYNAMIC);"
++    "l.ori %0, %0, gotofflo(_DYNAMIC);"
++    "l.add %0, %0, %1;"
++    : "=r"(dyn) : "r"(got)
++    );
++
++  return dyn - *got;
++}
++
++/* Initial entry point code for the dynamic linker.
++   The C function `_dl_start' is the real entry point;
++   its return value is the user program's entry point.
++
++   Code is really located in dl-start.S, just tell the
++   linker that it exists. */
++#define RTLD_START asm (".globl _dl_start");
++
++/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or
++   TLS variable, so undefined references should not be allowed to
++   define the value.
++   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
++   of the main executable's symbols, as for a COPY reloc.  */
++
++#define elf_machine_type_class(type) \
++  (((type) == R_OR1K_JMP_SLOT \
++   || (type) == R_OR1K_TLS_DTPMOD \
++   || (type) == R_OR1K_TLS_DTPOFF \
++   || (type) == R_OR1K_TLS_TPOFF) * ELF_RTYPE_CLASS_PLT \
++   | ((type) == R_OR1K_COPY) * ELF_RTYPE_CLASS_COPY)
++
++/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
++#define ELF_MACHINE_JMP_SLOT    R_OR1K_JMP_SLOT
++
++#define ARCH_LA_PLTENTER or1k_gnu_pltenter
++#define ARCH_LA_PLTEXIT or1k_gnu_pltexit
++
++/* Set up the loaded object described by L so its unrelocated PLT
++   entries will jump to the on-demand fixup code in dl-runtime.c.  */
++static inline int __attribute__ ((unused, always_inline))
++elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
++{
++  ElfW(Addr) *gotplt;
++  extern void _dl_runtime_resolve (ElfW(Word));
++  extern void _dl_runtime_profile (ElfW(Word));
++
++  /* We do not support profiling yet */
++  assert(profile == 0);
++
++  if (l->l_info[DT_JMPREL] && lazy)
++    {
++      gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
++
++      /* Fill in the got */
++
++      /* Register our address in the got.
++       * This will also be used in the resolver for accessing the
++       * link_map structure. */
++      gotplt[1] = (ElfW(Addr)) l;
++
++      /* This function will get called to fix up the GOTPLT entry
++         indicated by the offset on the stack, and then jump to the
++         resolved address.  */
++      gotplt[2] = (ElfW(Addr)) &_dl_runtime_resolve;
++
++    }
++
++  return lazy;
++}
++
++/* Mask identifying addresses reserved for the user program,
++   where the dynamic linker should not map anything.  */
++#define ELF_MACHINE_USER_ADDRESS_MASK   0xf8000000UL
++
++/* We define an initialization functions.  This is called very early in
++   _dl_sysdep_start.  */
++#define DL_PLATFORM_INIT dl_platform_init ()
++
++static inline void __attribute__ ((unused))
++dl_platform_init (void)
++{
++  if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
++    /* Avoid an empty string which would disturb us.  */
++    GLRO(dl_platform) = NULL;
++}
++
++static inline Elf32_Addr
++elf_machine_fixup_plt (struct link_map *map, lookup_t t,
++                       const Elf32_Rela *reloc,
++                       Elf32_Addr *reloc_addr, Elf32_Addr value)
++{
++  return *reloc_addr = value;
++}
++
++/* Return the final value of a plt relocation.  */
++static inline Elf32_Addr
++elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
++                       Elf32_Addr value)
++{
++  return value + reloc->r_addend;
++}
++
++
++#endif /* !dl_machine_h */
++
++#ifdef RESOLVE_MAP
++
++/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
++   MAP is the object containing the reloc.  */
++
++auto inline void
++__attribute ((always_inline))
++elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
++                  const Elf32_Sym *sym, const struct r_found_version *version,
++                  void *const reloc_addr_arg, int skip_ifunc)
++{
++  Elf32_Addr *const reloc_addr = reloc_addr_arg;
++  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
++
++  if (__builtin_expect (r_type == R_OR1K_NONE, 0))
++    return;
++  else
++    {
++# ifndef RESOLVE_CONFLICT_FIND_MAP
++      const Elf32_Sym *const refsym = sym;
++# endif
++      struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
++      Elf32_Addr value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
++
++      if (sym != NULL
++          && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0)
++          && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
++          && __builtin_expect (!skip_ifunc, 1))
++        value = elf_ifunc_invoke (value);
++
++      switch (r_type)
++        {
++# ifndef RESOLVE_CONFLICT_FIND_MAP
++          case R_OR1K_COPY:
++            if (sym == NULL)
++              /* This can happen in trace mode if an object could not be
++                 found.  */
++              break;
++            if (__builtin_expect (sym->st_size > refsym->st_size, 0)
++                || (__builtin_expect (sym->st_size < refsym->st_size, 0)
++                  && GLRO(dl_verbose)))
++            {
++              const char *strtab;
++
++              strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
++              _dl_error_printf ("\
++%s: Symbol `%s' has different size in shared object, consider re-linking\n",
++                  rtld_progname ?: "<program name unknown>",
++                  strtab + refsym->st_name);
++            }
++            memcpy (reloc_addr_arg, (void *) value,
++                MIN (sym->st_size, refsym->st_size));
++            break;
++#endif
++          case R_OR1K_32:
++	    {
++	      /* Handle mis-aligned offsets */
++	      struct unaligned
++		{
++		  Elf32_Addr x;
++		} __attribute__ ((packed, may_alias));
++
++	      /* Support relocations on mis-aligned offsets.  */
++	      ((struct unaligned *) reloc_addr)->x = value + reloc->r_addend;
++	      break;
++	    }
++	  case R_OR1K_INSN_REL_26:
++	  case R_OR1K_GLOB_DAT:
++	  case R_OR1K_JMP_SLOT:
++	    *reloc_addr = value + reloc->r_addend;
++	    break;
++	  case R_OR1K_TLS_DTPMOD:
++# ifdef RTLD_BOOTSTRAP
++	    /* During startup the dynamic linker is always the module
++	       with index 1. */
++	    *reloc_addr = 1;
++# else
++	    if (sym_map != NULL)
++	      *reloc_addr = sym_map->l_tls_modid;
++# endif
++	    break;
++	  case R_OR1K_TLS_DTPOFF:
++# ifndef RTLD_BOOTSTRAP
++	    *reloc_addr = (sym == NULL ? 0 : sym->st_value) + reloc->r_addend;
++# endif
++	    break;
++
++          case R_OR1K_TLS_TPOFF:
++# ifdef RTLD_BOOTSTRAP
++	    *reloc_addr = sym->st_value + reloc->r_addend +
++	      map->l_tls_offset - TLS_TCB_SIZE;
++# else
++	    if (sym_map != NULL)
++	      {
++		CHECK_STATIC_TLS (map, sym_map);
++		*reloc_addr = sym->st_value + reloc->r_addend +
++		  sym_map->l_tls_offset - TLS_TCB_SIZE;
++	      }
++# endif
++	    break;
++          default:
++            _dl_fatal_printf("Unhandled reloc: %u\n", r_type);
++            _dl_reloc_bad_type (map, r_type, 0);
++            break;
++        }
++    }
++}
++
++auto inline void
++__attribute__ ((always_inline))
++elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
++                           void *const reloc_addr_arg)
++{
++  Elf32_Addr *const reloc_addr = reloc_addr_arg;
++  *reloc_addr = l_addr + reloc->r_addend;
++}
++
++auto inline void
++__attribute__ ((always_inline))
++elf_machine_lazy_rel (struct link_map *map,
++                      Elf32_Addr l_addr, const Elf32_Rela *reloc,
++                      int skip_ifunc)
++{
++  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
++  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
++
++  if (__builtin_expect (r_type == R_OR1K_JMP_SLOT, 1))
++      *reloc_addr += l_addr;
++  else if (__builtin_expect (r_type == R_OR1K_NONE, 0))
++    return;
++  else
++    {
++      _dl_fatal_printf("Unhandled lazy reloc: %u\n", r_type);
++      _dl_reloc_bad_type (map, r_type, 1);
++    }
++}
++
++#endif /* RESOLVE_MAP */
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/Implies
+@@ -0,0 +1,3 @@
++wordsize-32
++ieee754/flt-32
++ieee754/dbl-64
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/bits/fenv.h
+@@ -0,0 +1,74 @@
++/* Copyright (C) 2004-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public License as
++   published by the Free Software Foundation; either version 2.1 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _FENV_H
++# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
++#endif
++
++/* Define bits representing exceptions in the FPSR status word.  */
++enum
++  {
++    FE_INVALID =
++#define FE_INVALID	1
++      FE_INVALID,
++    FE_DIVBYZERO =
++#define FE_DIVBYZERO	2
++      FE_DIVBYZERO,
++    FE_OVERFLOW =
++#define FE_OVERFLOW	4
++      FE_OVERFLOW,
++    FE_UNDERFLOW =
++#define FE_UNDERFLOW	8
++      FE_UNDERFLOW,
++    FE_INEXACT =
++#define FE_INEXACT	16
++      FE_INEXACT,
++  };
++
++/* Amount to shift by to convert an exception bit in FPSR to a an
++   exception bit mask in FPCR.  */
++#define FE_EXCEPT_SHIFT	8
++
++/* All supported exceptions.  */
++#define FE_ALL_EXCEPT	\
++	(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW | FE_INEXACT)
++
++/* Define bits representing rounding modes in the FPCR Rmode field.  */
++#define FE_TONEAREST  0x000000
++#define FE_UPWARD     0x400000
++#define FE_DOWNWARD   0x800000
++#define FE_TOWARDZERO 0xc00000
++
++/* Type representing exception flags. */
++typedef unsigned int fexcept_t;
++
++/* Type representing floating-point environment.  */
++typedef struct
++  {
++    unsigned int __fpcr;
++    unsigned int __fpsr;
++  }
++fenv_t;
++
++/* If the default argument is used we use this value.  */
++#define FE_DFL_ENV	((const fenv_t *) -1l)
++
++#ifdef __USE_GNU
++/* Floating-point environment where none of the exceptions are masked.  */
++# define FE_NOMASK_ENV  ((const fenv_t *) -2)
++#endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/bits/endian.h
+@@ -0,0 +1,30 @@
++/*
++ * This is free and unencumbered software released into the public domain.
++ *
++ * Anyone is free to copy, modify, publish, use, compile, sell, or
++ * distribute this software, either in source code form or as a compiled
++ * binary, for any purpose, commercial or non-commercial, and by any
++ * means.
++ *
++ * In jurisdictions that recognize copyright laws, the author or authors
++ * of this software dedicate any and all copyright interest in the
++ * software to the public domain. We make this dedication for the benefit
++ * of the public at large and to the detriment of our heirs and
++ * successors. We intend this dedication to be an overt act of
++ * relinquishment in perpetuity of all present and future rights to this
++ * software under copyright law.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
++ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
++ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
++ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
++ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ * OTHER DEALINGS IN THE SOFTWARE.
++ */
++
++#ifndef _ENDIAN_H
++# error "Never use <bits/endian.h> directly; include <endian.h> instead."
++#endif
++
++#define __BYTE_ORDER __BIG_ENDIAN
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/bits/setjmp.h
+@@ -0,0 +1,47 @@
++/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, write to the Free
++   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
++   02111-1307 USA.  */
++
++/* Define the machine-dependent type `jmp_buf'.  or1k version.  */
++
++#ifndef _BITS_SETJMP_H
++#define _BITS_SETJMP_H  1
++
++#if !defined _SETJMP_H && !defined _PTHREAD_H
++# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
++#endif
++
++#if defined __USE_MISC || defined _ASM
++# define JB_SR     0  /* To save flag */
++# define JB_GPRS   1  /* Starting with GPR1, we don't save r0 - this is special register - allways zero */
++# define JB_SP     1  /* GPR1 */
++# define JB_LR     9  /* GPR9 */
++# define JB_RV     11 /* GPR11 */
++# define JB_SIZE   (32*4)
++#endif
++
++#ifndef _ASM
++typedef long int __jmp_buf[32];
++#endif
++
++/* Test if longjmp to JMPBUF would unwind the frame
++   containing a local variable at ADDRESS.  */
++#define _JMPBUF_UNWINDS(jmpbuf, address) \
++  ((void *) (address) < (void *) (jmpbuf)[JB_SP])
++
++#endif
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/nptl/Makefile
+@@ -0,0 +1,21 @@
++# Copyright (C) 2005-2012 Free Software Foundation, Inc.
++#
++# This file is part of the GNU C Library.
++#
++# The GNU C Library is free software; you can redistribute it and/or
++# modify it under the terms of the GNU Lesser General Public
++# License as published by the Free Software Foundation; either
++# version 2.1 of the License, or (at your option) any later version.
++#
++# The GNU C Library is distributed in the hope that it will be useful,
++# but WITHOUT ANY WARRANTY; without even the implied warranty of
++# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++# Lesser General Public License for more details.
++#
++# You should have received a copy of the GNU Lesser General Public
++# License along with the GNU C Library.  If not, see
++# <http://www.gnu.org/licenses/>.
++
++ifeq ($(subdir),csu)
++gen-as-const-headers += tcb-offsets.sym
++endif
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/nptl/tls.h
+@@ -0,0 +1,197 @@
++/* Definition for thread-local data handling.  NPTL/ARM version.
++   Copyright (C) 2005, 2007, 2011 Free Software Foundation, Inc.
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public
++   License as published by the Free Software Foundation; either
++   version 2.1 of the License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library.  If not, see
++   <http://www.gnu.org/licenses/>.  */
++
++#ifndef _TLS_H
++#define _TLS_H  1
++
++#include <dl-sysdep.h>
++
++#ifndef __ASSEMBLER__
++# include <stdbool.h>
++# include <stddef.h>
++# include <stdint.h>
++
++/* Type for the dtv.  */
++typedef union dtv
++{
++  size_t counter;
++  struct
++  {
++    void *val;
++    bool is_static;
++  } pointer;
++} dtv_t;
++
++typedef struct
++{
++  /* TODO: uintptr_t pointer_guard;
++   * TODO: uintptr_t stack_guard; */
++  dtv_t *dtv;
++} tcbhead_t;
++
++register tcbhead_t *__thread_self __asm__("r10");
++
++# define TLS_MULTIPLE_THREADS_IN_TCB 1
++
++#else /* __ASSEMBLER__ */
++# include <tcb-offsets.h>
++#endif /* __ASSEMBLER__ */
++
++#ifndef __ASSEMBLER__
++
++/* Get system call information.  */
++# include <sysdep.h>
++
++/* The TP points to the start of the TLS block.
++ * As I understand it, this isn't strictly that "TP points to DTV" - it's
++ * more where to place the TCB in the TLS block. This will place it in 
++ * the beginning.
++ *
++ * Layout:
++ *  ------------------------------------
++ *  | PRE | TCB | TLS MEMORY ..        |
++ *  ------------------------------------
++ *              ^ r10 / TP
++ *
++ * PRE is the struct pthread described below
++ * TCB is tcbhead_t
++ * TLS memory is where the TLS program sections are loaded
++ *
++ * See _dl_allocate_tls_storage and __libc_setup_tls for more information.
++ */
++# define TLS_DTV_AT_TP  1
++
++/* Get the thread descriptor definition.  */
++# include <nptl/descr.h>
++
++/* Requirements for the TCB.  */
++# define TLS_INIT_TCB_SIZE    sizeof (tcbhead_t)
++# define TLS_INIT_TCB_ALIGN   __alignof__ (tcbhead_t)
++
++# define TLS_TCB_SIZE         sizeof (tcbhead_t)
++# define TLS_TCB_ALIGN        __alignof__ (tcbhead_t)
++
++/* This is the size of the TCB.  */
++
++/* This is the size we need before TCB.
++ * To support THREAD_GETMEM with friends we want to have a
++ * struct pthread available.
++ * Yank it in infront of everything, I'm sure nobody will mind.
++ *
++ * This memory is really allocated PRE the TLS block, so it's possible
++ * to do ((char*)tlsblock) - TLS_PRE_TCB_SIZE to access it.
++ * This is done for THREAD_SELF. */
++# define TLS_PRE_TCB_SIZE sizeof (struct pthread)
++
++
++/* Install the dtv pointer.
++ * When called, dtvp is a pointer not the DTV per say (which should start
++ * with the generation counter) but to the length of the DTV.
++ * We can always index with -1, so we store dtvp[1]
++ */
++# define INSTALL_DTV(tcbp, dtvp) \
++  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
++
++/* Install new dtv for current thread
++ * In a logicial world dtv here would also point to the length of the DTV.
++ * However it does not, this time it points to the generation counter,
++ * so just store it.
++ *
++ * Note: -1 is still valid and contains the length. */
++# define INSTALL_NEW_DTV(dtv) \
++  (THREAD_DTV() = (dtv))
++
++/* Return dtv of given thread descriptor.  */
++# define GET_DTV(tcbp) \
++  (((tcbhead_t *) (tcbp))->dtv)
++
++/* Code to initially initialize the thread pointer.
++ *
++ * Set TP to the address _after_ tcbhead_t. This will allow us
++ * to change the size of tcbhead_t without having to re-link everything.
++ *
++ * secondcall has something to do with USE__THREAD,
++ * seems to always be 0 so we don't care about it.
++ *
++ * This has to return NULL on success (or a string with the failure text).
++ * It's hard to fail this, so return NULL always.
++ */
++# define TLS_INIT_TP(tcbp, secondcall) \
++  ({__thread_self = ((tcbhead_t *)tcbp + 1); NULL;})
++
++/* Return the address of the dtv for the current thread.
++ *
++ * Dereference TP, offset to dtv - really straightforward.
++ * Remember that we made TP point to after tcb, so we need to reverse that.
++ */
++#  define THREAD_DTV() \
++  ((((tcbhead_t *)__thread_self)-1)->dtv)
++
++/* Return the thread descriptor for the current thread. 
++ *
++ * Return a pointer to the TLS_PRE area where we allocated space for
++ * a struct pthread. Again, TP points to after tcbhead_t, compensate with
++ * TLS_INIT_TCB_SIZE.
++ *
++ * I regard this is a seperate system from the "normal" TLS.
++ */
++# define THREAD_SELF \
++  ((struct pthread *) ((char *) __thread_self - TLS_INIT_TCB_SIZE \
++    - TLS_PRE_TCB_SIZE))
++
++/* Magic for libthread_db to know how to do THREAD_SELF.  */
++# define DB_THREAD_SELF \
++  CONST_THREAD_AREA (32, sizeof (struct pthread))
++
++/* Access to data in the thread descriptor is easy.  */
++#define THREAD_GETMEM(descr, member) \
++  descr->member
++#define THREAD_GETMEM_NC(descr, member, idx) \
++  descr->member[idx]
++#define THREAD_SETMEM(descr, member, value) \
++  descr->member = (value)
++#define THREAD_SETMEM_NC(descr, member, idx, value) \
++  descr->member[idx] = (value)
++
++/* Get and set the global scope generation counter in struct pthread.  */
++#define THREAD_GSCOPE_FLAG_UNUSED 0
++#define THREAD_GSCOPE_FLAG_USED   1
++#define THREAD_GSCOPE_FLAG_WAIT   2
++#define THREAD_GSCOPE_RESET_FLAG() \
++  do                       \
++    { int __res                    \
++  = atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,       \
++             THREAD_GSCOPE_FLAG_UNUSED);         \
++      if (__res == THREAD_GSCOPE_FLAG_WAIT)            \
++  lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
++    }                      \
++  while (0)
++#define THREAD_GSCOPE_SET_FLAG() \
++  do                       \
++    {                      \
++      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;       \
++      atomic_write_barrier ();                 \
++    }                      \
++  while (0)
++#define THREAD_GSCOPE_WAIT() \
++  GL(dl_wait_lookup_done) ()
++
++#endif /* __ASSEMBLER__ */
++
++#endif  /* tls.h */
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/nptl/pthreaddef.h
+@@ -0,0 +1,38 @@
++/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
++
++   This file is part of the GNU C Library.
++
++   The GNU C Library is free software; you can redistribute it and/or
++   modify it under the terms of the GNU Lesser General Public License as
++   published by the Free Software Foundation; either version 2.1 of the
++   License, or (at your option) any later version.
++
++   The GNU C Library is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++   Lesser General Public License for more details.
++
++   You should have received a copy of the GNU Lesser General Public
++   License along with the GNU C Library; if not, see
++   <http://www.gnu.org/licenses/>.  */
++
++/* Default stack size.  */
++#define ARCH_STACK_DEFAULT_SIZE (2 * 1024 * 1024)
++
++/* Required stack pointer alignment at beginning.  */
++#define STACK_ALIGN 16
++
++/* Minimal stack size after allocating thread descriptor and guard size.  */
++#define MINIMAL_REST_STACK 2048
++
++/* Alignment requirement for TCB.  */
++#define TCB_ALIGNMENT 16
++
++/* Location of current stack frame.  */
++#define CURRENT_STACK_FRAME __builtin_frame_address (0)
++
++
++/* XXX Until we have a better place keep the definitions here.  */
++#define __exit_thread_inline(val) \
++  INLINE_SYSCALL (exit, 1, (val))
++
+--- /dev/null
++++ eglibc-2.18/ports/sysdeps/or1k/nptl/tcb-offsets.sym
+@@ -0,0 +1,9 @@
++#include <sysdep.h>
++#include <tls.h>
++
++PTHREAD_MULTIPLE_THREADS_OFFSET		offsetof (struct pthread, header.multiple_threads)
++PTHREAD_PID_OFFSET			offsetof (struct pthread, pid)
++PTHREAD_TID_OFFSET			offsetof (struct pthread, tid)
++PTHREAD_SIZEOF				sizeof (struct pthread)
++TCB_SIZEOF				sizeof (tcbhead_t)
++TP_TO_PTHREAD_OFFSET			-(sizeof (struct pthread) + sizeof (tcbhead_t))
diff -Nru eglibc-2.18/debian/patches/series eglibc-2.18/debian/patches/series
--- eglibc-2.18/debian/patches/series	2014-01-10 17:50:59.000000000 +0000
+++ eglibc-2.18/debian/patches/series	2014-01-17 08:21:41.000000000 +0000
@@ -262,3 +262,4 @@
 any/cvs-DL_CALL_DT_INIT_FINI.diff
 any/cvs-vfscanf-0e+0.diff
 any/cvs-ptrace_peeksiginfo_args.diff
+or1k/support.diff
diff -Nru eglibc-2.18/debian/rules.d/control.mk eglibc-2.18/debian/rules.d/control.mk
--- eglibc-2.18/debian/rules.d/control.mk	2013-11-29 08:24:28.000000000 +0000
+++ eglibc-2.18/debian/rules.d/control.mk	2014-01-21 07:23:59.000000000 +0000
@@ -1,7 +1,7 @@
 libc_packages := libc6 libc6.1 libc0.1 libc0.3
 libc0_1_archs := kfreebsd-amd64 kfreebsd-i386
 libc0_3_archs := hurd-i386
-libc6_archs   := amd64 arm arm64 armel armhf hppa i386 m68k mips mipsel powerpc powerpcspe ppc64 ppc64el sparc sparc64 s390x sh4 x32
+libc6_archs   := amd64 arm arm64 armel armhf hppa i386 m68k mips or1k mipsel powerpc powerpcspe ppc64 ppc64el sparc sparc64 s390x sh4 x32
 libc6_1_archs := alpha ia64
 
 control_deps := $(wildcard debian/control.in/*) $(addprefix debian/control.in/, $(libc_packages))
diff -Nru eglibc-2.18/debian/sysdeps/or1k.mk eglibc-2.18/debian/sysdeps/or1k.mk
--- eglibc-2.18/debian/sysdeps/or1k.mk	1970-01-01 00:00:00.000000000 +0000
+++ eglibc-2.18/debian/sysdeps/or1k.mk	2014-01-21 07:23:25.000000000 +0000
@@ -0,0 +1,4 @@
+libc_add-ons = ports nptl $(add-ons)
+
+# No --enable-multi-arch until binutils patches catch up:
+extra_config_options = --disable-profile
