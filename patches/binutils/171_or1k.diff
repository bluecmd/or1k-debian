--- a/bfd/Makefile.am
+++ b/bfd/Makefile.am
@@ -138,8 +138,7 @@
 	cpu-mt.lo \
 	cpu-nios2.lo \
 	cpu-ns32k.lo \
-	cpu-openrisc.lo \
-	cpu-or32.lo \
+	cpu-or1k.lo \
 	cpu-pdp11.lo \
 	cpu-pj.lo \
 	cpu-plugin.lo \
@@ -222,8 +221,7 @@
 	cpu-mt.c \
 	cpu-ns32k.c \
 	cpu-nios2.c \
-	cpu-openrisc.c \
-	cpu-or32.c \
+	cpu-or1k.c \
 	cpu-pdp11.c \
 	cpu-pj.c \
 	cpu-plugin.c \
@@ -282,7 +280,6 @@
 	coff-m68k.lo \
 	coff-m88k.lo \
 	coff-mips.lo \
-	coff-or32.lo \
 	coff-rs6000.lo \
 	coff-sh.lo \
 	coff-sparc.lo \
@@ -350,8 +347,7 @@
 	elf32-msp430.lo \
 	elf32-mt.lo \
 	elf32-nios2.lo \
-	elf32-openrisc.lo \
-	elf32-or32.lo \
+	elf32-or1k.lo \
 	elf32-pj.lo \
 	elf32-ppc.lo \
 	elf32-rl78.lo \
@@ -470,7 +466,6 @@
 	coff-m68k.c \
 	coff-m88k.c \
 	coff-mips.c \
-	coff-or32.c \
 	coff-rs6000.c \
 	coff-sh.c \
 	coff-sparc.c \
@@ -538,8 +533,7 @@
 	elf32-msp430.c \
 	elf32-mt.c \
 	elf32-nios2.c \
-	elf32-openrisc.c \
-	elf32-or32.c \
+	elf32-or1k.c \
 	elf32-pj.c \
 	elf32-ppc.c \
 	elf32-rl78.c \
--- a/bfd/Makefile.in
+++ b/bfd/Makefile.in
@@ -439,8 +439,7 @@
 	cpu-mt.lo \
 	cpu-nios2.lo \
 	cpu-ns32k.lo \
-	cpu-openrisc.lo \
-	cpu-or32.lo \
+	cpu-or1k.lo \
 	cpu-pdp11.lo \
 	cpu-pj.lo \
 	cpu-plugin.lo \
@@ -523,8 +522,7 @@
 	cpu-mt.c \
 	cpu-ns32k.c \
 	cpu-nios2.c \
-	cpu-openrisc.c \
-	cpu-or32.c \
+	cpu-or1k.c \
 	cpu-pdp11.c \
 	cpu-pj.c \
 	cpu-plugin.c \
@@ -584,7 +582,6 @@
 	coff-m68k.lo \
 	coff-m88k.lo \
 	coff-mips.lo \
-	coff-or32.lo \
 	coff-rs6000.lo \
 	coff-sh.lo \
 	coff-sparc.lo \
@@ -652,8 +649,7 @@
 	elf32-msp430.lo \
 	elf32-mt.lo \
 	elf32-nios2.lo \
-	elf32-openrisc.lo \
-	elf32-or32.lo \
+	elf32-or1k.lo \
 	elf32-pj.lo \
 	elf32-ppc.lo \
 	elf32-rl78.lo \
@@ -772,7 +768,6 @@
 	coff-m68k.c \
 	coff-m88k.c \
 	coff-mips.c \
-	coff-or32.c \
 	coff-rs6000.c \
 	coff-sh.c \
 	coff-sparc.c \
@@ -840,8 +835,7 @@
 	elf32-msp430.c \
 	elf32-mt.c \
 	elf32-nios2.c \
-	elf32-openrisc.c \
-	elf32-or32.c \
+	elf32-or1k.c \
 	elf32-pj.c \
 	elf32-ppc.c \
 	elf32-rl78.c \
@@ -1283,7 +1277,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-m68k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-m88k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-mips.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-or32.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-rs6000.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-sh.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coff-sparc.Plo@am__quote@
@@ -1354,8 +1347,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-mt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-nios2.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-ns32k.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-openrisc.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-or32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-or1k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-pdp11.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-pj.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu-plugin.Plo@am__quote@
@@ -1443,8 +1435,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-msp430.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-mt.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-nios2.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-openrisc.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-or32.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-or1k.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-pj.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-ppc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/elf32-rl78.Plo@am__quote@
--- a/bfd/archures.c
+++ b/bfd/archures.c
@@ -121,7 +121,9 @@
 .#define bfd_mach_i960_jx	 7
 .#define bfd_mach_i960_hx        8
 .
-.  bfd_arch_or32,      {* OpenRISC 32 *}
+.  bfd_arch_or1k,      {* OpenRISC 1000 *}
+.#define bfd_mach_or1k           1
+.#define bfd_mach_or1knd         2
 .
 .  bfd_arch_sparc,     {* SPARC *}
 .#define bfd_mach_sparc			1
@@ -576,8 +578,7 @@
 extern const bfd_arch_info_type bfd_mt_arch;
 extern const bfd_arch_info_type bfd_nios2_arch;
 extern const bfd_arch_info_type bfd_ns32k_arch;
-extern const bfd_arch_info_type bfd_openrisc_arch;
-extern const bfd_arch_info_type bfd_or32_arch;
+extern const bfd_arch_info_type bfd_or1k_arch;
 extern const bfd_arch_info_type bfd_pdp11_arch;
 extern const bfd_arch_info_type bfd_pj_arch;
 extern const bfd_arch_info_type bfd_plugin_arch;
@@ -665,8 +666,7 @@
     &bfd_mt_arch,
     &bfd_nios2_arch,
     &bfd_ns32k_arch,
-    &bfd_openrisc_arch,
-    &bfd_or32_arch,
+    &bfd_or1k_arch,
     &bfd_pdp11_arch,
     &bfd_powerpc_arch,
     &bfd_rs6000_arch,
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1876,7 +1876,9 @@
 #define bfd_mach_i960_jx        7
 #define bfd_mach_i960_hx        8
 
-  bfd_arch_or32,      /* OpenRISC 32 */
+  bfd_arch_or1k,      /* OpenRISC 1000 */
+#define bfd_mach_or1k           1
+#define bfd_mach_or1knd         2
 
   bfd_arch_sparc,     /* SPARC */
 #define bfd_mach_sparc                 1
@@ -4914,9 +4916,31 @@
   BFD_RELOC_860_HIGOT,
   BFD_RELOC_860_HIGOTOFF,
 
-/* OpenRISC Relocations.  */
-  BFD_RELOC_OPENRISC_ABS_26,
-  BFD_RELOC_OPENRISC_REL_26,
+/* OpenRISC 1000 Relocations.  */
+  BFD_RELOC_OR1K_REL_26,
+  BFD_RELOC_OR1K_GOTPC_HI16,
+  BFD_RELOC_OR1K_GOTPC_LO16,
+  BFD_RELOC_OR1K_GOT16,
+  BFD_RELOC_OR1K_PLT26,
+  BFD_RELOC_OR1K_GOTOFF_HI16,
+  BFD_RELOC_OR1K_GOTOFF_LO16,
+  BFD_RELOC_OR1K_COPY,
+  BFD_RELOC_OR1K_GLOB_DAT,
+  BFD_RELOC_OR1K_JMP_SLOT,
+  BFD_RELOC_OR1K_RELATIVE,
+  BFD_RELOC_OR1K_TLS_GD_HI16,
+  BFD_RELOC_OR1K_TLS_GD_LO16,
+  BFD_RELOC_OR1K_TLS_LDM_HI16,
+  BFD_RELOC_OR1K_TLS_LDM_LO16,
+  BFD_RELOC_OR1K_TLS_LDO_HI16,
+  BFD_RELOC_OR1K_TLS_LDO_LO16,
+  BFD_RELOC_OR1K_TLS_IE_HI16,
+  BFD_RELOC_OR1K_TLS_IE_LO16,
+  BFD_RELOC_OR1K_TLS_LE_HI16,
+  BFD_RELOC_OR1K_TLS_LE_LO16,
+  BFD_RELOC_OR1K_TLS_TPOFF,
+  BFD_RELOC_OR1K_TLS_DTPOFF,
+  BFD_RELOC_OR1K_TLS_DTPMOD,
 
 /* H8 elf Relocations.  */
   BFD_RELOC_H8_DIR16A8,
--- a/bfd/coff-or32.c
+++ /dev/null
@@ -1,629 +0,0 @@
-/* BFD back-end for OpenRISC 1000 COFF binaries.
-   Copyright 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2011, 2012
-   Free Software Foundation, Inc.
-   Contributed by Ivan Guzvinec  <ivang@opencores.org>
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#define OR32 1
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libbfd.h"
-#include "coff/or32.h"
-#include "coff/internal.h"
-#include "libcoff.h"
-
-static bfd_reloc_status_type or32_reloc
-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
-
-#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (2)
-
-#define INSERT_HWORD(WORD,HWORD)              \
-    (((WORD) & 0xffff0000) | ((HWORD)& 0x0000ffff))
-#define EXTRACT_HWORD(WORD)                   \
-    ((WORD) & 0x0000ffff)
-#define SIGN_EXTEND_HWORD(HWORD)              \
-    ((HWORD) & 0x8000 ? (HWORD)|(~0xffffL) : (HWORD))
-
-#define INSERT_JUMPTARG(WORD,JT)              \
-    (((WORD) & 0xfc000000) | ((JT)& 0x03ffffff))
-#define EXTRACT_JUMPTARG(WORD)                   \
-    ((WORD) & 0x03ffffff)
-#define SIGN_EXTEND_JUMPTARG(JT)              \
-    ((JT) & 0x04000000 ? (JT)|(~0x03ffffffL) : (JT))
-
-/* Provided the symbol, returns the value reffed.  */
-
-static long
-get_symbol_value (asymbol *symbol)
-{
-  long relocation = 0;
-
-  if (bfd_is_com_section (symbol->section))
-    relocation = 0;
-  else
-    relocation = symbol->value +
-      symbol->section->output_section->vma +
-      symbol->section->output_offset;
-
-  return relocation;
-}
-
-/* This function is in charge of performing all the or32 relocations.  */
-
-static bfd_reloc_status_type
-or32_reloc (bfd *abfd,
-	    arelent *reloc_entry,
-	    asymbol *symbol_in,
-	    void * data,
-	    asection *input_section,
-	    bfd *output_bfd,
-	    char **error_message)
-{
-  /* The consth relocation comes in two parts, we have to remember
-     the state between calls, in these variables.  */
-  static bfd_boolean part1_consth_active = FALSE;
-  static unsigned long part1_consth_value;
-
-  unsigned long insn;
-  unsigned long sym_value;
-  unsigned long unsigned_value;
-  unsigned short r_type;
-  long signed_value;
-
-  unsigned long addr = reloc_entry->address ;   /*+ input_section->vma*/
-  bfd_byte *hit_data =addr + (bfd_byte *)(data);
-
-  r_type = reloc_entry->howto->type;
-
-  if (output_bfd)
-    {
-      /* Partial linking - do nothing.  */
-      reloc_entry->address += input_section->output_offset;
-      return bfd_reloc_ok;
-    }
-
-  if (symbol_in != NULL
-      && bfd_is_und_section (symbol_in->section))
-    {
-      /* Keep the state machine happy in case we're called again.  */
-      if (r_type == R_IHIHALF)
-        {
-          part1_consth_active = TRUE;
-          part1_consth_value  = 0;
-        }
-
-      return bfd_reloc_undefined;
-    }
-
-  if ((part1_consth_active) && (r_type != R_IHCONST))
-    {
-      part1_consth_active = FALSE;
-      *error_message = (char *) "Missing IHCONST";
-
-      return bfd_reloc_dangerous;
-    }
-
-  sym_value = get_symbol_value (symbol_in);
-
-  switch (r_type)
-    {
-    case R_IREL:
-      insn = bfd_get_32(abfd, hit_data);
-
-      /* Take the value in the field and sign extend it.  */
-      signed_value = EXTRACT_JUMPTARG (insn);
-      signed_value = SIGN_EXTEND_JUMPTARG (signed_value);
-      signed_value <<= 2;
-
-      /* See the note on the R_IREL reloc in coff_or32_relocate_section.  */
-      if (signed_value == - (long) reloc_entry->address)
-        signed_value = 0;
-
-      signed_value += sym_value + reloc_entry->addend;
-      /* Relative jmp/call, so subtract from the value the
-	 address of the place we're coming from.  */
-      signed_value -= (reloc_entry->address
-		       + input_section->output_section->vma
-		       + input_section->output_offset);
-      if (signed_value > 0x7ffffff || signed_value < -0x8000000)
-	return bfd_reloc_overflow;
-
-      signed_value >>= 2;
-      insn = INSERT_JUMPTARG (insn, signed_value);
-      bfd_put_32 (abfd, insn, hit_data);
-      break;
-
-    case R_ILOHALF:
-      insn = bfd_get_32 (abfd, hit_data);
-      unsigned_value = EXTRACT_HWORD (insn);
-      unsigned_value +=  sym_value + reloc_entry->addend;
-      insn = INSERT_HWORD (insn, unsigned_value);
-      bfd_put_32 (abfd, insn, hit_data);
-      break;
-
-    case R_IHIHALF:
-      insn = bfd_get_32 (abfd, hit_data);
-
-      /* consth, part 1
-         Just get the symbol value that is referenced.  */
-      part1_consth_active = TRUE;
-      part1_consth_value = sym_value + reloc_entry->addend;
-
-      /* Don't modify insn until R_IHCONST.  */
-      break;
-
-    case R_IHCONST:
-      insn = bfd_get_32 (abfd, hit_data);
-
-      /* consth, part 2
-         Now relocate the reference.  */
-      if (! part1_consth_active)
-        {
-          *error_message = (char *) "Missing IHIHALF";
-          return bfd_reloc_dangerous;
-        }
-
-      /* sym_ptr_ptr = r_symndx, in coff_slurp_reloc_table() */
-      unsigned_value = 0;   /*EXTRACT_HWORD(insn) << 16;*/
-      unsigned_value += reloc_entry->addend; /* r_symndx */
-      unsigned_value += part1_consth_value;
-      unsigned_value = unsigned_value >> 16;
-      insn = INSERT_HWORD (insn, unsigned_value);
-      part1_consth_active = FALSE;
-      bfd_put_32 (abfd, insn, hit_data);
-      break;
-
-    case R_BYTE:
-      insn = bfd_get_8 (abfd, hit_data);
-      unsigned_value = insn + sym_value + reloc_entry->addend;
-      if (unsigned_value & 0xffffff00)
-        return bfd_reloc_overflow;
-      bfd_put_8 (abfd, unsigned_value, hit_data);
-      break;
-
-    case R_HWORD:
-      insn = bfd_get_16 (abfd, hit_data);
-      unsigned_value = insn + sym_value + reloc_entry->addend;
-      if (unsigned_value & 0xffff0000)
-        return bfd_reloc_overflow;
-      bfd_put_16 (abfd, insn, hit_data);
-      break;
-
-    case R_WORD:
-      insn = bfd_get_32 (abfd, hit_data);
-      insn += sym_value + reloc_entry->addend;
-      bfd_put_32 (abfd, insn, hit_data);
-      break;
-
-    default:
-      *error_message = _("Unrecognized reloc");
-      return bfd_reloc_dangerous;
-    }
-
-  return bfd_reloc_ok;
-}
-
-/*      type     rightshift
-           size
-        bitsize
-             pc-relative
-             bitpos
-           absolute
-               complain_on_overflow
-              special_function
-                relocation name
-                     partial_inplace
-                      src_mask
-*/
-
-/* FIXME: I'm not real sure about this table.  */
-static reloc_howto_type howto_table[] =
-{
-  { R_ABS,      0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "ABS",     TRUE, 0xffffffff,0xffffffff, FALSE },
-    EMPTY_HOWTO (1),
-    EMPTY_HOWTO (2),
-    EMPTY_HOWTO (3),
-    EMPTY_HOWTO (4),
-    EMPTY_HOWTO (5),
-    EMPTY_HOWTO (6),
-    EMPTY_HOWTO (7),
-    EMPTY_HOWTO (8),
-    EMPTY_HOWTO (9),
-    EMPTY_HOWTO (10),
-    EMPTY_HOWTO (11),
-    EMPTY_HOWTO (12),
-    EMPTY_HOWTO (13),
-    EMPTY_HOWTO (14),
-    EMPTY_HOWTO (15),
-    EMPTY_HOWTO (16),
-    EMPTY_HOWTO (17),
-    EMPTY_HOWTO (18),
-    EMPTY_HOWTO (19),
-    EMPTY_HOWTO (20),
-    EMPTY_HOWTO (21),
-    EMPTY_HOWTO (22),
-    EMPTY_HOWTO (23),
-  { R_IREL,     0, 3, 32, TRUE,   0, complain_overflow_signed,    or32_reloc, "IREL",    TRUE, 0xffffffff,0xffffffff, FALSE },
-  { R_IABS,     0, 3, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "IABS",    TRUE, 0xffffffff,0xffffffff, FALSE },
-  { R_ILOHALF,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "ILOHALF", TRUE, 0x0000ffff,0x0000ffff, FALSE },
-  { R_IHIHALF,  0, 3, 16, TRUE,   16,complain_overflow_signed,    or32_reloc, "IHIHALF", TRUE, 0xffff0000,0xffff0000, FALSE },
-  { R_IHCONST,  0, 3, 16, TRUE,   0, complain_overflow_signed,    or32_reloc, "IHCONST", TRUE, 0xffff0000,0xffff0000, FALSE },
-  { R_BYTE,     0, 0, 8,  FALSE,  0, complain_overflow_bitfield,  or32_reloc, "BYTE",    TRUE, 0x000000ff,0x000000ff, FALSE },
-  { R_HWORD,    0, 1, 16, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "HWORD",   TRUE, 0x0000ffff,0x0000ffff, FALSE },
-  { R_WORD,     0, 2, 32, FALSE,  0, complain_overflow_bitfield,  or32_reloc, "WORD",    TRUE, 0xffffffff,0xffffffff, FALSE },
-};
-
-#define BADMAG(x) OR32BADMAG (x)
-
-#define RELOC_PROCESSING(relent, reloc, symbols, abfd, section) \
-  reloc_processing (relent, reloc, symbols, abfd, section)
-
-static void
-reloc_processing (arelent *relent,
-		  struct internal_reloc *reloc,
-		  asymbol **symbols,
-		  bfd *abfd,
-		  asection *section)
-{
-  static bfd_vma ihihalf_vaddr = (bfd_vma) -1;
-
-  relent->address = reloc->r_vaddr;
-  relent->howto = howto_table + reloc->r_type;
-
-  if (reloc->r_type == R_IHCONST)
-    {
-      /* The address of an R_IHCONST should always be the address of
-	 the immediately preceding R_IHIHALF.  relocs generated by gas
-	 are correct, but relocs generated by High C are different (I
-	 can't figure out what the address means for High C).  We can
-	 handle both gas and High C by ignoring the address here, and
-	 simply reusing the address saved for R_IHIHALF.  */
-      if (ihihalf_vaddr == (bfd_vma) -1)
-	abort ();
-
-      relent->address = ihihalf_vaddr;
-      ihihalf_vaddr = (bfd_vma) -1;
-      relent->addend = reloc->r_symndx;
-      relent->sym_ptr_ptr= bfd_abs_section_ptr->symbol_ptr_ptr;
-    }
-  else
-    {
-      relent->sym_ptr_ptr = symbols + obj_convert (abfd)[reloc->r_symndx];
-      relent->addend = 0;
-      relent->address-= section->vma;
-
-      if (reloc->r_type == R_IHIHALF)
-	ihihalf_vaddr = relent->address;
-      else if (ihihalf_vaddr != (bfd_vma) -1)
-	abort ();
-    }
-}
-
-/* The reloc processing routine for the optimized COFF linker.  */
-
-static bfd_boolean
-coff_or32_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
-			    struct bfd_link_info *info,
-			    bfd *input_bfd,
-			    asection *input_section,
-			    bfd_byte *contents,
-			    struct internal_reloc *relocs,
-			    struct internal_syment *syms,
-			    asection **sections)
-{
-  struct internal_reloc *rel;
-  struct internal_reloc *relend;
-  bfd_boolean hihalf;
-  bfd_vma hihalf_val;
-
-  /* If we are performing a relocatable link, we don't need to do a
-     thing.  The caller will take care of adjusting the reloc
-     addresses and symbol indices.  */
-  if (info->relocatable)
-    return TRUE;
-
-  hihalf = FALSE;
-  hihalf_val = 0;
-
-  rel = relocs;
-  relend = rel + input_section->reloc_count;
-
-  for (; rel < relend; rel++)
-    {
-      long symndx;
-      bfd_byte *loc;
-      struct coff_link_hash_entry *h;
-      struct internal_syment *sym;
-      asection *sec;
-      bfd_vma val;
-      bfd_boolean overflow;
-      unsigned long insn;
-      long signed_value;
-      unsigned long unsigned_value;
-      bfd_reloc_status_type rstat;
-
-      symndx = rel->r_symndx;
-      loc = contents + rel->r_vaddr - input_section->vma;
-
-      if (symndx == -1 || rel->r_type == R_IHCONST)
-        h = NULL;
-      else
-        h = obj_coff_sym_hashes (input_bfd)[symndx];
-
-      sym = NULL;
-      sec = NULL;
-      val = 0;
-
-      /* An R_IHCONST reloc does not have a symbol.  Instead, the
-         symbol index is an addend.  R_IHCONST is always used in
-         conjunction with R_IHHALF.  */
-      if (rel->r_type != R_IHCONST)
-        {
-          if (h == NULL)
-            {
-              if (symndx == -1)
-                sec = bfd_abs_section_ptr;
-              else
-                {
-                  sym = syms + symndx;
-                  sec = sections[symndx];
-                  val = (sec->output_section->vma
-                         + sec->output_offset
-                         + sym->n_value
-                         - sec->vma);
-                }
-            }
-          else
-            {
-              if (h->root.type == bfd_link_hash_defined
-                  || h->root.type == bfd_link_hash_defweak)
-                {
-                  sec = h->root.u.def.section;
-                  val = (h->root.u.def.value
-                         + sec->output_section->vma
-                         + sec->output_offset);
-                }
-              else
-                {
-                  if (! ((*info->callbacks->undefined_symbol)
-                         (info, h->root.root.string, input_bfd, input_section,
-                          rel->r_vaddr - input_section->vma, TRUE)))
-                    return FALSE;
-                }
-            }
-
-          if (hihalf)
-            {
-              if (! ((*info->callbacks->reloc_dangerous)
-                     (info, "missing IHCONST reloc", input_bfd,
-                      input_section, rel->r_vaddr - input_section->vma)))
-                return FALSE;
-              hihalf = FALSE;
-            }
-        }
-
-      overflow = FALSE;
-
-      switch (rel->r_type)
-        {
-        default:
-          bfd_set_error (bfd_error_bad_value);
-          return FALSE;
-
-        case R_IREL:
-          insn = bfd_get_32 (input_bfd, loc);
-
-          /* Extract the addend.  */
-          signed_value = EXTRACT_JUMPTARG (insn);
-          signed_value = SIGN_EXTEND_JUMPTARG (signed_value);
-          signed_value <<= 2;
-
-          /* Determine the destination of the jump.  */
-          signed_value += val;
-
-	  /* Make the destination PC relative.  */
-	  signed_value -= (input_section->output_section->vma
-			   + input_section->output_offset
-			   + (rel->r_vaddr - input_section->vma));
-	  if (signed_value > 0x7ffffff || signed_value < - 0x8000000)
-	    {
-	      overflow = TRUE;
-	      signed_value = 0;
-	    }
-
-          /* Put the adjusted value back into the instruction.  */
-          signed_value >>= 2;
-          insn = INSERT_JUMPTARG(insn, signed_value);
-
-          bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
-          break;
-
-        case R_ILOHALF:
-          insn = bfd_get_32 (input_bfd, loc);
-          unsigned_value = EXTRACT_HWORD (insn);
-          unsigned_value += val;
-          insn = INSERT_HWORD (insn, unsigned_value);
-          bfd_put_32 (input_bfd, insn, loc);
-          break;
-
-        case R_IHIHALF:
-          /* Save the value for the R_IHCONST reloc.  */
-          hihalf = TRUE;
-          hihalf_val = val;
-          break;
-
-        case R_IHCONST:
-          if (! hihalf)
-            {
-              if (! ((*info->callbacks->reloc_dangerous)
-                     (info, "missing IHIHALF reloc", input_bfd,
-                      input_section, rel->r_vaddr - input_section->vma)))
-                return FALSE;
-              hihalf_val = 0;
-            }
-
-          insn = bfd_get_32 (input_bfd, loc);
-          unsigned_value = rel->r_symndx + hihalf_val;
-          unsigned_value >>= 16;
-          insn = INSERT_HWORD (insn, unsigned_value);
-          bfd_put_32 (input_bfd, (bfd_vma) insn, loc);
-
-          hihalf = FALSE;
-          break;
-
-        case R_BYTE:
-        case R_HWORD:
-        case R_WORD:
-          rstat = _bfd_relocate_contents (howto_table + rel->r_type,
-                                          input_bfd, val, loc);
-          if (rstat == bfd_reloc_overflow)
-            overflow = TRUE;
-          else if (rstat != bfd_reloc_ok)
-            abort ();
-          break;
-        }
-
-      if (overflow)
-        {
-          const char *name;
-          char buf[SYMNMLEN + 1];
-
-          if (symndx == -1)
-            name = "*ABS*";
-          else if (h != NULL)
-            name = NULL;
-          else if (sym == NULL)
-            name = "*unknown*";
-          else if (sym->_n._n_n._n_zeroes == 0
-                   && sym->_n._n_n._n_offset != 0)
-            name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
-          else
-            {
-              strncpy (buf, sym->_n._n_name, SYMNMLEN);
-              buf[SYMNMLEN] = '\0';
-              name = buf;
-            }
-
-          if (! ((*info->callbacks->reloc_overflow)
-                 (info, (h ? &h->root : NULL), name,
-		  howto_table[rel->r_type].name, (bfd_vma) 0, input_bfd,
-		  input_section, rel->r_vaddr - input_section->vma)))
-            return FALSE;
-        }
-    }
-
-  return TRUE;
-}
-
-#define coff_relocate_section coff_or32_relocate_section
-
-/* We don't want to change the symndx of a R_IHCONST reloc, since it
-   is actually an addend, not a symbol index at all.  */
-
-static bfd_boolean
-coff_or32_adjust_symndx (bfd *obfd ATTRIBUTE_UNUSED,
-			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
-			 bfd *ibfd ATTRIBUTE_UNUSED,
-			 asection *sec ATTRIBUTE_UNUSED,
-			 struct internal_reloc *irel,
-			 bfd_boolean *adjustedp)
-{
-  if (irel->r_type == R_IHCONST)
-    *adjustedp = TRUE;
-  else
-    *adjustedp = FALSE;
-  return TRUE;
-}
-
-#define coff_adjust_symndx coff_or32_adjust_symndx
-
-#ifndef bfd_pe_print_pdata
-#define bfd_pe_print_pdata	NULL
-#endif
-
-#include "coffcode.h"
-
-const bfd_target or32coff_big_vec =
-{
-  "coff-or32-big",  /* Name.  */
-  bfd_target_coff_flavour,
-  BFD_ENDIAN_BIG,   /* Data byte order is big.  */
-  BFD_ENDIAN_BIG,   /* Header byte order is big.  */
-
-  (HAS_RELOC  | EXEC_P |    /* Object flags.  */
-   HAS_LINENO | HAS_DEBUG |
-   HAS_SYMS   | HAS_LOCALS | WP_TEXT),
-
-  (SEC_HAS_CONTENTS | SEC_ALLOC | /* Section flags.  */
-   SEC_LOAD | SEC_RELOC |
-   SEC_READONLY ),
-  '_',        /* Leading underscore.  */
-  '/',        /* ar_pad_char.  */
-  15,         /* ar_max_namelen.  */
-  0,          /* match priority.  */
-
-  /* Data.  */
-  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
-  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
-  bfd_getb16, bfd_getb_signed_16, bfd_putb16,
-
-  /* Headers.  */
-  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
-  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
-  bfd_getb16, bfd_getb_signed_16, bfd_putb16,
-
-  {
-    _bfd_dummy_target,
-    coff_object_p,
-    bfd_generic_archive_p,
-    _bfd_dummy_target
-  },
-  {
-    bfd_false,
-    coff_mkobject,
-    _bfd_generic_mkarchive,
-    bfd_false
-  },
-  {
-    bfd_false,
-    coff_write_object_contents,
-    _bfd_write_archive_contents,
-    bfd_false
-  },
-
-  BFD_JUMP_TABLE_GENERIC (coff),
-  BFD_JUMP_TABLE_COPY (coff),
-  BFD_JUMP_TABLE_CORE (_bfd_nocore),
-  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
-  BFD_JUMP_TABLE_SYMBOLS (coff),
-  BFD_JUMP_TABLE_RELOCS (coff),
-  BFD_JUMP_TABLE_WRITE (coff),
-  BFD_JUMP_TABLE_LINK (coff),
-  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),
-
- /* Alternative_target.  */
-#ifdef TARGET_LITTLE_SYM
-  & TARGET_LITTLE_SYM,
-#else
-  NULL,
-#endif
-
-  COFF_SWAP_TABLE
-};
--- a/bfd/coffcode.h
+++ b/bfd/coffcode.h
@@ -2092,12 +2092,6 @@
   machine = 0;
   switch (internal_f->f_magic)
     {
-#ifdef OR32_MAGIC_BIG
-    case OR32_MAGIC_BIG:
-    case OR32_MAGIC_LITTLE:
-      arch = bfd_arch_or32;
-      break;
-#endif
 #ifdef PPCMAGIC
     case PPCMAGIC:
       arch = bfd_arch_powerpc;
@@ -3064,15 +3058,6 @@
       return TRUE;
 #endif
 
-#ifdef OR32_MAGIC_BIG
-    case bfd_arch_or32:
-      if (bfd_big_endian (abfd))
-	* magicp = OR32_MAGIC_BIG;
-      else
-	* magicp = OR32_MAGIC_LITTLE;
-      return TRUE;
-#endif
-
     default:			/* Unknown architecture.  */
       /* Fall through to "return FALSE" below, to avoid
 	 "statement never reached" errors on the one below.  */
@@ -4154,11 +4139,6 @@
     internal_a.magic = MIPS_PE_MAGIC;
 #endif
 
-#ifdef OR32
-#define __A_MAGIC_SET__
-    internal_a.magic = NMAGIC; /* Assume separate i/d.  */
-#endif
-
 #ifndef __A_MAGIC_SET__
 #include "Your aouthdr magic number is not being set!"
 #else
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -65,7 +65,7 @@
  m68*-*-rtemscoff* | \
  maxq-*-coff | \
  i960-*-rtems* | \
- or32-*-rtems* | \
+ or1k-*-rtems* | \
  m68*-*-lynxos* | \
  sparc-*-lynxos* | \
  vax-*-vms* | \
@@ -110,7 +110,7 @@
 microblaze*)	 targ_archs=bfd_microblaze_arch ;;
 mips*)		 targ_archs=bfd_mips_arch ;;
 nios2*)          targ_archs=bfd_nios2_arch ;;
-or32*)		 targ_archs=bfd_or32_arch ;;
+or1k*|or1knd*)	 targ_archs=bfd_or1k_arch ;;
 pdp11*)		 targ_archs=bfd_pdp11_arch ;;
 pj*)		 targ_archs="bfd_pj_arch bfd_i386_arch";;
 powerpc*)	 targ_archs="bfd_rs6000_arch bfd_powerpc_arch" ;;
@@ -1154,17 +1154,12 @@
     targ_selvecs=bfd_elf32_bignios2_vec
     ;;
 
-  openrisc-*-elf)
-    targ_defvec=bfd_elf32_openrisc_vec
+  or1k-*-elf | or1k-*-linux*)
+    targ_defvec=bfd_elf32_or1k_vec
     ;;
 
-  or32-*-coff)
-    targ_defvec=or32coff_big_vec
-    targ_underscore=yes
-    ;;
-
-  or32-*-elf)
-    targ_defvec=bfd_elf32_or32_big_vec
+  or1knd-*-elf | or1knd-*-linux*)
+    targ_defvec=bfd_elf32_or1k_vec
     ;;
 
   pdp11-*-*)
--- a/bfd/configure
+++ b/bfd/configure
@@ -15307,8 +15307,7 @@
 				tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradlittlemips_vec | bfd_elf32_ntradlittlemips_freebsd_vec)
 				tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
-    bfd_elf32_openrisc_vec)	tb="$tb elf32-openrisc.lo elf32.lo $elf" ;;
-    bfd_elf32_or32_big_vec)	tb="$tb elf32-or32.lo elf32.lo $elf" ;;
+    bfd_elf32_or1k_vec)         tb="$tb elf32-or1k.lo elf32.lo $elf" ;;
     bfd_elf32_pj_vec)           tb="$tb elf32-pj.lo elf32.lo $elf";;
     bfd_elf32_pjl_vec)          tb="$tb elf32-pj.lo elf32.lo $elf";;
     bfd_elf32_powerpc_vec)	tb="$tb elf32-ppc.lo elf-vxworks.lo elf32.lo $elf" ;;
@@ -15479,7 +15478,6 @@
     nlm32_i386_vec)		tb="$tb nlm32-i386.lo nlm32.lo nlm.lo" ;;
     nlm32_powerpc_vec)		tb="$tb nlm32-ppc.lo nlm32.lo nlm.lo" ;;
     nlm32_sparc_vec)		tb="$tb nlm32-sparc.lo nlm32.lo nlm.lo" ;;
-    or32coff_big_vec)		tb="$tb coff-or32.lo cofflink.lo" ;;
     pc532machaout_vec)		tb="$tb pc532-mach.lo aout-ns32k.lo" ;;
     pc532netbsd_vec)		tb="$tb ns32knetbsd.lo aout-ns32k.lo" ;;
     pef_vec)                    tb="$tb pef.lo" ;;
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -577,6 +577,11 @@
     SHARED_LDFLAGS="-no-undefined"
     SHARED_LIBADD="-L`pwd`/../libiberty -liberty -L`pwd`/../intl -lintl -lcygwin -lkernel32"
   ;;
+
+  # Hack to build or1k-src on OSX
+  *-*-darwin*)
+    SHARED_LIBADD="-L`pwd`/../libiberty/pic -L`pwd`/../intl -liberty -lintl"
+  ;;
   esac
 
   if test -n "$SHARED_LIBADD"; then
@@ -796,8 +801,7 @@
 				tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
     bfd_elf32_ntradlittlemips_vec | bfd_elf32_ntradlittlemips_freebsd_vec)
 				tb="$tb elfn32-mips.lo elfxx-mips.lo elf-vxworks.lo elf32.lo $elf ecofflink.lo"; target_size=64 ;;
-    bfd_elf32_openrisc_vec)	tb="$tb elf32-openrisc.lo elf32.lo $elf" ;;
-    bfd_elf32_or32_big_vec)	tb="$tb elf32-or32.lo elf32.lo $elf" ;;
+    bfd_elf32_or1k_vec)		tb="$tb elf32-or1k.lo elf32.lo $elf" ;;
     bfd_elf32_pj_vec)           tb="$tb elf32-pj.lo elf32.lo $elf";;
     bfd_elf32_pjl_vec)          tb="$tb elf32-pj.lo elf32.lo $elf";;
     bfd_elf32_powerpc_vec)	tb="$tb elf32-ppc.lo elf-vxworks.lo elf32.lo $elf" ;;
@@ -968,7 +972,6 @@
     nlm32_i386_vec)		tb="$tb nlm32-i386.lo nlm32.lo nlm.lo" ;;
     nlm32_powerpc_vec)		tb="$tb nlm32-ppc.lo nlm32.lo nlm.lo" ;;
     nlm32_sparc_vec)		tb="$tb nlm32-sparc.lo nlm32.lo nlm.lo" ;;
-    or32coff_big_vec)		tb="$tb coff-or32.lo cofflink.lo" ;;
     pc532machaout_vec)		tb="$tb pc532-mach.lo aout-ns32k.lo" ;;
     pc532netbsd_vec)		tb="$tb ns32knetbsd.lo aout-ns32k.lo" ;;
     pef_vec)                    tb="$tb pef.lo" ;;
--- a/bfd/cpu-openrisc.c
+++ /dev/null
@@ -1,44 +0,0 @@
-/* BFD support for the OpenRISC architecture.
-   Copyright 2001, 2002, 2005, 2007 Free Software Foundation, Inc.
-   Contributed by Johan Rydberg, jrydberg@opencores.org
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libbfd.h"
-
-#define N(BITS_WORD, BITS_ADDR, NUMBER, PRINT, DEFAULT, NEXT) \
-  {                                                           \
-    BITS_WORD,           /* bits in a word */                 \
-    BITS_ADDR,           /* bits in an address */             \
-    8,                   /* 8 bits in a byte */               \
-    bfd_arch_openrisc,                                        \
-    NUMBER,                                                   \
-    "openrisc",                                               \
-    PRINT,                                                    \
-    2,                                                        \
-    DEFAULT,                                                  \
-    bfd_default_compatible,                                   \
-    bfd_default_scan,                                         \
-    bfd_arch_default_fill,				      \
-    NEXT,                                                     \
-  }
-
-const bfd_arch_info_type bfd_openrisc_arch =
-  N (32, 32, 0, "openrisc", TRUE, 0);
--- /dev/null
+++ b/bfd/cpu-or1k.c
@@ -0,0 +1,61 @@
+/* BFD support for the OpenRISC 1000 architecture.
+   Copyright 2002, 2005, 2007 Free Software Foundation, Inc.
+   Contributed by Ivan Guzvinec  <ivang@opencores.org>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+
+const bfd_arch_info_type bfd_or1k_arch;
+const bfd_arch_info_type bfd_or1knd_arch;
+
+const bfd_arch_info_type bfd_or1k_arch =
+  {
+    32,           /* 32 bits in a word.  */
+    32,	          /* 32 bits in an address.  */
+    8,	          /* 8 bits in a byte.  */
+    bfd_arch_or1k,
+    bfd_mach_or1k,
+    "or1k",
+    "or1k",
+    4,
+    TRUE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    bfd_arch_default_fill,
+    &bfd_or1knd_arch,
+  };
+
+const bfd_arch_info_type bfd_or1knd_arch =
+  {
+    32,           /* 32 bits in a word.  */
+    32,	          /* 32 bits in an address.  */
+    8,	          /* 8 bits in a byte.  */
+    bfd_arch_or1k,
+    bfd_mach_or1knd,
+    "or1knd",
+    "or1knd",
+    4,
+    FALSE,
+    bfd_default_compatible,
+    bfd_default_scan,
+    bfd_arch_default_fill,
+    NULL,
+  };
--- a/bfd/cpu-or32.c
+++ /dev/null
@@ -1,42 +0,0 @@
-/* BFD support for the OpenRISC 1000 architecture.
-   Copyright 2002, 2005, 2007 Free Software Foundation, Inc.
-   Contributed by Ivan Guzvinec  <ivang@opencores.org>
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libbfd.h"
-
-const bfd_arch_info_type bfd_or32_arch =
-  {
-    32,           /* 32 bits in a word.  */
-    32,	          /* 32 bits in an address.  */
-    8,	          /* 8 bits in a byte.  */
-    bfd_arch_or32,
-    0,	          /* Only 1 machine.  */
-    "or32",
-    "or32",
-    4,
-    TRUE,         /* The one and only.  */
-    bfd_default_compatible,
-    bfd_default_scan,
-    bfd_arch_default_fill,
-    0,
-  };
-
--- a/bfd/elf-bfd.h
+++ b/bfd/elf-bfd.h
@@ -420,6 +420,7 @@
   MIPS_ELF_DATA,
   MN10300_ELF_DATA,
   NIOS2_ELF_DATA,
+  OR1K_ELF_DATA,
   PPC32_ELF_DATA,
   PPC64_ELF_DATA,
   S390_ELF_DATA,
--- a/bfd/elf32-openrisc.c
+++ /dev/null
@@ -1,570 +0,0 @@
-/* OpenRISC-specific support for 32-bit ELF.
-   Copyright 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010, 2012
-   Free Software Foundation, Inc.
-   Contributed by Johan Rydberg, jrydberg@opencores.org
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libbfd.h"
-#include "elf-bfd.h"
-#include "elf/openrisc.h"
-#include "libiberty.h"
-
-static reloc_howto_type openrisc_elf_howto_table[] =
-{
-  /* This reloc does nothing.  */
-  HOWTO (R_OPENRISC_NONE,	/* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 32,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_NONE",	/* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0,			/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A PC relative 26 bit relocation, right shifted by 2.  */
-  HOWTO (R_OPENRISC_INSN_REL_26, /* type */
-	 2,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 26,			/* bitsize */
-	 TRUE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_signed, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_INSN_REL_26", /* name */
-	 FALSE,			/* partial_inplace */
-	 0x00000000,		/* src_mask */
-	 0x03ffffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A absolute 26 bit relocation, right shifted by 2.  */
-  HOWTO (R_OPENRISC_INSN_ABS_26, /* type */
-	 2,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 26,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_signed, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_INSN_ABS_26", /* name */
-	 FALSE,			/* partial_inplace */
-	 0x00000000,		/* src_mask */
-	 0x03ffffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  HOWTO (R_OPENRISC_LO_16_IN_INSN, /* type */
-	 0,			/* rightshift */
-	 1,			/* size (0 = byte, 1 = short, 2 = long) */
-	 16,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_LO_16_IN_INSN", /* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0x0000ffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  HOWTO (R_OPENRISC_HI_16_IN_INSN, /* type */
-	 16,			/* rightshift */
-	 1,			/* size (0 = byte, 1 = short, 2 = long) */
-	 16,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont,	/* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_HI_16_IN_INSN",	/* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0x0000ffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* An 8 bit absolute relocation.  */
-  HOWTO (R_OPENRISC_8,		/* type */
-	 0,			/* rightshift */
-	 0,			/* size (0 = byte, 1 = short, 2 = long) */
-	 8,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_8",	/* name */
-	 TRUE,			/* partial_inplace */
-	 0x0000,		/* src_mask */
-	 0x00ff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A 16 bit absolute relocation.  */
-  HOWTO (R_OPENRISC_16,		/* type */
-	 0,			/* rightshift */
-	 1,			/* size (0 = byte, 1 = short, 2 = long) */
-	 16,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_16",	/* name */
-	 TRUE,			/* partial_inplace */
-	 0x00000000,		/* src_mask */
-	 0x0000ffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A 32 bit absolute relocation.  */
-  HOWTO (R_OPENRISC_32,		/* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 32,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OPENRISC_32",	/* name */
-	 TRUE,			/* partial_inplace */
-	 0x00000000,		/* src_mask */
-	 0xffffffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* GNU extension to record C++ vtable hierarchy.  */
-  HOWTO (R_OPENRISC_GNU_VTINHERIT, /* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 0,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont, /* complain_on_overflow */
-	 NULL,			/* special_function */
-	 "R_OPENRISC_GNU_VTINHERIT", /* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0,			/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* GNU extension to record C++ vtable member usage.  */
-  HOWTO (R_OPENRISC_GNU_VTENTRY, /* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 0,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont, /* complain_on_overflow */
-	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
-	 "R_OPENRISC_GNU_VTENTRY", /* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0,			/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-};
-
-/* Map BFD reloc types to OpenRISC ELF reloc types.  */
-
-struct openrisc_reloc_map
-{
-  bfd_reloc_code_real_type bfd_reloc_val;
-  unsigned int openrisc_reloc_val;
-};
-
-static const struct openrisc_reloc_map openrisc_reloc_map[] =
-{
-  { BFD_RELOC_NONE, 		R_OPENRISC_NONE },
-  { BFD_RELOC_32, 		R_OPENRISC_32 },
-  { BFD_RELOC_16, 		R_OPENRISC_16 },
-  { BFD_RELOC_8, 		R_OPENRISC_8 },
-  { BFD_RELOC_OPENRISC_REL_26,	R_OPENRISC_INSN_REL_26 },
-  { BFD_RELOC_OPENRISC_ABS_26,	R_OPENRISC_INSN_ABS_26 },
-  { BFD_RELOC_HI16, 		R_OPENRISC_HI_16_IN_INSN },
-  { BFD_RELOC_LO16, 		R_OPENRISC_LO_16_IN_INSN },
-  { BFD_RELOC_VTABLE_INHERIT,	R_OPENRISC_GNU_VTINHERIT },
-  { BFD_RELOC_VTABLE_ENTRY, 	R_OPENRISC_GNU_VTENTRY }
-};
-
-static reloc_howto_type *
-openrisc_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
-			    bfd_reloc_code_real_type code)
-{
-  unsigned int i;
-
-  for (i = ARRAY_SIZE (openrisc_reloc_map); --i;)
-    if (openrisc_reloc_map[i].bfd_reloc_val == code)
-      return & openrisc_elf_howto_table[openrisc_reloc_map[i].
-				       openrisc_reloc_val];
-
-  return NULL;
-}
-
-static reloc_howto_type *
-openrisc_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
-			    const char *r_name)
-{
-  unsigned int i;
-
-  for (i = 0;
-       i < (sizeof (openrisc_elf_howto_table)
-	    / sizeof (openrisc_elf_howto_table[0]));
-       i++)
-    if (openrisc_elf_howto_table[i].name != NULL
-	&& strcasecmp (openrisc_elf_howto_table[i].name, r_name) == 0)
-      return &openrisc_elf_howto_table[i];
-
-  return NULL;
-}
-
-/* Set the howto pointer for an OpenRISC ELF reloc.  */
-
-static void
-openrisc_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
-			     arelent * cache_ptr,
-			     Elf_Internal_Rela * dst)
-{
-  unsigned int r_type;
-
-  r_type = ELF32_R_TYPE (dst->r_info);
-  BFD_ASSERT (r_type < (unsigned int) R_OPENRISC_max);
-  cache_ptr->howto = & openrisc_elf_howto_table[r_type];
-}
-
-/* Perform a single relocation.  By default we use the standard BFD
-   routines, but a few relocs, we have to do them ourselves.  */
-
-static bfd_reloc_status_type
-openrisc_final_link_relocate (reloc_howto_type *howto,
-			      bfd *input_bfd,
-			      asection *input_section,
-			      bfd_byte *contents,
-			      Elf_Internal_Rela *rel,
-			      bfd_vma relocation)
-{
-  bfd_reloc_status_type r = bfd_reloc_ok;
-
-  switch (howto->type)
-    {
-    case R_OPENRISC_LO_16_IN_INSN:
-      relocation &= 0xffff;
-      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
-				    contents, rel->r_offset,
-				    relocation, rel->r_addend);
-      break;
-
-    default:
-      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
-				    contents, rel->r_offset,
-				    relocation, rel->r_addend);
-    }
-
-  return r;
-}
-
-/* Relocate an OpenRISC ELF section.
-
-   The RELOCATE_SECTION function is called by the new ELF backend linker
-   to handle the relocations for a section.
-
-   The relocs are always passed as Rela structures; if the section
-   actually uses Rel structures, the r_addend field will always be
-   zero.
-
-   This function is responsible for adjusting the section contents as
-   necessary, and (if using Rela relocs and generating a relocatable
-   output file) adjusting the reloc addend as necessary.
-
-   This function does not have to worry about setting the reloc
-   address or the reloc symbol index.
-
-   LOCAL_SYMS is a pointer to the swapped in local symbols.
-
-   LOCAL_SECTIONS is an array giving the section in the input file
-   corresponding to the st_shndx field of each local symbol.
-
-   The global hash table entry for the global symbols can be found
-   via elf_sym_hashes (input_bfd).
-
-   When generating relocatable output, this function must handle
-   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
-   going to be the section symbol corresponding to the output
-   section, which means that the addend must be adjusted
-   accordingly.  */
-
-static bfd_boolean
-openrisc_elf_relocate_section (bfd *output_bfd,
-			       struct bfd_link_info *info,
-			       bfd *input_bfd,
-			       asection *input_section,
-			       bfd_byte *contents,
-			       Elf_Internal_Rela *relocs,
-			       Elf_Internal_Sym *local_syms,
-			       asection **local_sections)
-{
-  Elf_Internal_Shdr *symtab_hdr;
-  struct elf_link_hash_entry **sym_hashes;
-  Elf_Internal_Rela *rel;
-  Elf_Internal_Rela *relend;
-
-  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
-  sym_hashes = elf_sym_hashes (input_bfd);
-  relend = relocs + input_section->reloc_count;
-
-  for (rel = relocs; rel < relend; rel++)
-    {
-      reloc_howto_type *howto;
-      unsigned long r_symndx;
-      Elf_Internal_Sym *sym;
-      asection *sec;
-      struct elf_link_hash_entry *h;
-      bfd_vma relocation;
-      bfd_reloc_status_type r;
-      const char *name = NULL;
-      int r_type;
-
-      r_type = ELF32_R_TYPE (rel->r_info);
-      r_symndx = ELF32_R_SYM (rel->r_info);
-
-      if (r_type == R_OPENRISC_GNU_VTINHERIT
-	  || r_type == R_OPENRISC_GNU_VTENTRY)
-	continue;
-
-      if ((unsigned int) r_type >
-	  (sizeof openrisc_elf_howto_table / sizeof (reloc_howto_type)))
-	abort ();
-
-      howto = openrisc_elf_howto_table + ELF32_R_TYPE (rel->r_info);
-      h = NULL;
-      sym = NULL;
-      sec = NULL;
-
-      if (r_symndx < symtab_hdr->sh_info)
-	{
-	  sym = local_syms + r_symndx;
-	  sec = local_sections[r_symndx];
-	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
-
-	  name = bfd_elf_string_from_elf_section
-	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
-	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
-	}
-      else
-	{
-	  bfd_boolean unresolved_reloc, warned;
-
-	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
-				   r_symndx, symtab_hdr, sym_hashes,
-				   h, sec, relocation,
-				   unresolved_reloc, warned);
-	}
-
-      if (sec != NULL && discarded_section (sec))
-	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
-					 rel, 1, relend, howto, 0, contents);
-
-      if (info->relocatable)
-	continue;
-
-      r = openrisc_final_link_relocate (howto, input_bfd, input_section,
-					contents, rel, relocation);
-
-      if (r != bfd_reloc_ok)
-	{
-	  const char *msg = NULL;
-
-	  switch (r)
-	    {
-	    case bfd_reloc_overflow:
-	      r = info->callbacks->reloc_overflow
-		(info, (h ? &h->root : NULL), name, howto->name,
-		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
-	      break;
-
-	    case bfd_reloc_undefined:
-	      r = info->callbacks->undefined_symbol
-		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
-	      break;
-
-	    case bfd_reloc_outofrange:
-	      msg = _("internal error: out of range error");
-	      break;
-
-	    case bfd_reloc_notsupported:
-	      msg = _("internal error: unsupported relocation error");
-	      break;
-
-	    case bfd_reloc_dangerous:
-	      msg = _("internal error: dangerous relocation");
-	      break;
-
-	    default:
-	      msg = _("internal error: unknown error");
-	      break;
-	    }
-
-	  if (msg)
-	    r = info->callbacks->warning
-	      (info, msg, name, input_bfd, input_section, rel->r_offset);
-
-	  if (!r)
-	    return FALSE;
-	}
-    }
-
-  return TRUE;
-}
-
-/* Return the section that should be marked against GC for a given
-   relocation.  */
-
-static asection *
-openrisc_elf_gc_mark_hook (asection *sec,
-			   struct bfd_link_info *info,
-			   Elf_Internal_Rela *rel,
-			   struct elf_link_hash_entry *h,
-			   Elf_Internal_Sym *sym)
-{
-  if (h != NULL)
-    switch (ELF32_R_TYPE (rel->r_info))
-      {
-      case R_OPENRISC_GNU_VTINHERIT:
-      case R_OPENRISC_GNU_VTENTRY:
-	return NULL;
-      }
-
-  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
-}
-
-/* Look through the relocs for a section during the first phase.
-   Since we don't do .gots or .plts, we just need to consider the
-   virtual table relocs for gc.  */
-
-static bfd_boolean
-openrisc_elf_check_relocs (bfd *abfd,
-			   struct bfd_link_info *info,
-			   asection *sec,
-			   const Elf_Internal_Rela *relocs)
-{
-  Elf_Internal_Shdr *symtab_hdr;
-  struct elf_link_hash_entry **sym_hashes;
-  const Elf_Internal_Rela *rel;
-  const Elf_Internal_Rela *rel_end;
-
-  if (info->relocatable)
-    return TRUE;
-
-  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
-  sym_hashes = elf_sym_hashes (abfd);
-
-  rel_end = relocs + sec->reloc_count;
-  for (rel = relocs; rel < rel_end; rel++)
-    {
-      struct elf_link_hash_entry *h;
-      unsigned long r_symndx;
-
-      r_symndx = ELF32_R_SYM (rel->r_info);
-      if (r_symndx < symtab_hdr->sh_info)
-	h = NULL;
-      else
-	{
-	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
-	  while (h->root.type == bfd_link_hash_indirect
-		 || h->root.type == bfd_link_hash_warning)
-	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
-
-	  /* PR15323, ref flags aren't set for references in the same
-	     object.  */
-	  h->root.non_ir_ref = 1;
-	}
-
-      switch (ELF32_R_TYPE (rel->r_info))
-	{
-	  /* This relocation describes the C++ object vtable hierarchy.
-	     Reconstruct it for later use during GC.  */
-	case R_OPENRISC_GNU_VTINHERIT:
-	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
-	    return FALSE;
-	  break;
-
-	  /* This relocation describes which C++ vtable entries are actually
-	     used.  Record for later use during GC.  */
-	case R_OPENRISC_GNU_VTENTRY:
-	  BFD_ASSERT (h != NULL);
-	  if (h != NULL
-	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
-	    return FALSE;
-	  break;
-	}
-    }
-
-  return TRUE;
-}
-
-/* Set the right machine number.  */
-
-static bfd_boolean
-openrisc_elf_object_p (bfd *abfd)
-{
-  bfd_default_set_arch_mach (abfd, bfd_arch_openrisc, 0);
-  return TRUE;
-}
-
-/* Store the machine number in the flags field.  */
-
-static void
-openrisc_elf_final_write_processing (bfd *abfd,
-				     bfd_boolean linker ATTRIBUTE_UNUSED)
-{
-  unsigned long val;
-
-  switch (bfd_get_mach (abfd))
-    {
-    default:
-      val = 0;
-      break;
-    }
-
-  elf_elfheader (abfd)->e_flags &= ~0xf;
-  elf_elfheader (abfd)->e_flags |= val;
-}
-
-
-#define ELF_ARCH			bfd_arch_openrisc
-#define ELF_MACHINE_CODE		EM_OPENRISC
-#define ELF_MACHINE_ALT1		EM_OPENRISC_OLD
-#define ELF_MAXPAGESIZE			0x1000
-
-#define TARGET_BIG_SYM			bfd_elf32_openrisc_vec
-#define TARGET_BIG_NAME			"elf32-openrisc"
-
-#define elf_info_to_howto_rel		NULL
-#define elf_info_to_howto		openrisc_info_to_howto_rela
-#define elf_backend_relocate_section	openrisc_elf_relocate_section
-#define elf_backend_gc_mark_hook	openrisc_elf_gc_mark_hook
-#define elf_backend_check_relocs	openrisc_elf_check_relocs
-
-#define elf_backend_can_gc_sections	1
-#define elf_backend_rela_normal		1
-
-#define bfd_elf32_bfd_reloc_type_lookup openrisc_reloc_type_lookup
-#define bfd_elf32_bfd_reloc_name_lookup openrisc_reloc_name_lookup
-
-#define elf_backend_object_p                openrisc_elf_object_p
-#define elf_backend_final_write_processing  openrisc_elf_final_write_processing
-
-#include "elf32-target.h"
--- /dev/null
+++ b/bfd/elf32-or1k.c
@@ -0,0 +1,2886 @@
+/* Or1k-specific support for 32-bit ELF.
+   Copyright 2001-2013
+   Free Software Foundation, Inc.
+   Contributed by Johan Rydberg, jrydberg@opencores.org
+
+   PIC parts added by Stefan Kristiansson, stefan.kristiansson@saunalahti.fi,
+   largely based on elf32-m32r.c and elf32-microblaze.c.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+#include "sysdep.h"
+#include "bfd.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/or1k.h"
+#include "libiberty.h"
+
+#define PLT_ENTRY_SIZE 20
+
+#define PLT0_ENTRY_WORD0 0x19800000 /* l.movhi r12, 0 <- hi(.got+4) */
+#define PLT0_ENTRY_WORD1 0xa98c0000 /* l.ori r12, r12, 0 <- lo(.got+4) */
+#define PLT0_ENTRY_WORD2 0x85ec0004 /* l.lwz r15, 4(r12) <- *(.got+8)*/
+#define PLT0_ENTRY_WORD3 0x44007800 /* l.jr r15 */
+#define PLT0_ENTRY_WORD4 0x858c0000 /* l.lwz r12, 0(r12) */
+
+#define PLT0_PIC_ENTRY_WORD0 0x85900004 /* l.lwz r12, 4(r16) */
+#define PLT0_PIC_ENTRY_WORD1 0x85f00008 /* l.lwz r15, 8(r16) */
+#define PLT0_PIC_ENTRY_WORD2 0x44007800 /* l.jr r15 */
+#define PLT0_PIC_ENTRY_WORD3 0x15000000 /* l.nop */
+#define PLT0_PIC_ENTRY_WORD4 0x15000000 /* l.nop */
+
+#define PLT_ENTRY_WORD0 0x19800000 /* l.movhi r12, 0 <- hi(got idx addr) */
+#define PLT_ENTRY_WORD1 0xa98c0000 /* l.ori r12, r12, 0 <- lo(got idx addr) */
+#define PLT_ENTRY_WORD2 0x858c0000 /* l.lwz r12, 0(r12) */
+#define PLT_ENTRY_WORD3 0x44006000 /* l.jr r12 */
+#define PLT_ENTRY_WORD4 0xa9600000 /* l.ori r11, r0, 0 <- reloc offset */
+
+#define PLT_PIC_ENTRY_WORD0 0x85900000 /* l.lwz r12, 0(r16) <- index in got */
+#define PLT_PIC_ENTRY_WORD1 0xa9600000 /* l.ori r11, r0, 0 <- reloc offset */
+#define PLT_PIC_ENTRY_WORD2 0x44006000 /* l.jr r12 */
+#define PLT_PIC_ENTRY_WORD3 0x15000000 /* l.nop */
+#define PLT_PIC_ENTRY_WORD4 0x15000000 /* l.nop */
+
+#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
+
+static reloc_howto_type or1k_elf_howto_table[] =
+{
+  /* This reloc does nothing.  */
+  HOWTO (R_OR1K_NONE,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_NONE",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  HOWTO (R_OR1K_32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_32",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  HOWTO (R_OR1K_16,
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_16",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  HOWTO (R_OR1K_8,
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_unsigned, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_8",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  HOWTO (R_OR1K_LO_16_IN_INSN, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_LO_16_IN_INSN", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_HI_16_IN_INSN, /* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_HI_16_IN_INSN", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  /* A PC relative 26 bit relocation, right shifted by 2.  */
+  HOWTO (R_OR1K_INSN_REL_26, /* type */
+	 2,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 26,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_INSN_REL_26", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x03ffffff,		/* dst_mask */
+	 TRUE),			/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable hierarchy.  */
+  HOWTO (R_OR1K_GNU_VTINHERIT, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 NULL,			/* special_function */
+	 "R_OR1K_GNU_VTINHERIT", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* GNU extension to record C++ vtable member usage.  */
+  HOWTO (R_OR1K_GNU_VTENTRY, /* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 0,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
+	 "R_OR1K_GNU_VTENTRY", /* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_32_PCREL,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_32_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_16_PCREL,
+	 0,			/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_16_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+  
+  HOWTO (R_OR1K_8_PCREL,
+	 0,			/* rightshift */
+	 0,			/* size (0 = byte, 1 = short, 2 = long) */
+	 8,			/* bitsize */
+	 TRUE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_8_PCREL",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+   HOWTO (R_OR1K_GOTPC_HI16,   	/* Type.  */
+	 16,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 TRUE,			/* PC_relative.  */
+	 0,			/* Bitpos.  */
+	 complain_overflow_dont, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc,	/* Special Function.  */
+	 "R_OR1K_GOTPC_HI16", 	/* Name.  */
+	 FALSE,		/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0xffff,		/* Dest Mask.  */
+	 TRUE), 		/* PC relative offset?  */
+
+   HOWTO (R_OR1K_GOTPC_LO16,   	/* Type.  */
+	 0,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 16,			/* Bitsize.  */
+	 TRUE,			/* PC_relative.  */
+	 0,			/* Bitpos.  */
+	 complain_overflow_dont, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc,	/* Special Function.  */
+	 "R_OR1K_GOTPC_LO16", 	/* Name.  */
+	 FALSE,		/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0xffff,		/* Dest Mask.  */
+	 TRUE), 		/* PC relative offset?  */
+
+  HOWTO (R_OR1K_GOT16,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_signed, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_GOT16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* A 26 bit PLT relocation.  Shifted by 2.  */
+  HOWTO (R_OR1K_PLT26,  /* Type.  */
+	 2,			/* Rightshift.  */
+	 2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+	 26,			/* Bitsize.  */
+	 TRUE,			/* PC_relative.  */
+	 0,			/* Bitpos.  */
+	 complain_overflow_dont, /* Complain on overflow.  */
+	 bfd_elf_generic_reloc,/* Special Function.  */
+	 "R_OR1K_PLT26",	/* Name.  */
+	 FALSE,		/* Partial Inplace.  */
+	 0,			/* Source Mask.  */
+	 0x03ffffff,		/* Dest Mask.  */
+	 TRUE), 		/* PC relative offset?  */
+
+  HOWTO (R_OR1K_GOTOFF_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_GOTOFF_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_GOTOFF_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_GOTOFF_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_COPY,		/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_OR1K_COPY",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_GLOB_DAT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_OR1K_GLOB_DAT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_JMP_SLOT,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_OR1K_JMP_SLOT",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_RELATIVE,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_OR1K_RELATIVE",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0xffffffff,		/* src_mask */
+	 0xffffffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_GD_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_GD_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_GD_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_GD_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LDM_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LDM_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LDM_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LDM_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LDO_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LDO_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LDO_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LDO_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_IE_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_IE_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_IE_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_IE_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LE_HI16,	/* type */
+	 16,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LE_HI16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_OR1K_TLS_LE_LO16,	/* type */
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_OR1K_TLS_LE_LO16",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0x0,			/* src_mask */
+	 0xffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+};
+
+/* Map BFD reloc types to Or1k ELF reloc types.  */
+
+struct or1k_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned int or1k_reloc_val;
+};
+
+static const struct or1k_reloc_map or1k_reloc_map[] =
+{
+  { BFD_RELOC_NONE, 		R_OR1K_NONE },
+  { BFD_RELOC_32, 		R_OR1K_32 },
+  { BFD_RELOC_16, 		R_OR1K_16 },
+  { BFD_RELOC_8, 		R_OR1K_8 },
+  { BFD_RELOC_LO16, 		R_OR1K_LO_16_IN_INSN },
+  { BFD_RELOC_HI16, 		R_OR1K_HI_16_IN_INSN },
+  { BFD_RELOC_OR1K_REL_26,	R_OR1K_INSN_REL_26 },
+  { BFD_RELOC_VTABLE_ENTRY, 	R_OR1K_GNU_VTENTRY },
+  { BFD_RELOC_VTABLE_INHERIT,	R_OR1K_GNU_VTINHERIT },
+  { BFD_RELOC_32_PCREL,		R_OR1K_32_PCREL },
+  { BFD_RELOC_16_PCREL,		R_OR1K_16_PCREL },
+  { BFD_RELOC_8_PCREL,		R_OR1K_8_PCREL },
+  { BFD_RELOC_OR1K_GOTPC_HI16,	R_OR1K_GOTPC_HI16 },
+  { BFD_RELOC_OR1K_GOTPC_LO16,	R_OR1K_GOTPC_LO16 },
+  { BFD_RELOC_OR1K_GOT16,	R_OR1K_GOT16 },
+  { BFD_RELOC_OR1K_PLT26,	R_OR1K_PLT26 },
+  { BFD_RELOC_OR1K_GOTOFF_HI16,	R_OR1K_GOTOFF_HI16 },
+  { BFD_RELOC_OR1K_GOTOFF_LO16,	R_OR1K_GOTOFF_LO16 },
+  { BFD_RELOC_OR1K_GLOB_DAT,	R_OR1K_GLOB_DAT },
+  { BFD_RELOC_OR1K_COPY,	R_OR1K_COPY },
+  { BFD_RELOC_OR1K_JMP_SLOT,	R_OR1K_JMP_SLOT },
+  { BFD_RELOC_OR1K_RELATIVE,	R_OR1K_RELATIVE },
+  { BFD_RELOC_OR1K_TLS_GD_HI16,	R_OR1K_TLS_GD_HI16 },
+  { BFD_RELOC_OR1K_TLS_GD_LO16,	R_OR1K_TLS_GD_LO16 },
+  { BFD_RELOC_OR1K_TLS_LDM_HI16,	R_OR1K_TLS_LDM_HI16 },
+  { BFD_RELOC_OR1K_TLS_LDM_LO16,	R_OR1K_TLS_LDM_LO16 },
+  { BFD_RELOC_OR1K_TLS_LDO_HI16,	R_OR1K_TLS_LDO_HI16 },
+  { BFD_RELOC_OR1K_TLS_LDO_LO16,	R_OR1K_TLS_LDO_LO16 },
+  { BFD_RELOC_OR1K_TLS_IE_HI16,	R_OR1K_TLS_IE_HI16 },
+  { BFD_RELOC_OR1K_TLS_IE_LO16,	R_OR1K_TLS_IE_LO16 },
+  { BFD_RELOC_OR1K_TLS_LE_HI16,	R_OR1K_TLS_LE_HI16 },
+  { BFD_RELOC_OR1K_TLS_LE_LO16,	R_OR1K_TLS_LE_LO16 },
+};
+
+/* The linker needs to keep track of the number of relocs that it
+   decides to copy as dynamic relocs in check_relocs for each symbol.
+   This is so that it can later discard them if they are found to be
+   unnecessary.  We store the information in a field extending the
+   regular ELF linker hash table.  */
+
+struct elf_or1k_dyn_relocs
+{
+  struct elf_or1k_dyn_relocs *next;
+
+  /* The input section of the reloc.  */
+  asection *sec;
+
+  /* Total number of relocs copied for the input section.  */
+  bfd_size_type count;
+
+  /* Number of pc-relative relocs copied for the input section.  */
+  bfd_size_type pc_count;
+};
+
+#define TLS_UNKNOWN    0
+#define TLS_NONE       1
+#define TLS_GD	       2
+#define TLS_LD	       3
+#define TLS_IE	       4
+#define TLS_LE	       5
+
+/* ELF linker hash entry.  */
+
+struct elf_or1k_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Track dynamic relocs copied for this symbol.  */
+  struct elf_or1k_dyn_relocs *dyn_relocs;
+
+  /* Track type of TLS access */
+  unsigned char tls_type;
+};
+
+/* ELF object data */
+struct elf_or1k_obj_tdata
+{
+  struct elf_obj_tdata root;
+
+  /* tls_type for each local got entry.  */
+  unsigned char *local_tls_type;
+};
+
+#define elf_or1k_tdata(abfd) \
+  ((struct elf_or1k_obj_tdata *) (abfd)->tdata.any)
+
+#define elf_or1k_local_tls_type(abfd) \
+  (elf_or1k_tdata (abfd)->local_tls_type)
+
+/* ELF linker hash table.  */
+
+struct elf_or1k_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Short-cuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *sgotplt;
+  asection *srelgot;
+  asection *splt;
+  asection *srelplt;
+  asection *sdynbss;
+  asection *srelbss;
+
+  /* Small local sym to section mapping cache.  */
+  struct sym_cache sym_sec;
+};
+
+/* Get the ELF linker hash table from a link_info structure.  */
+
+#define or1k_elf_hash_table(p) \
+  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
+   == OR1K_ELF_DATA ? ((struct elf_or1k_link_hash_table *) ((p)->hash)) : NULL)
+
+static bfd_boolean
+elf_or1k_mkobject (bfd *abfd)
+{
+  return bfd_elf_allocate_object (abfd, sizeof (struct elf_or1k_obj_tdata),
+				  OR1K_ELF_DATA);
+}
+
+/* Create an entry in an or1k ELF linker hash table.  */
+
+static struct bfd_hash_entry *
+or1k_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
+                            struct bfd_hash_table *table,
+                            const char *string)
+{
+  struct elf_or1k_link_hash_entry *ret =
+    (struct elf_or1k_link_hash_entry *) entry;
+
+  /* Allocate the structure if it has not already been allocated by a
+     subclass.  */
+  if (ret == NULL)
+    ret = bfd_hash_allocate (table,
+                             sizeof (struct elf_or1k_link_hash_entry));
+  if (ret == NULL)
+    return NULL;
+
+  /* Call the allocation method of the superclass.  */
+  ret = ((struct elf_or1k_link_hash_entry *)
+         _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
+                                     table, string));
+  if (ret != NULL)
+    {
+      struct elf_or1k_link_hash_entry *eh;
+
+      eh = (struct elf_or1k_link_hash_entry *) ret;
+      eh->dyn_relocs = NULL;
+      eh->tls_type = TLS_UNKNOWN;
+    }
+
+  return (struct bfd_hash_entry *) ret;
+}
+
+/* Create an or1k ELF linker hash table.  */
+
+static struct bfd_link_hash_table *
+or1k_elf_link_hash_table_create (bfd *abfd)
+{
+  struct elf_or1k_link_hash_table *ret;
+  bfd_size_type amt = sizeof (struct elf_or1k_link_hash_table);
+
+  ret = bfd_zmalloc (amt);
+  if (ret == NULL)
+    return NULL;
+
+  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
+				      or1k_elf_link_hash_newfunc,
+				      sizeof (struct elf_or1k_link_hash_entry),
+				      OR1K_ELF_DATA))
+    {
+      free (ret);
+      return NULL;
+    }
+
+  return &ret->root.root;
+}
+
+static reloc_howto_type *
+or1k_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
+			    bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = ARRAY_SIZE (or1k_reloc_map); --i;)
+    if (or1k_reloc_map[i].bfd_reloc_val == code)
+      return & or1k_elf_howto_table[or1k_reloc_map[i].
+				       or1k_reloc_val];
+
+  return NULL;
+}
+
+static reloc_howto_type *
+or1k_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+			    const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < (sizeof (or1k_elf_howto_table)
+	    / sizeof (or1k_elf_howto_table[0]));
+       i++)
+    if (or1k_elf_howto_table[i].name != NULL
+	&& strcasecmp (or1k_elf_howto_table[i].name, r_name) == 0)
+      return &or1k_elf_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an Or1k ELF reloc.  */
+
+static void
+or1k_info_to_howto_rela (bfd * abfd ATTRIBUTE_UNUSED,
+			     arelent * cache_ptr,
+			     Elf_Internal_Rela * dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_OR1K_max);
+  cache_ptr->howto = & or1k_elf_howto_table[r_type];
+}
+
+
+/* Return the relocation value for @tpoff relocations..  */
+static bfd_vma
+tpoff (struct bfd_link_info *info, bfd_vma address)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+
+  /* The thread pointer on or1k stores the address after the TCB where 
+   * the data is, just compute the difference. No need to compensate
+   * for the size of TCB. */
+  return (address - elf_hash_table (info)->tls_sec->vma);
+}
+
+/* Relocate an Or1k ELF section.
+
+   The RELOCATE_SECTION function is called by the new ELF backend linker
+   to handle the relocations for a section.
+
+   The relocs are always passed as Rela structures; if the section
+   actually uses Rel structures, the r_addend field will always be
+   zero.
+
+   This function is responsible for adjusting the section contents as
+   necessary, and (if using Rela relocs and generating a relocatable
+   output file) adjusting the reloc addend as necessary.
+
+   This function does not have to worry about setting the reloc
+   address or the reloc symbol index.
+
+   LOCAL_SYMS is a pointer to the swapped in local symbols.
+
+   LOCAL_SECTIONS is an array giving the section in the input file
+   corresponding to the st_shndx field of each local symbol.
+
+   The global hash table entry for the global symbols can be found
+   via elf_sym_hashes (input_bfd).
+
+   When generating relocatable output, this function must handle
+   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
+   going to be the section symbol corresponding to the output
+   section, which means that the addend must be adjusted
+   accordingly.  */
+
+static bfd_boolean
+or1k_elf_relocate_section (bfd *output_bfd,
+			       struct bfd_link_info *info,
+			       bfd *input_bfd,
+			       asection *input_section,
+			       bfd_byte *contents,
+			       Elf_Internal_Rela *relocs,
+			       Elf_Internal_Sym *local_syms,
+			       asection **local_sections)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  Elf_Internal_Rela *rel;
+  Elf_Internal_Rela *relend;
+  struct elf_or1k_link_hash_table *htab = or1k_elf_hash_table (info);
+  bfd *dynobj;
+  asection *sreloc;
+  bfd_vma *local_got_offsets;
+  asection *sgot;
+
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  local_got_offsets = elf_local_got_offsets (input_bfd);
+
+  sreloc = elf_section_data (input_section)->sreloc;
+
+  sgot = htab->sgot;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (input_bfd);
+  relend = relocs + input_section->reloc_count;
+
+  for (rel = relocs; rel < relend; rel++)
+    {
+      reloc_howto_type *howto;
+      unsigned long r_symndx;
+      Elf_Internal_Sym *sym;
+      asection *sec;
+      struct elf_link_hash_entry *h;
+      bfd_vma relocation;
+      bfd_reloc_status_type r;
+      const char *name = NULL;
+      int r_type;
+
+      r_type = ELF32_R_TYPE (rel->r_info);
+      r_symndx = ELF32_R_SYM (rel->r_info);
+
+      if (r_type == R_OR1K_GNU_VTINHERIT
+	  || r_type == R_OR1K_GNU_VTENTRY)
+	continue;
+
+      if (r_type < 0 || r_type >= (int) R_OR1K_max)
+        {
+          bfd_set_error (bfd_error_bad_value);
+          return FALSE;
+        }
+
+      howto = or1k_elf_howto_table + ELF32_R_TYPE (rel->r_info);
+      h = NULL;
+      sym = NULL;
+      sec = NULL;
+      
+      if (r_symndx < symtab_hdr->sh_info)
+	{
+	  sym = local_syms + r_symndx;
+	  sec = local_sections[r_symndx];
+	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
+
+	  name = bfd_elf_string_from_elf_section
+	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
+	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
+	}
+      else
+	{
+	  bfd_boolean unresolved_reloc, warned;
+
+	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
+				   r_symndx, symtab_hdr, sym_hashes,
+				   h, sec, relocation,
+				   unresolved_reloc, warned);
+	}
+
+      if (sec != NULL && discarded_section (sec))
+	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+					 rel, 1, relend, howto, 0, contents);
+
+      if (info->relocatable)
+	continue;
+
+      switch (howto->type)
+	{
+	case R_OR1K_PLT26:
+	  {
+	    if (htab->splt != NULL && h != NULL
+		&& h->plt.offset != (bfd_vma) -1)
+	      {
+		relocation = (htab->splt->output_section->vma
+			      + htab->splt->output_offset
+			      + h->plt.offset);
+	      }
+	    break;
+	  }
+
+	case R_OR1K_GOT16:
+	  /* Relocation is to the entry for this symbol in the global
+	     offset table.  */
+	  BFD_ASSERT (sgot != NULL);
+	  if (h != NULL)
+	    {
+	      bfd_boolean dyn;
+	      bfd_vma off;
+
+	      off = h->got.offset;
+	      BFD_ASSERT (off != (bfd_vma) -1);
+
+	      dyn = htab->root.dynamic_sections_created;
+	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+		  || (info->shared
+		      && (info->symbolic
+			  || h->dynindx == -1
+			  || h->forced_local)
+		      && h->def_regular))
+		{
+		  /* This is actually a static link, or it is a
+		     -Bsymbolic link and the symbol is defined
+		     locally, or the symbol was forced to be local
+		     because of a version file.  We must initialize
+		     this entry in the global offset table.  Since the
+		     offset must always be a multiple of 4, we use the
+		     least significant bit to record whether we have
+		     initialized it already.
+
+		     When doing a dynamic link, we create a .rela.got
+		     relocation entry to initialize the value.  This
+		     is done in the finish_dynamic_symbol routine.  */
+		  if ((off & 1) != 0)
+		    off &= ~1;
+		  else
+		    {
+		      /* Write entry in GOT */
+		      bfd_put_32 (output_bfd, relocation,
+				  sgot->contents + off);
+		      /* Mark GOT entry as having been written.  */
+		      h->got.offset |= 1;
+		    }
+		}
+
+	      relocation = sgot->output_offset + off;
+	    }
+	  else
+	    {
+	      bfd_vma off;
+	      bfd_byte *loc;
+
+	      BFD_ASSERT (local_got_offsets != NULL
+			  && local_got_offsets[r_symndx] != (bfd_vma) -1);
+
+	      /* Get offset into GOT table.  */
+	      off = local_got_offsets[r_symndx];
+
+	      /* The offset must always be a multiple of 4.  We use
+		 the least significant bit to record whether we have
+		 already processed this entry.  */
+	      if ((off & 1) != 0)
+		off &= ~1;
+	      else
+		{
+		  /* Write entry in GOT.  */
+		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
+		  if (info->shared)
+		    {
+		      asection *srelgot;
+		      Elf_Internal_Rela outrel;
+
+		      /* We need to generate a R_OR1K_RELATIVE reloc
+			 for the dynamic linker.  */
+		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+		      BFD_ASSERT (srelgot != NULL);
+
+		      outrel.r_offset = (sgot->output_section->vma
+					 + sgot->output_offset
+					 + off);
+		      outrel.r_info = ELF32_R_INFO (0, R_OR1K_RELATIVE);
+		      outrel.r_addend = relocation;
+		      loc = srelgot->contents;
+		      loc += srelgot->reloc_count * sizeof (Elf32_External_Rela);
+		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,loc);
+		      ++srelgot->reloc_count;
+		    }
+
+		  local_got_offsets[r_symndx] |= 1;
+		}
+	      relocation = sgot->output_offset + off;
+	    }
+
+	  /* Addend should be zero.  */
+	  if (rel->r_addend != 0)
+	    (*_bfd_error_handler)
+	      (_("internal error: addend should be zero for R_OR1K_GOT16"));
+
+	  break;
+
+	case R_OR1K_GOTOFF_LO16:
+	case R_OR1K_GOTOFF_HI16:
+	  /* Relocation is offset from GOT.  */
+	  BFD_ASSERT (sgot != NULL);
+	  relocation -= sgot->output_section->vma;
+	  break;
+
+	case R_OR1K_INSN_REL_26:
+	case R_OR1K_HI_16_IN_INSN:
+	case R_OR1K_LO_16_IN_INSN:
+	case R_OR1K_32:
+	  /*
+	  R_OR1K_16? */
+	  {
+	    /* r_symndx will be STN_UNDEF (zero) only for relocs against symbols
+	       from removed linkonce sections, or sections discarded by
+	       a linker script.  */
+	    if (r_symndx == STN_UNDEF
+		|| (input_section->flags & SEC_ALLOC) == 0)
+	      break;
+
+	    if ((info->shared
+		 && (h == NULL
+		     || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+		     || h->root.type != bfd_link_hash_undefweak)
+		 && (!howto->pc_relative
+		     || (h != NULL
+			 && h->dynindx != -1
+			 && (!info->symbolic
+			     || !h->def_regular))))
+		|| (!info->shared
+		    && h != NULL
+		    && h->dynindx != -1
+		    && !h->non_got_ref
+		    && ((h->def_dynamic
+			 && !h->def_regular)
+			|| h->root.type == bfd_link_hash_undefweak
+			|| h->root.type == bfd_link_hash_undefined)))
+	      {
+		Elf_Internal_Rela outrel;
+		bfd_byte *loc;
+		bfd_boolean skip;
+
+		/* When generating a shared object, these relocations
+		   are copied into the output file to be resolved at run
+		   time.  */
+
+		BFD_ASSERT (sreloc != NULL);
+
+		skip = FALSE;
+
+		outrel.r_offset =
+		  _bfd_elf_section_offset (output_bfd, info, input_section,
+					   rel->r_offset);
+		if (outrel.r_offset == (bfd_vma) -1)
+		  skip = TRUE;
+		else if (outrel.r_offset == (bfd_vma) -2)
+		  skip = TRUE;
+		outrel.r_offset += (input_section->output_section->vma
+				    + input_section->output_offset);
+
+		if (skip)
+		  memset (&outrel, 0, sizeof outrel);
+		/* h->dynindx may be -1 if the symbol was marked to
+		   become local.  */
+		else if (h != NULL
+			 && ((! info->symbolic && h->dynindx != -1)
+			     || !h->def_regular))
+		  {
+		    BFD_ASSERT (h->dynindx != -1);
+		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
+		    outrel.r_addend = rel->r_addend;
+		  }
+		else
+		  {
+		    if (r_type == R_OR1K_32)
+		      {
+			outrel.r_info = ELF32_R_INFO (0, R_OR1K_RELATIVE);
+			outrel.r_addend = relocation + rel->r_addend;
+		      }
+		    else
+		      {
+			BFD_FAIL ();
+			(*_bfd_error_handler)
+			  (_("%B: probably compiled without -fPIC?"),
+			   input_bfd);
+			bfd_set_error (bfd_error_bad_value);
+			return FALSE;
+		      }
+		  }
+
+		loc = sreloc->contents;
+		loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
+		bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
+		break;
+	      }
+            break;
+	  }
+
+	case R_OR1K_TLS_LDM_HI16:
+	case R_OR1K_TLS_LDM_LO16:
+	case R_OR1K_TLS_LDO_HI16:
+	case R_OR1K_TLS_LDO_LO16:
+	  /* TODO: implement support for local dynamic */
+	  BFD_FAIL ();
+	  (*_bfd_error_handler)
+	    (_("%B: support for local dynamic not implemented"),
+	     input_bfd);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+
+
+	case R_OR1K_TLS_GD_HI16:
+	case R_OR1K_TLS_GD_LO16:
+	case R_OR1K_TLS_IE_HI16:
+	case R_OR1K_TLS_IE_LO16:
+	  {
+	    bfd_vma gotoff;
+	    Elf_Internal_Rela rela;
+	    bfd_byte *loc;
+	    int dynamic;
+
+	    /* mark as TLS related GOT entry by setting 
+	     * bit 2 as well as bit 1 */
+	    if (h != NULL) 
+	      {
+		gotoff = h->got.offset;
+		h->got.offset |= 3;
+	      }
+	    else
+	      {
+		gotoff = local_got_offsets[r_symndx];
+		local_got_offsets[r_symndx] |= 3;
+	      }
+
+	    /* only process the relocation once */
+	    if (gotoff & 1)
+	      {
+		relocation = sgot->output_offset + (gotoff  & ~3);
+		break;
+	      }
+
+	    BFD_ASSERT(elf_hash_table (info)->hgot == NULL ||
+		elf_hash_table (info)->hgot->root.u.def.value == 0);
+
+	    /* dynamic entries will require relocations. if we do not need
+	     * them we will just use the default R_OR1K_NONE and
+	     * not set anything */
+
+	    dynamic = info->shared ||
+	      (sec && (sec->flags & SEC_ALLOC) != 0
+		&& h != NULL
+		&& (h->root.type == bfd_link_hash_defweak || !h->def_regular));
+	
+	    /* Shared GD */
+	    if (dynamic && (howto->type == R_OR1K_TLS_GD_HI16
+			   || howto->type == R_OR1K_TLS_GD_LO16))
+	      {
+		int i;
+
+		/* add DTPMOD and DTPOFF GOT and rela entries */
+		for (i = 0; i < 2; ++i)
+		  {
+		    rela.r_offset = sgot->output_section->vma +
+		      sgot->output_offset + gotoff + i*4;
+		    if (h != NULL && h->dynindx != -1)
+		      {
+			rela.r_info = ELF32_R_INFO (h->dynindx,
+			    (i == 0 ? R_OR1K_TLS_DTPMOD : R_OR1K_TLS_DTPOFF));
+			rela.r_addend = 0;
+		      }
+		    else
+		      {
+			rela.r_info = ELF32_R_INFO (0,
+			    (i == 0 ? R_OR1K_TLS_DTPMOD : R_OR1K_TLS_DTPOFF));
+			rela.r_addend = tpoff (info, relocation);
+		      }
+
+		    loc = sreloc->contents;
+		    loc += sreloc->reloc_count++ *
+		      sizeof (Elf32_External_Rela);
+
+		    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+		    bfd_put_32 (output_bfd, 0, sgot->contents + gotoff + i*4);
+		  }
+	      }
+	    /* Static GD */
+	    else if (howto->type == R_OR1K_TLS_GD_HI16
+		     || howto->type == R_OR1K_TLS_GD_LO16)
+	      {
+		bfd_put_32 (output_bfd, 1, sgot->contents + gotoff);
+		bfd_put_32 (output_bfd, tpoff (info, relocation), 
+		    sgot->contents + gotoff + 4);
+	      }
+	    /* Shared IE */
+	    else if (dynamic)
+	      {
+		/* add TPOFF GOT and rela entries */
+		rela.r_offset = sgot->output_section->vma +
+		  sgot->output_offset + gotoff;
+		if (h != NULL && h->dynindx != -1)
+		  {
+		    rela.r_info = ELF32_R_INFO (h->dynindx, R_OR1K_TLS_TPOFF);
+		    rela.r_addend = 0;
+		  }
+		else
+		  {
+		    rela.r_info = ELF32_R_INFO (0, R_OR1K_TLS_TPOFF);
+		    rela.r_addend = tpoff (info, relocation);
+		  }
+
+		loc = sreloc->contents;
+		loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
+
+		bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+		bfd_put_32 (output_bfd, 0, sgot->contents + gotoff);
+	      }
+	    /* Static IE */
+	    else
+	      {
+		bfd_put_32 (output_bfd, tpoff (info, relocation),
+		    sgot->contents + gotoff);
+	      }
+	    relocation = sgot->output_offset + gotoff;
+	    break;
+	  }
+	case R_OR1K_TLS_LE_HI16:
+	case R_OR1K_TLS_LE_LO16:
+
+	  /* Relocation is offset from TP.  */
+	  relocation = tpoff(info, relocation);
+	  break;
+
+	case R_OR1K_TLS_DTPMOD:
+	case R_OR1K_TLS_DTPOFF:
+	case R_OR1K_TLS_TPOFF:
+	  /* These are resolved dynamically on load and shouldn't
+	   * be used as linker input. */
+	  BFD_FAIL ();
+	  (*_bfd_error_handler)
+	    (_("%B: will not resolve runtime TLS relocation"),
+	     input_bfd);
+	  bfd_set_error (bfd_error_bad_value);
+	  return FALSE;
+
+	default:
+	  break;
+	}
+      r = _bfd_final_link_relocate (howto, input_bfd, input_section, contents,
+                                    rel->r_offset, relocation, rel->r_addend);
+
+      if (r != bfd_reloc_ok)
+	{
+	  const char *msg = NULL;
+
+	  switch (r)
+	    {
+	    case bfd_reloc_overflow:
+	      r = info->callbacks->reloc_overflow
+		(info, (h ? &h->root : NULL), name, howto->name,
+		 (bfd_vma) 0, input_bfd, input_section, rel->r_offset);
+	      break;
+
+	    case bfd_reloc_undefined:
+	      r = info->callbacks->undefined_symbol
+		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
+	      break;
+
+	    case bfd_reloc_outofrange:
+	      msg = _("internal error: out of range error");
+	      break;
+
+	    case bfd_reloc_notsupported:
+	      msg = _("internal error: unsupported relocation error");
+	      break;
+
+	    case bfd_reloc_dangerous:
+	      msg = _("internal error: dangerous relocation");
+	      break;
+
+	    default:
+	      msg = _("internal error: unknown error");
+	      break;
+	    }
+
+	  if (msg)
+	    r = info->callbacks->warning
+	      (info, msg, name, input_bfd, input_section, rel->r_offset);
+
+	  if (!r)
+	    return FALSE;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Return the section that should be marked against GC for a given
+   relocation.  */
+
+static asection *
+or1k_elf_gc_mark_hook (asection *sec,
+			   struct bfd_link_info *info,
+			   Elf_Internal_Rela *rel,
+			   struct elf_link_hash_entry *h,
+			   Elf_Internal_Sym *sym)
+{
+  if (h != NULL)
+    switch (ELF32_R_TYPE (rel->r_info))
+      {
+      case R_OR1K_GNU_VTINHERIT:
+      case R_OR1K_GNU_VTENTRY:
+	return NULL;
+      }
+
+  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
+}
+
+static bfd_boolean
+or1k_elf_gc_sweep_hook (bfd *abfd,
+                        struct bfd_link_info *info ATTRIBUTE_UNUSED,
+                        asection *sec,
+                        const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
+{
+  /* Update the got entry reference counts for the section being removed.  */
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  bfd_signed_vma *local_got_refcounts;
+  const Elf_Internal_Rela *rel, *relend;
+
+  elf_section_data (sec)->local_dynrel = NULL;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+  local_got_refcounts = elf_local_got_refcounts (abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      struct elf_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+	}
+
+      switch (ELF32_R_TYPE (rel->r_info))
+	{
+	case R_OR1K_GOT16:
+	  if (h != NULL)
+	    {
+	      if (h->got.refcount > 0)
+		h->got.refcount--;
+	    }
+	  else
+	    {
+	      if (local_got_refcounts && local_got_refcounts[r_symndx] > 0)
+		local_got_refcounts[r_symndx]--;
+	    }
+	  break;
+
+	default:
+	  break;
+	}
+    }
+  return TRUE;
+}
+
+/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
+   shortcuts to them in our hash table.  */
+
+static bfd_boolean
+create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_or1k_link_hash_table *htab;
+  asection *s;
+
+  /* This function may be called more than once.  */
+  s = bfd_get_section_by_name (dynobj, ".got");
+  if (s != NULL && (s->flags & SEC_LINKER_CREATED) != 0)
+    return TRUE;
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  if (! _bfd_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
+  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
+  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
+
+  if (! htab->sgot || ! htab->sgotplt || ! htab->srelgot)
+    abort ();
+
+  if (! bfd_set_section_flags (dynobj, htab->srelgot, SEC_ALLOC
+			       | SEC_LOAD
+			       | SEC_HAS_CONTENTS
+			       | SEC_IN_MEMORY
+			       | SEC_LINKER_CREATED
+			       | SEC_READONLY)
+      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
+    return FALSE;
+
+  return TRUE;
+}
+
+/* Look through the relocs for a section during the first phase. */
+
+static bfd_boolean
+or1k_elf_check_relocs (bfd *abfd,
+			   struct bfd_link_info *info,
+			   asection *sec,
+			   const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel;
+
+  const Elf_Internal_Rela *rel_end;
+  struct elf_or1k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *sreloc = NULL;
+
+  if (info->relocatable)
+    return TRUE;
+
+  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes (abfd);
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      struct elf_link_hash_entry *h;
+      unsigned long r_symndx;
+      unsigned char tls_type;
+
+      r_symndx = ELF32_R_SYM (rel->r_info);
+      if (r_symndx < symtab_hdr->sh_info)
+	h = NULL;
+      else
+	{
+	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+	  while (h->root.type == bfd_link_hash_indirect
+		 || h->root.type == bfd_link_hash_warning)
+	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+	  /* PR15323, ref flags aren't set for references in the same
+	     object.  */
+	  h->root.non_ir_ref = 1;
+	}
+
+      switch (ELF32_R_TYPE (rel->r_info))
+        {
+	case R_OR1K_TLS_GD_HI16:
+	case R_OR1K_TLS_GD_LO16:
+	  tls_type = TLS_GD;
+	  break;
+	case R_OR1K_TLS_LDM_HI16:
+	case R_OR1K_TLS_LDM_LO16:
+	case R_OR1K_TLS_LDO_HI16:
+	case R_OR1K_TLS_LDO_LO16:
+	  tls_type = TLS_LD;
+	  break;
+	case R_OR1K_TLS_IE_HI16:
+	case R_OR1K_TLS_IE_LO16:
+	  tls_type = TLS_IE;
+	  break;
+	case R_OR1K_TLS_LE_HI16:
+	case R_OR1K_TLS_LE_LO16:
+	  tls_type = TLS_LE;
+	  break;
+	default:
+	  tls_type = TLS_NONE;
+	}
+
+      /* record TLS type */
+      if (h != NULL)
+	  ((struct elf_or1k_link_hash_entry *) h)->tls_type = tls_type;
+      else
+	{
+	  unsigned char *local_tls_type;
+
+	  /* This is a TLS type record for a local symbol.  */
+	  local_tls_type = (unsigned char *) elf_or1k_local_tls_type (abfd);
+	  if (local_tls_type == NULL)
+	    {
+	      bfd_size_type size;
+
+	      size = symtab_hdr->sh_info;
+	      local_tls_type = bfd_zalloc (abfd, size);
+	      if (local_tls_type == NULL)
+		return FALSE;
+	      elf_or1k_local_tls_type (abfd) = local_tls_type;
+	    }
+	  local_tls_type[r_symndx] = tls_type;
+	}
+
+      switch (ELF32_R_TYPE (rel->r_info))
+	{
+	  /* This relocation describes the C++ object vtable hierarchy.
+	     Reconstruct it for later use during GC.  */
+	case R_OR1K_GNU_VTINHERIT:
+	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
+	    return FALSE;
+	  break;
+
+	  /* This relocation describes which C++ vtable entries are actually
+	     used.  Record for later use during GC.  */
+	case R_OR1K_GNU_VTENTRY:
+	  BFD_ASSERT (h != NULL);
+	  if (h != NULL
+	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
+	    return FALSE;
+	  break;
+
+	  /* This relocation requires .plt entry.  */
+        case R_OR1K_PLT26:
+          if (h != NULL)
+	    {
+	      h->needs_plt = 1;
+	      h->plt.refcount += 1;
+	    }
+	  break;
+
+	case R_OR1K_GOT16:
+	case R_OR1K_GOTOFF_HI16:
+	case R_OR1K_GOTOFF_LO16:
+	case R_OR1K_TLS_GD_HI16:
+	case R_OR1K_TLS_GD_LO16:
+	case R_OR1K_TLS_IE_HI16:
+	case R_OR1K_TLS_IE_LO16:
+	  if (htab->sgot == NULL)
+	    {
+	      if (dynobj == NULL)
+		htab->root.dynobj = dynobj = abfd;
+	      if (! create_got_section (dynobj, info))
+		return FALSE;
+	    }
+
+	  /* TLS specific */
+	  if (ELF32_R_TYPE (rel->r_info) >= R_OR1K_TLS_GD_HI16 &&
+	      ELF32_R_TYPE (rel->r_info) <= R_OR1K_TLS_IE_LO16)
+	    {
+	      /* set which rela section to use */
+	      elf_section_data (sec)->sreloc =
+		bfd_get_section_by_name (dynobj, ".rela.got");;
+	    }
+
+	  if (ELF32_R_TYPE (rel->r_info) != R_OR1K_GOTOFF_HI16 &&
+	      ELF32_R_TYPE (rel->r_info) != R_OR1K_GOTOFF_LO16)
+	    {
+	      if (h != NULL)
+		h->got.refcount += 1;
+	      else
+		{
+		  bfd_signed_vma *local_got_refcounts;
+
+		  /* This is a global offset table entry for a local symbol.  */
+		  local_got_refcounts = elf_local_got_refcounts (abfd);
+		  if (local_got_refcounts == NULL)
+		    {
+		      bfd_size_type size;
+
+		      size = symtab_hdr->sh_info;
+		      size *= sizeof (bfd_signed_vma);
+		      local_got_refcounts = bfd_zalloc (abfd, size);
+		      if (local_got_refcounts == NULL)
+			return FALSE;
+		      elf_local_got_refcounts (abfd) = local_got_refcounts;
+		    }
+		  local_got_refcounts[r_symndx] += 1;
+		}
+	    }
+	  break;
+
+	case R_OR1K_INSN_REL_26:
+	case R_OR1K_HI_16_IN_INSN:
+	case R_OR1K_LO_16_IN_INSN:
+	case R_OR1K_32:
+	  /* R_OR1K_16? */
+          {
+            if (h != NULL && !info->shared)
+	      {
+		/* we may need a copy reloc.  */
+		h->non_got_ref = 1;
+
+		/* we may also need a .plt entry.  */
+		h->plt.refcount += 1;
+		if (ELF32_R_TYPE (rel->r_info) != R_OR1K_INSN_REL_26)
+		  h->pointer_equality_needed = 1;
+	      }
+
+
+	    /* If we are creating a shared library, and this is a reloc
+	       against a global symbol, or a non PC relative reloc
+	       against a local symbol, then we need to copy the reloc
+	       into the shared library.  However, if we are linking with
+	       -Bsymbolic, we do not need to copy a reloc against a
+	       global symbol which is defined in an object we are
+	       including in the link (i.e., DEF_REGULAR is set).  At
+	       this point we have not seen all the input files, so it is
+	       possible that DEF_REGULAR is not set now but will be set
+	       later (it is never cleared).  In case of a weak definition,
+	       DEF_REGULAR may be cleared later by a strong definition in
+	       a shared library.  We account for that possibility below by
+	       storing information in the relocs_copied field of the hash
+	       table entry.  A similar situation occurs when creating
+	       shared libraries and symbol visibility changes render the
+	       symbol local.
+
+	       If on the other hand, we are creating an executable, we
+	       may need to keep relocations for symbols satisfied by a
+	       dynamic library if we manage to avoid copy relocs for the
+	       symbol.  */
+
+            if ((info->shared
+		 && (sec->flags & SEC_ALLOC) != 0
+		 && (ELF32_R_TYPE (rel->r_info) != R_OR1K_INSN_REL_26
+		     || (h != NULL
+			 && (! info->symbolic
+			     || h->root.type == bfd_link_hash_defweak
+			     || !h->def_regular))))
+		|| (!info->shared
+		    && (sec->flags & SEC_ALLOC) != 0
+		    && h != NULL
+		    && (h->root.type == bfd_link_hash_defweak
+			|| !h->def_regular)))
+	      {
+		struct elf_or1k_dyn_relocs *p;
+		struct elf_or1k_dyn_relocs **head;
+
+		/* When creating a shared object, we must copy these
+		   relocs into the output file.  We create a reloc
+		   section in dynobj and make room for the reloc.  */
+		if (sreloc == NULL)
+		  {
+		    const char *name;
+		    unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
+		    unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
+
+		    name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
+		    if (name == NULL)
+		      return FALSE;
+
+		    if (strncmp (name, ".rela", 5) != 0
+			|| strcmp (bfd_get_section_name (abfd, sec),
+				   name + 5) != 0)
+		      {
+			(*_bfd_error_handler)
+			  (_("%B: bad relocation section name `%s\'"),
+			   abfd, name);
+		      }
+
+		    if (htab->root.dynobj == NULL)
+		      htab->root.dynobj = abfd;
+		    dynobj = htab->root.dynobj;
+
+		    sreloc = bfd_get_section_by_name (dynobj, name);
+		    if (sreloc == NULL)
+		      {
+		        sreloc = _bfd_elf_make_dynamic_reloc_section
+		          (sec, dynobj, 2, abfd, /*rela?*/ TRUE);
+
+		        if (sreloc == NULL)
+		          return FALSE;
+		      }
+		    elf_section_data (sec)->sreloc = sreloc;
+		  }
+
+		/* If this is a global symbol, we count the number of
+		   relocations we need for this symbol.  */
+		if (h != NULL)
+		  head = &((struct elf_or1k_link_hash_entry *) h)->dyn_relocs;
+		else
+		  {
+		    /* Track dynamic relocs needed for local syms too.
+		       We really need local syms available to do this
+		       easily.  Oh well.  */
+
+		    asection *s;
+		    Elf_Internal_Sym *isym;
+		    void *vpp;
+
+		    isym = bfd_sym_from_r_symndx (&htab->sym_sec,
+						  abfd, r_symndx);
+		    if (isym == NULL)
+		      return FALSE;
+
+		    s = bfd_section_from_elf_index (abfd, isym->st_shndx);
+		    if (s == NULL)
+		      return FALSE;
+
+		    vpp = &elf_section_data (s)->local_dynrel;
+		    head = (struct elf_or1k_dyn_relocs **) vpp;
+		  }
+
+		p = *head;
+		if (p == NULL || p->sec != sec)
+		  {
+		    bfd_size_type amt = sizeof *p;
+		    p = ((struct elf_or1k_dyn_relocs *)
+			 bfd_alloc (htab->root.dynobj, amt));
+		    if (p == NULL)
+		      return FALSE;
+		    p->next = *head;
+		    *head = p;
+		    p->sec = sec;
+		    p->count = 0;
+		    p->pc_count = 0;
+		  }
+
+		p->count += 1;
+		if (ELF32_R_TYPE (rel->r_info) == R_OR1K_INSN_REL_26)
+		  p->pc_count += 1;
+	      }
+	  }
+	  break;
+	}
+    }
+
+  return TRUE;
+}
+
+/* Finish up the dynamic sections.  */
+
+static bfd_boolean
+or1k_elf_finish_dynamic_sections (bfd *output_bfd,
+				  struct bfd_link_info *info)
+{
+  bfd *dynobj;
+  asection *sdyn, *sgot;
+  struct elf_or1k_link_hash_table *htab;
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+
+  sgot = htab->sgotplt;
+  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      asection *splt;
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT (sgot != NULL && sdyn != NULL);
+
+      dyncon = (Elf32_External_Dyn *) sdyn->contents;
+      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
+
+      for (; dyncon < dynconend; dyncon++)
+	{
+	  Elf_Internal_Dyn dyn;
+          asection *s;
+
+	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
+
+	  switch (dyn.d_tag)
+	    {
+	    default:
+	      continue;
+
+	    case DT_PLTGOT:
+	      s = htab->sgot->output_section;
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->vma;
+	      break;
+
+	    case DT_JMPREL:
+	      s = htab->srelplt->output_section;
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_ptr = s->vma;
+	      break;
+
+	    case DT_PLTRELSZ:
+	      s = htab->srelplt->output_section;
+	      BFD_ASSERT (s != NULL);
+	      dyn.d_un.d_val = s->size;
+	      break;
+
+	    case DT_RELASZ:
+	      /* My reading of the SVR4 ABI indicates that the
+		 procedure linkage table relocs (DT_JMPREL) should be
+		 included in the overall relocs (DT_RELA).  This is
+		 what Solaris does.  However, UnixWare can not handle
+		 that case.  Therefore, we override the DT_RELASZ entry
+		 here to make it not include the JMPREL relocs.  Since
+		 the linker script arranges for .rela.plt to follow all
+		 other relocation sections, we don't have to worry
+		 about changing the DT_RELA entry.  */
+	      if (htab->srelplt != NULL)
+		{
+		  /* FIXME: this calculation sometimes produces
+		     wrong result, the problem is that the dyn.d_un.d_val
+		     is not always correct, needs investigation why
+		     that happens. In the meantime, reading the
+		     ".rela.dyn" section by name seems to yield
+		     correct result.
+
+		  s = htab->srelplt->output_section;
+		  dyn.d_un.d_val -= s->size;
+		  */
+
+		  s = bfd_get_section_by_name (output_bfd, ".rela.dyn");
+		  dyn.d_un.d_val = s ? s->size : 0;
+		}
+	      break;
+	    }
+	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
+	}
+
+
+      /* Fill in the first entry in the procedure linkage table.  */
+      splt = htab->splt;
+      if (splt && splt->size > 0)
+	{
+	  if (info->shared)
+	    {
+	      bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD0,
+			  splt->contents);
+	      bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD1,
+			  splt->contents + 4);
+	      bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD2,
+			  splt->contents + 8);
+	      bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD3,
+			  splt->contents + 12);
+	      bfd_put_32 (output_bfd, PLT0_PIC_ENTRY_WORD4,
+			  splt->contents + 16);
+	    }
+	  else
+	    {
+	      unsigned long addr;
+	      /* addr = .got + 4 */
+	      addr = sgot->output_section->vma + sgot->output_offset + 4;
+	      bfd_put_32 (output_bfd,
+			  PLT0_ENTRY_WORD0 | ((addr >> 16) & 0xffff),
+			  splt->contents);
+	      bfd_put_32 (output_bfd,
+			  PLT0_ENTRY_WORD1 | (addr & 0xffff),
+			  splt->contents + 4);
+	      bfd_put_32 (output_bfd, PLT0_ENTRY_WORD2, splt->contents + 8);
+	      bfd_put_32 (output_bfd, PLT0_ENTRY_WORD3, splt->contents + 12);
+	      bfd_put_32 (output_bfd, PLT0_ENTRY_WORD4, splt->contents + 16);
+	    }
+
+	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
+	}
+    }
+
+  /* Set the first entry in the global offset table to the address of
+     the dynamic section.  */
+  if (sgot && sgot->size > 0)
+    {
+      if (sdyn == NULL)
+	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
+      else
+	bfd_put_32 (output_bfd,
+		    sdyn->output_section->vma + sdyn->output_offset,
+		    sgot->contents);
+      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
+    }
+
+  if (htab->sgot && htab->sgot->size > 0)
+    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+/* Finish up dynamic symbol handling.  We set the contents of various
+   dynamic sections here.  */
+
+static bfd_boolean
+or1k_elf_finish_dynamic_symbol (bfd *output_bfd,
+				struct bfd_link_info *info,
+				struct elf_link_hash_entry *h,
+				Elf_Internal_Sym *sym)
+{
+  struct elf_or1k_link_hash_table *htab;
+  bfd_byte *loc;
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  if (h->plt.offset != (bfd_vma) -1)
+    {
+      asection *splt;
+      asection *sgot;
+      asection *srela;
+
+      bfd_vma plt_index;
+      bfd_vma got_offset;
+      bfd_vma got_addr;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the procedure linkage table.  Set
+         it up.  */
+      BFD_ASSERT (h->dynindx != -1);
+
+      splt = htab->splt;
+      sgot = htab->sgotplt;
+      srela = htab->srelplt;
+      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
+
+      /* Get the index in the procedure linkage table which
+         corresponds to this symbol.  This is the index of this symbol
+         in all the symbols for which we are making plt entries.  The
+         first entry in the procedure linkage table is reserved.  */
+      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+
+      /* Get the offset into the .got table of the entry that
+        corresponds to this function.  Each .got entry is 4 bytes.
+        The first three are reserved.  */
+      got_offset = (plt_index + 3) * 4;
+      got_addr = got_offset;
+
+      /* Fill in the entry in the procedure linkage table.  */
+      if (! info->shared)
+        {
+	  got_addr += htab->sgotplt->output_section->vma
+	    + htab->sgotplt->output_offset;
+	  bfd_put_32 (output_bfd, PLT_ENTRY_WORD0 | ((got_addr >> 16) & 0xffff),
+		      splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, PLT_ENTRY_WORD1 | (got_addr & 0xffff),
+		      splt->contents + h->plt.offset + 4);
+	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD2,
+		      splt->contents + h->plt.offset + 8);
+	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD3,
+		      splt->contents + h->plt.offset + 12);
+	  bfd_put_32 (output_bfd, PLT_ENTRY_WORD4
+		      | plt_index * sizeof (Elf32_External_Rela),
+		      splt->contents + h->plt.offset + 16);
+	}
+      else
+	{
+	  bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD0 | (got_addr & 0xffff),
+		      splt->contents + h->plt.offset);
+	  bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD1
+		      | plt_index * sizeof (Elf32_External_Rela),
+		      splt->contents + h->plt.offset + 4);
+	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD2,
+		      splt->contents + h->plt.offset + 8);
+	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD3,
+		      splt->contents + h->plt.offset + 12);
+	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD4,
+		      splt->contents + h->plt.offset + 16);
+	}
+
+      /* Fill in the entry in the global offset table.  */
+      bfd_put_32 (output_bfd,
+		  (splt->output_section->vma
+		   + splt->output_offset), /* same offset */
+		  sgot->contents + got_offset);
+
+      /* Fill in the entry in the .rela.plt section.  */
+      rela.r_offset = (sgot->output_section->vma
+		       + sgot->output_offset
+		       + got_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_OR1K_JMP_SLOT);
+      rela.r_addend = 0;
+      loc = srela->contents;
+      loc += plt_index * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
+      if (!h->def_regular)
+	{
+	  /* Mark the symbol as undefined, rather than as defined in
+	     the .plt section.  Leave the value alone.  */
+	  sym->st_shndx = SHN_UNDEF;
+	}
+
+    }
+
+  if (h->got.offset != (bfd_vma) -1 &&
+      (h->got.offset & 2) == 0) /* homemade TLS check */
+    {
+      asection *sgot;
+      asection *srela;
+      Elf_Internal_Rela rela;
+
+      /* This symbol has an entry in the global offset table.  Set it
+         up.  */
+      sgot = htab->sgot;
+      srela = htab->srelgot;
+      BFD_ASSERT (sgot != NULL && srela != NULL);
+
+      rela.r_offset = (sgot->output_section->vma
+                       + sgot->output_offset
+                       + (h->got.offset &~ 1));
+
+      /* If this is a -Bsymbolic link, and the symbol is defined
+         locally, we just want to emit a RELATIVE reloc.  Likewise if
+         the symbol was forced to be local because of a version file.
+         The entry in the global offset table will already have been
+         initialized in the relocate_section function.  */
+      if (info->shared
+	  && (info->symbolic
+	      || h->dynindx == -1
+	      || h->forced_local)
+	  && h->def_regular)
+	{
+	  rela.r_info = ELF32_R_INFO (0, R_OR1K_RELATIVE);
+	  rela.r_addend = (h->root.u.def.value
+			   + h->root.u.def.section->output_section->vma
+			   + h->root.u.def.section->output_offset);
+	}
+      else
+	{
+	  BFD_ASSERT ((h->got.offset & 1) == 0);
+	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
+	  rela.r_info = ELF32_R_INFO (h->dynindx, R_OR1K_GLOB_DAT);
+	  rela.r_addend = 0;
+	}
+
+      loc = srela->contents;
+      loc += srela->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++srela->reloc_count;
+    }
+
+  if (h->needs_copy)
+    {
+      asection *s;
+      Elf_Internal_Rela rela;
+
+      /* This symbols needs a copy reloc.  Set it up.  */
+      BFD_ASSERT (h->dynindx != -1
+		  && (h->root.type == bfd_link_hash_defined
+		      || h->root.type == bfd_link_hash_defweak));
+
+      s = bfd_get_section_by_name (h->root.u.def.section->owner,
+				   ".rela.bss");
+      BFD_ASSERT (s != NULL);
+
+      rela.r_offset = (h->root.u.def.value
+		       + h->root.u.def.section->output_section->vma
+		       + h->root.u.def.section->output_offset);
+      rela.r_info = ELF32_R_INFO (h->dynindx, R_OR1K_COPY);
+      rela.r_addend = 0;
+      loc = s->contents;
+      loc += s->reloc_count * sizeof (Elf32_External_Rela);
+      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+      ++s->reloc_count;
+    }
+
+  /* Mark some specially defined symbols as absolute.  */
+  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
+      || h == htab->root.hgot)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+static enum elf_reloc_type_class
+or1k_elf_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
+			   const asection *rel_sec ATTRIBUTE_UNUSED,
+			   const Elf_Internal_Rela *rela)
+{
+  switch ((int) ELF32_R_TYPE (rela->r_info))
+    {
+    case R_OR1K_RELATIVE:  return reloc_class_relative;
+    case R_OR1K_JMP_SLOT:  return reloc_class_plt;
+    case R_OR1K_COPY:      return reloc_class_copy;
+    default:               return reloc_class_normal;
+    }
+}
+
+/* Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+or1k_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
+				struct elf_link_hash_entry *h)
+{
+  struct elf_or1k_link_hash_table *htab;
+  struct elf_or1k_link_hash_entry *eh;
+  struct elf_or1k_dyn_relocs *p;
+  bfd *dynobj;
+  asection *s;
+
+  dynobj = elf_hash_table (info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+	      && (h->needs_plt
+		  || h->u.weakdef != NULL
+		  || (h->def_dynamic
+		      && h->ref_regular
+		      && !h->def_regular)));
+
+  /* If this is a function, put it in the procedure linkage table.  We
+     will fill in the contents of the procedure linkage table later,
+     when we know the address of the .got section.  */
+  if (h->type == STT_FUNC
+      || h->needs_plt)
+    {
+      if (! info->shared
+	  && !h->def_dynamic
+	  && !h->ref_dynamic
+	  && h->root.type != bfd_link_hash_undefweak
+	  && h->root.type != bfd_link_hash_undefined)
+        {
+	  /* This case can occur if we saw a PLT reloc in an input
+	     file, but the symbol was never referred to by a dynamic
+	     object.  In such a case, we don't actually need to build
+	     a procedure linkage table, and we can just do a PCREL
+	     reloc instead.  */
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+
+      return TRUE;
+    }
+  else
+    h->plt.offset = (bfd_vma) -1;
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
+		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  /* If we are creating a shared library, we must presume that the
+     only references to the symbol are via the global offset table.
+     For such cases we need not do anything here; the relocations will
+     be handled correctly by relocate_section.  */
+  if (info->shared)
+    return TRUE;
+
+  /* If there are no references to this symbol that do not use the
+     GOT, we don't need to generate a copy reloc.  */
+  if (!h->non_got_ref)
+    return TRUE;
+
+  /* If -z nocopyreloc was given, we won't generate them either.  */
+  if (info->nocopyreloc)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  eh = (struct elf_or1k_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      s = p->sec->output_section;
+      if (s != NULL && (s->flags & (SEC_READONLY | SEC_HAS_CONTENTS)) != 0)
+	break;
+    }
+
+  /* If we didn't find any dynamic relocs in sections which needs the
+     copy reloc, then we'll be keeping the dynamic relocs and avoiding
+     the copy reloc.  */
+  if (p == NULL)
+    {
+      h->non_got_ref = 0;
+      return TRUE;
+    }
+
+  /* We must allocate the symbol in our .dynbss section, which will
+     become part of the .bss section of the executable.  There will be
+     an entry for this symbol in the .dynsym section.  The dynamic
+     object will contain position independent code, so all references
+     from the dynamic object to this symbol will go through the global
+     offset table.  The dynamic linker will use the .dynsym entry to
+     determine the address it must put in the global offset table, so
+     both the dynamic object and the regular object will refer to the
+     same memory location for the variable.  */
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  s = htab->sdynbss;
+  BFD_ASSERT (s != NULL);
+
+  /* We must generate a R_OR1K_COPY reloc to tell the dynamic linker
+     to copy the initial value out of the dynamic object and into the
+     runtime process image.  We need to remember the offset into the
+     .rela.bss section we are going to use.  */
+  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
+    {
+      asection *srel;
+
+      srel = htab->srelbss;
+      BFD_ASSERT (srel != NULL);
+      srel->size += sizeof (Elf32_External_Rela);
+      h->needs_copy = 1;
+    }
+
+  return _bfd_elf_adjust_dynamic_copy (h, s);
+}
+
+/* Allocate space in .plt, .got and associated reloc sections for
+   dynamic relocs.  */
+
+static bfd_boolean
+allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct bfd_link_info *info;
+  struct elf_or1k_link_hash_table *htab;
+  struct elf_or1k_link_hash_entry *eh;
+  struct elf_or1k_dyn_relocs *p;
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  info = (struct bfd_link_info *) inf;
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  eh = (struct elf_or1k_link_hash_entry *) h;
+
+  if (htab->root.dynamic_sections_created
+      && h->plt.refcount > 0)
+    {
+      /* Make sure this symbol is output as a dynamic symbol.
+         Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info->shared, h))
+	{
+	  asection *s = htab->splt;
+
+	  /* If this is the first .plt entry, make room for the special
+	     first entry.  */
+	  if (s->size == 0)
+	    s->size = PLT_ENTRY_SIZE;
+
+	  h->plt.offset = s->size;
+
+	  /* If this symbol is not defined in a regular file, and we are
+	     not generating a shared library, then set the symbol to this
+	     location in the .plt.  This is required to make function
+	     pointers compare as equal between the normal executable and
+	     the shared library.  */
+	  if (! info->shared
+	      && !h->def_regular)
+	    {
+	      h->root.u.def.section = s;
+	      h->root.u.def.value = h->plt.offset;
+	    }
+
+	  /* Make room for this entry.  */
+	  s->size += PLT_ENTRY_SIZE;
+
+	  /* We also need to make an entry in the .got.plt section, which
+	     will be placed in the .got section by the linker script.  */
+	  htab->sgotplt->size += 4;
+
+	  /* We also need to make an entry in the .rel.plt section.  */
+	  htab->srelplt->size += sizeof (Elf32_External_Rela);
+	}
+      else
+	{
+	  h->plt.offset = (bfd_vma) -1;
+	  h->needs_plt = 0;
+	}
+    }
+  else
+    {
+      h->plt.offset = (bfd_vma) -1;
+      h->needs_plt = 0;
+    }
+
+  if (h->got.refcount > 0)
+    {
+      asection *s;
+      bfd_boolean dyn;
+      unsigned char tls_type;
+
+      /* Make sure this symbol is output as a dynamic symbol.
+	 Undefined weak syms won't yet be marked as dynamic.  */
+      if (h->dynindx == -1
+	  && !h->forced_local)
+	{
+	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+	    return FALSE;
+	}
+
+      s = htab->sgot;
+
+      h->got.offset = s->size;
+
+      tls_type = ((struct elf_or1k_link_hash_entry *) h)->tls_type;
+
+      /* TLS GD requires two GOT and two relocs */
+      if (tls_type == TLS_GD)
+	s->size += 8;
+      else
+	s->size += 4;
+      dyn = htab->root.dynamic_sections_created;
+      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)) 
+	{
+	  if (tls_type == TLS_GD)
+	    htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
+	  else
+	    htab->srelgot->size += sizeof (Elf32_External_Rela);
+        }
+    }
+  else
+    h->got.offset = (bfd_vma) -1;
+
+  if (eh->dyn_relocs == NULL)
+    return TRUE;
+
+  /* In the shared -Bsymbolic case, discard space allocated for
+     dynamic pc-relative relocs against symbols which turn out to be
+     defined in regular objects.  For the normal shared case, discard
+     space for pc-relative relocs that have become local due to symbol
+     visibility changes.  */
+
+  if (info->shared)
+    {
+      if (h->def_regular
+	  && (h->forced_local
+	      || info->symbolic))
+	{
+	  struct elf_or1k_dyn_relocs **pp;
+
+	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      p->count -= p->pc_count;
+	      p->pc_count = 0;
+	      if (p->count == 0)
+		*pp = p->next;
+	      else
+		pp = &p->next;
+	    }
+	}
+
+      /* Also discard relocs on undefined weak syms with non-default
+	 visibility.  */
+      if (eh->dyn_relocs != NULL
+	  && h->root.type == bfd_link_hash_undefweak)
+	{
+	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
+	    eh->dyn_relocs = NULL;
+
+	  /* Make sure undefined weak symbols are output as a dynamic
+	     symbol in PIEs.  */
+	  else if (h->dynindx == -1
+		   && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+	}
+    }
+  else
+    {
+      /* For the non-shared case, discard space for relocs against
+         symbols which turn out to need copy relocs or are not
+         dynamic.  */
+
+      if (!h->non_got_ref
+	  && ((h->def_dynamic
+	       && !h->def_regular)
+	      || (htab->root.dynamic_sections_created
+		  && (h->root.type == bfd_link_hash_undefweak
+		      || h->root.type == bfd_link_hash_undefined))))
+	{
+	  /* Make sure this symbol is output as a dynamic symbol.
+	     Undefined weak syms won't yet be marked as dynamic.  */
+	  if (h->dynindx == -1
+	      && !h->forced_local)
+	    {
+	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
+		return FALSE;
+	    }
+
+	  /* If that succeeded, we know we'll be keeping all the
+	     relocs.  */
+	  if (h->dynindx != -1)
+	    goto keep;
+	}
+
+      eh->dyn_relocs = NULL;
+
+    keep: ;
+    }
+
+  /* Finally, allocate space.  */
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *sreloc = elf_section_data (p->sec)->sreloc;
+      sreloc->size += p->count * sizeof (Elf32_External_Rela);
+    }
+
+  return TRUE;
+}
+
+/* Find any dynamic relocs that apply to read-only sections.  */
+
+static bfd_boolean
+readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
+{
+  struct elf_or1k_link_hash_entry *eh;
+  struct elf_or1k_dyn_relocs *p;
+
+  eh = (struct elf_or1k_link_hash_entry *) h;
+  for (p = eh->dyn_relocs; p != NULL; p = p->next)
+    {
+      asection *s = p->sec->output_section;
+
+      if (s != NULL && (s->flags & SEC_READONLY) != 0)
+	{
+	  struct bfd_link_info *info = (struct bfd_link_info *) inf;
+
+	  info->flags |= DF_TEXTREL;
+
+	  /* Not an error, just cut short the traversal.  */
+	  return FALSE;
+	}
+    }
+  return TRUE;
+}
+
+/* Set the sizes of the dynamic sections.  */
+
+static bfd_boolean
+or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+                                struct bfd_link_info *info)
+{
+  struct elf_or1k_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd_boolean relocs;
+  bfd *ibfd;
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT (dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Set the contents of the .interp section to the interpreter.  */
+      if (info->executable)
+	{
+	  s = bfd_get_section_by_name (dynobj, ".interp");
+	  BFD_ASSERT (s != NULL);
+	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
+	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
+	}
+    }
+
+  /* Set up .got offsets for local syms, and space for local dynamic
+     relocs.  */
+  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      bfd_signed_vma *local_got;
+      bfd_signed_vma *end_local_got;
+      bfd_size_type locsymcount;
+      Elf_Internal_Shdr *symtab_hdr;
+      unsigned char *local_tls_type;
+      asection *srel;
+
+      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
+	continue;
+
+      for (s = ibfd->sections; s != NULL; s = s->next)
+	{
+	  struct elf_or1k_dyn_relocs *p;
+
+	  for (p = ((struct elf_or1k_dyn_relocs *)
+		    elf_section_data (s)->local_dynrel);
+	       p != NULL;
+	       p = p->next)
+	    {
+	      if (! bfd_is_abs_section (p->sec)
+		  && bfd_is_abs_section (p->sec->output_section))
+		{
+		  /* Input section has been discarded, either because
+		     it is a copy of a linkonce section or due to
+		     linker script /DISCARD/, so we'll be discarding
+		     the relocs too.  */
+		}
+	      else if (p->count != 0)
+		{
+		  srel = elf_section_data (p->sec)->sreloc;
+		  srel->size += p->count * sizeof (Elf32_External_Rela);
+		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
+		    info->flags |= DF_TEXTREL;
+		}
+	    }
+	}
+
+      local_got = elf_local_got_refcounts (ibfd);
+      if (!local_got)
+	continue;
+
+      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+      s = htab->sgot;
+      srel = htab->srelgot;
+      local_tls_type = (unsigned char *) elf_or1k_local_tls_type (ibfd);
+      for (; local_got < end_local_got; ++local_got)
+	{
+	  if (*local_got > 0)
+	    {
+	      *local_got = s->size;
+
+	      /* TLS GD requires two GOT and two relocs */
+	      if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		s->size += 8;
+	      else
+		s->size += 4;
+	      if (info->shared)
+		{
+		  if (local_tls_type != NULL && *local_tls_type == TLS_GD)
+		    srel->size += 2 * sizeof (Elf32_External_Rela);
+		  else
+		    srel->size += sizeof (Elf32_External_Rela);
+		}
+	    }
+	  else
+
+	    *local_got = (bfd_vma) -1;
+
+	  if (local_tls_type)
+	    ++local_tls_type;
+	}
+    }
+
+  /* Allocate global sym .plt and .got entries, and space for global
+     sym dynamic relocs.  */
+  elf_link_hash_traverse (&htab->root, allocate_dynrelocs, info);
+
+  /* We now have determined the sizes of the various dynamic sections.
+     Allocate memory for them.  */
+  relocs = FALSE;
+  for (s = dynobj->sections; s != NULL; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+	continue;
+
+      if (s == htab->splt
+	  || s == htab->sgot
+	  || s == htab->sgotplt
+	  || s == htab->sdynbss)
+	{
+	  /* Strip this section if we don't need it; see the
+	     comment below.  */
+	}
+      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
+	{
+	  if (s->size != 0 && s != htab->srelplt)
+	    relocs = TRUE;
+
+	  /* We use the reloc_count field as a counter if we need
+	     to copy relocs into the output file.  */
+	  s->reloc_count = 0;
+	}
+      else
+	/* It's not one of our sections, so don't allocate space.  */
+	continue;
+
+      if (s->size == 0)
+	{
+	  /* If we don't need this section, strip it from the
+	     output file.  This is mostly to handle .rela.bss and
+	     .rela.plt.  We must create both sections in
+	     create_dynamic_sections, because they must be created
+	     before the linker maps input sections to output
+	     sections.  The linker does that before
+	     adjust_dynamic_symbol is called, and it is that
+	     function which decides whether anything needs to go
+	     into these sections.  */
+	  s->flags |= SEC_EXCLUDE;
+	  continue;
+	}
+
+      if ((s->flags & SEC_HAS_CONTENTS) == 0)
+	continue;
+
+      /* Allocate memory for the section contents.  We use bfd_zalloc
+	 here in case unused entries are not reclaimed before the
+	 section's contents are written out.  This should not happen,
+	 but this way if it does, we get a R_OR1K_NONE reloc instead
+	 of garbage.  */
+      s->contents = bfd_zalloc (dynobj, s->size);
+
+      if (s->contents == NULL)
+	return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+	 values later, in or1k_elf_finish_dynamic_sections, but we
+	 must add the entries now so that we get the correct size for
+	 the .dynamic section.  The DT_DEBUG entry is filled in by the
+	 dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) \
+  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
+
+     if (info->executable)
+       {
+	 if (! add_dynamic_entry (DT_DEBUG, 0))
+	   return FALSE;
+       }
+
+     if (htab->splt->size != 0)
+       {
+	 if (! add_dynamic_entry (DT_PLTGOT, 0)
+	     || ! add_dynamic_entry (DT_PLTRELSZ, 0)
+	     || ! add_dynamic_entry (DT_PLTREL, DT_RELA)
+	     || ! add_dynamic_entry (DT_JMPREL, 0))
+	   return FALSE;
+        }
+
+     if (relocs)
+       {
+	 if (! add_dynamic_entry (DT_RELA, 0)
+	     || ! add_dynamic_entry (DT_RELASZ, 0)
+	     || ! add_dynamic_entry (DT_RELAENT,
+				     sizeof (Elf32_External_Rela)))
+	   return FALSE;
+
+	 /* If any dynamic relocs apply to a read-only section,
+	    then we need a DT_TEXTREL entry.  */
+	 if ((info->flags & DF_TEXTREL) == 0)
+	   elf_link_hash_traverse (&htab->root, readonly_dynrelocs,
+				   info);
+
+	 if ((info->flags & DF_TEXTREL) != 0)
+	   {
+	     if (! add_dynamic_entry (DT_TEXTREL, 0))
+	       return FALSE;
+	   }
+       }
+    }
+
+#undef add_dynamic_entry
+  return TRUE;
+}
+
+/* Create dynamic sections when linking against a dynamic object.  */
+
+static bfd_boolean
+or1k_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_or1k_link_hash_table *htab;
+
+  htab = or1k_elf_hash_table (info);
+  if (htab == NULL)
+    return FALSE;
+
+  if (!htab->sgot && !create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
+    return FALSE;
+
+  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
+  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
+  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
+  if (!info->shared)
+    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
+
+  if (!htab->splt || !htab->srelplt || !htab->sdynbss
+      || (!info->shared && !htab->srelbss))
+    abort ();
+
+  return TRUE;
+}
+
+/* Copy the extra info we tack onto an elf_link_hash_entry.  */
+
+static void
+or1k_elf_copy_indirect_symbol (struct bfd_link_info *info,
+                               struct elf_link_hash_entry *dir,
+                               struct elf_link_hash_entry *ind)
+{
+  struct elf_or1k_link_hash_entry * edir;
+  struct elf_or1k_link_hash_entry * eind;
+
+  edir = (struct elf_or1k_link_hash_entry *) dir;
+  eind = (struct elf_or1k_link_hash_entry *) ind;
+
+  if (eind->dyn_relocs != NULL)
+    {
+      if (edir->dyn_relocs != NULL)
+	{
+	  struct elf_or1k_dyn_relocs **pp;
+	  struct elf_or1k_dyn_relocs *p;
+
+	  /* Add reloc counts against the indirect sym to the direct sym
+	     list.  Merge any entries against the same section.  */
+	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL;)
+	    {
+	      struct elf_or1k_dyn_relocs *q;
+
+	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
+		if (q->sec == p->sec)
+		  {
+		    q->pc_count += p->pc_count;
+		    q->count += p->count;
+		    *pp = p->next;
+		    break;
+		  }
+	      if (q == NULL)
+		pp = &p->next;
+	    }
+	  *pp = edir->dyn_relocs;
+	}
+
+      edir->dyn_relocs = eind->dyn_relocs;
+      eind->dyn_relocs = NULL;
+    }
+
+  if (ind->root.type == bfd_link_hash_indirect)
+    {
+      if (dir->got.refcount <= 0)
+	{
+	  edir->tls_type = eind->tls_type;
+	  eind->tls_type = TLS_UNKNOWN;
+	}
+    }
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+}
+
+/* Set the right machine number.  */
+
+static bfd_boolean
+or1k_elf_object_p (bfd *abfd)
+{
+  unsigned long mach = bfd_mach_or1k;
+
+  if (elf_elfheader (abfd)->e_flags & EF_OR1K_NODELAY) {
+    mach = bfd_mach_or1knd;
+  }
+  
+  return bfd_default_set_arch_mach (abfd, bfd_arch_or1k, mach);
+}
+
+/* Store the machine number in the flags field.  */
+
+static void
+or1k_elf_final_write_processing (bfd *abfd,
+				     bfd_boolean linker ATTRIBUTE_UNUSED)
+{
+  
+  switch (bfd_get_mach (abfd))
+    {
+    default:
+    case bfd_mach_or1k:
+      break;
+    case bfd_mach_or1knd:
+      elf_elfheader (abfd)->e_flags |= EF_OR1K_NODELAY;
+      break;
+    }
+  
+}
+
+static bfd_boolean
+or1k_elf_set_private_flags (bfd *abfd, flagword flags)
+{
+  BFD_ASSERT (!elf_flags_init (abfd)
+              || elf_elfheader (abfd)->e_flags == flags);
+  
+  elf_elfheader (abfd)->e_flags = flags;
+  elf_flags_init (abfd) = TRUE;
+  return TRUE;
+}
+
+/* make sure all input files are consistent with respect to
+   EF_OR1K_NODELAY flag setting */
+
+static bfd_boolean
+elf32_or1k_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+{
+  flagword out_flags;
+  flagword in_flags;
+
+  in_flags  = elf_elfheader (ibfd)->e_flags;
+  out_flags = elf_elfheader (obfd)->e_flags;
+
+  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour ||
+      bfd_get_flavour (obfd) != bfd_target_elf_flavour)
+    return TRUE;
+  
+  if (!elf_flags_init (obfd))
+    {
+      elf_flags_init (obfd) = TRUE;
+      elf_elfheader (obfd)->e_flags = in_flags;
+      
+      return TRUE;
+    }
+  
+  if (in_flags == out_flags)
+    return TRUE;
+  
+  if ((in_flags & EF_OR1K_NODELAY) != (out_flags & EF_OR1K_NODELAY)) {
+    
+    (*_bfd_error_handler)
+      (_("%B: EF_OR1K_NODELAY flag mismatch with previous modules"), ibfd);
+    
+    bfd_set_error (bfd_error_bad_value);
+    return FALSE;
+
+  }
+  
+  return TRUE;
+  
+}
+
+#define ELF_ARCH			bfd_arch_or1k
+#define ELF_MACHINE_CODE		EM_OR1K
+#define ELF_TARGET_ID			OR1K_ELF_DATA
+#define ELF_MAXPAGESIZE			0x2000
+
+#define TARGET_BIG_SYM			bfd_elf32_or1k_vec
+#define TARGET_BIG_NAME			"elf32-or1k"
+
+#define elf_info_to_howto_rel		NULL
+#define elf_info_to_howto		or1k_info_to_howto_rela
+#define elf_backend_relocate_section	or1k_elf_relocate_section
+#define elf_backend_gc_mark_hook	or1k_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook	or1k_elf_gc_sweep_hook
+#define elf_backend_check_relocs	or1k_elf_check_relocs
+#define elf_backend_reloc_type_class	or1k_elf_reloc_type_class
+#define elf_backend_can_gc_sections	1
+#define elf_backend_rela_normal		1
+
+#define bfd_elf32_mkobject		     elf_or1k_mkobject
+
+#define bfd_elf32_bfd_merge_private_bfd_data elf32_or1k_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags or1k_elf_set_private_flags
+#define bfd_elf32_bfd_reloc_type_lookup or1k_reloc_type_lookup
+#define bfd_elf32_bfd_reloc_name_lookup or1k_reloc_name_lookup
+
+#define elf_backend_object_p                or1k_elf_object_p
+#define elf_backend_final_write_processing  or1k_elf_final_write_processing
+#define elf_backend_can_refcount    		1
+
+#define elf_backend_plt_readonly                1
+#define elf_backend_want_got_plt                1
+#define elf_backend_want_plt_sym                0
+#define elf_backend_got_header_size             12
+#define bfd_elf32_bfd_link_hash_table_create    or1k_elf_link_hash_table_create
+#define elf_backend_copy_indirect_symbol        or1k_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections     or1k_elf_create_dynamic_sections
+#define elf_backend_finish_dynamic_sections     or1k_elf_finish_dynamic_sections
+#define elf_backend_size_dynamic_sections       or1k_elf_size_dynamic_sections
+#define elf_backend_adjust_dynamic_symbol       or1k_elf_adjust_dynamic_symbol
+#define elf_backend_finish_dynamic_symbol       or1k_elf_finish_dynamic_symbol
+
+#include "elf32-target.h"
--- a/bfd/elf32-or32.c
+++ /dev/null
@@ -1,514 +0,0 @@
-/* OR32-specific support for 32-bit ELF
-   Copyright 2002, 2004, 2005, 2007 Free Software Foundation, Inc.
-   Contributed by Ivan Guzvinec  <ivang@opencores.org>
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include "bfd.h"
-#include "libbfd.h"
-#include "elf-bfd.h"
-#include "elf/or32.h"
-#include "libiberty.h"
-
-/* Try to minimize the amount of space occupied by relocation tables
-   on the ROM (not that the ROM won't be swamped by other ELF overhead).  */
-#define USE_REL	1
-
-/* Set the right machine number for an OR32 ELF file.  */
-
-static bfd_boolean
-or32_elf_object_p (bfd *abfd)
-{
-  (void) bfd_default_set_arch_mach (abfd, bfd_arch_or32, 0);
-  return TRUE;
-}
-
-/* The final processing done just before writing out an OR32 ELF object file.
-   This gets the OR32 architecture right based on the machine number.  */
-
-static void
-or32_elf_final_write_processing (bfd *abfd,
-				 bfd_boolean linker ATTRIBUTE_UNUSED)
-{
-  elf_elfheader (abfd)->e_flags &=~ EF_OR32_MACH;
-}
-
-static bfd_reloc_status_type
-or32_elf_32_reloc (bfd *abfd,
-		   arelent *reloc_entry,
-		   asymbol *symbol,
-		   void * data,
-		   asection *input_section,
-		   bfd *output_bfd,
-		   char **error_message ATTRIBUTE_UNUSED)
-{
-  if (output_bfd != NULL)
-    {
-      unsigned long insn;
-      bfd_size_type addr = reloc_entry->address;
-
-      reloc_entry->address += input_section->output_offset;
-
-      insn = bfd_get_32 (abfd, (bfd_byte *) data + addr);
-      insn += symbol->section->output_section->vma;
-      insn += symbol->section->output_offset;
-      insn += symbol->value;
-      bfd_put_32 (abfd, insn, (bfd_byte *) data + addr);
-
-      return bfd_reloc_ok;
-    }
-
-  return bfd_reloc_continue;
-}
-
-static bfd_reloc_status_type
-or32_elf_16_reloc (bfd *abfd,
-		   arelent *reloc_entry,
-		   asymbol *symbol,
-		   void * data,
-		   asection *input_section,
-		   bfd *output_bfd,
-		   char **error_message ATTRIBUTE_UNUSED)
-{
-  if (output_bfd != NULL)
-    {
-      unsigned short insn;
-      bfd_size_type addr = reloc_entry->address;
-
-      reloc_entry->address += input_section->output_offset;
-
-      insn = bfd_get_16 (abfd, (bfd_byte *) data + addr);
-      insn += symbol->section->output_section->vma;
-      insn += symbol->section->output_offset;
-      insn += symbol->value;
-      bfd_put_16 (abfd, insn, (bfd_byte *) data + addr);
-
-      return bfd_reloc_ok;
-    }
-
-  return bfd_reloc_continue;
-}
-
-static bfd_reloc_status_type
-or32_elf_8_reloc (bfd *abfd ATTRIBUTE_UNUSED,
-		  arelent *reloc_entry,
-		  asymbol *symbol,
-		  void * data,
-		  asection *input_section,
-		  bfd *output_bfd,
-		  char **error_message ATTRIBUTE_UNUSED)
-{
-  if (output_bfd != NULL)
-    {
-      unsigned char insn;
-      bfd_size_type addr = reloc_entry->address;
-
-      reloc_entry->address += input_section->output_offset;
-
-      insn = bfd_get_8 (abfd, (bfd_byte *) data + addr);
-      insn += symbol->section->output_section->vma;
-      insn += symbol->section->output_offset;
-      insn += symbol->value;
-      bfd_put_8 (abfd, insn, (bfd_byte *) data + addr);
-
-      return bfd_reloc_ok;
-    }
-
-  return bfd_reloc_continue;
-}
-
-/* Do a R_OR32_CONSTH relocation.  This has to be done in combination
-   with a R_OR32_CONST reloc, because there is a carry from the LO16 to
-   the HI16.  Here we just save the information we need; we do the
-   actual relocation when we see the LO16.  OR32 ELF requires that the
-   LO16 immediately follow the HI16.  As a GNU extension, we permit an
-   arbitrary number of HI16 relocs to be associated with a single LO16
-   reloc.  This extension permits gcc to output the HI and LO relocs
-   itself. This code is copied from the elf32-mips.c.  */
-
-struct or32_consth
-{
-  struct or32_consth *next;
-  bfd_byte *addr;
-  bfd_vma addend;
-};
-
-/* FIXME: This should not be a static variable.  */
-
-static struct or32_consth *or32_consth_list;
-
-static bfd_reloc_status_type
-or32_elf_consth_reloc (bfd *abfd ATTRIBUTE_UNUSED,
-		       arelent *reloc_entry,
-		       asymbol *symbol,
-		       void * data,
-		       asection *input_section,
-		       bfd *output_bfd,
-		       char **error_message ATTRIBUTE_UNUSED)
-{
-  bfd_reloc_status_type ret;
-  bfd_vma relocation;
-  struct or32_consth *n;
-
-  ret = bfd_reloc_ok;
-
-  if (bfd_is_und_section (symbol->section)
-      && output_bfd == NULL)
-    ret = bfd_reloc_undefined;
-
-  if (bfd_is_com_section (symbol->section))
-    relocation = 0;
-  else
-    relocation = symbol->value;
-
-  relocation += symbol->section->output_section->vma;
-  relocation += symbol->section->output_offset;
-  relocation += reloc_entry->addend;
-
-  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
-    return bfd_reloc_outofrange;
-
-  /* Save the information, and let LO16 do the actual relocation.  */
-  n = bfd_malloc (sizeof *n);
-  if (n == NULL)
-    return bfd_reloc_outofrange;
-  n->addr = (bfd_byte *) data + reloc_entry->address;
-  n->addend = relocation;
-  n->next = or32_consth_list;
-  or32_consth_list = n;
-
-  if (output_bfd != NULL)
-    reloc_entry->address += input_section->output_offset;
-
-  return ret;
-}
-
-/* Do a R_OR32_CONST relocation.  This is a straightforward 16 bit
-   inplace relocation; this function exists in order to do the
-   R_OR32_CONSTH relocation described above.  */
-
-static bfd_reloc_status_type
-or32_elf_const_reloc (bfd *abfd,
-		      arelent *reloc_entry,
-		      asymbol *symbol,
-		      void * data,
-		      asection *input_section,
-		      bfd *output_bfd,
-		      char **error_message)
-{
-  if (or32_consth_list != NULL)
-    {
-      struct or32_consth *l;
-
-      l = or32_consth_list;
-      while (l != NULL)
-	{
-	  unsigned long insn;
-	  unsigned long val;
-          unsigned long vallo;
-	  struct or32_consth *next;
-
-	  /* Do the HI16 relocation.  Note that we actually don't need
-	     to know anything about the LO16 itself, except where to
-	     find the low 16 bits of the addend needed by the LO16.  */
-	  insn = bfd_get_32 (abfd, l->addr);
-	  vallo = (bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address)
-		   & 0xffff);
-	  val = ((insn & 0xffff) << 16) + vallo;
-	  val += l->addend;
-
-	  insn = (insn &~ 0xffff) | ((val >> 16) & 0xffff);
-	  bfd_put_32 (abfd, insn, l->addr);
-
-	  next = l->next;
-	  free (l);
-	  l = next;
-	}
-
-      or32_consth_list = NULL;
-    }
-
-  if (output_bfd != NULL)
-    {
-      unsigned long insn, tmp;
-      bfd_size_type addr = reloc_entry->address;
-
-      reloc_entry->address += input_section->output_offset;
-
-      insn = bfd_get_32 (abfd, (bfd_byte *) data + addr);
-      tmp = insn & 0x0000ffff;
-      tmp += symbol->section->output_section->vma;
-      tmp += symbol->section->output_offset;
-      tmp += symbol->value;
-      insn = (insn & 0xffff0000) | (tmp & 0x0000ffff);
-      bfd_put_32 (abfd, insn, (bfd_byte *) data + addr);
-
-      return bfd_reloc_ok;
-    }
-
-  /* Now do the LO16 reloc in the usual way.  */
-  return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
-				input_section, output_bfd, error_message);
-}
-
-static bfd_reloc_status_type
-or32_elf_jumptarg_reloc (bfd *abfd,
-			 arelent *reloc_entry,
-			 asymbol *symbol ATTRIBUTE_UNUSED,
-			 void * data,
-			 asection *input_section,
-			 bfd *output_bfd,
-			 char **error_message ATTRIBUTE_UNUSED)
-{
-  if (output_bfd != NULL)
-    {
-      unsigned long insn, tmp;
-      bfd_size_type addr = reloc_entry->address;
-
-      reloc_entry->address += input_section->output_offset;
-
-      insn = bfd_get_32 (abfd, (bfd_byte *) data + addr);
-      tmp = insn | 0xfc000000;
-      tmp -= (input_section->output_offset >> 2);
-      insn = (insn & 0xfc000000) | (tmp & 0x03ffffff);
-      bfd_put_32 (abfd, insn, (bfd_byte *) data + addr);
-
-      return bfd_reloc_ok;
-    }
-
-  return bfd_reloc_continue;
-}
-
-static reloc_howto_type elf_or32_howto_table[] =
-{
-  /* This reloc does nothing.  */
-  HOWTO (R_OR32_NONE,		/* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 32,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 bfd_elf_generic_reloc,	/* special_function */
-	 "R_OR32_NONE",		/* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0,			/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A standard 32 bit relocation.  */
-  HOWTO (R_OR32_32,		/* type */
-	 0,	                /* rightshift */
-	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
-	 32,	                /* bitsize */
-	 FALSE,	                /* pc_relative */
-	 0,	                /* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 or32_elf_32_reloc, 	/* special_function */
-	 "R_OR32_32",		/* name */
-	 FALSE,	                /* partial_inplace */
-	 0xffffffff,	        /* src_mask */
-	 0xffffffff,   		/* dst_mask */
-	 FALSE),                /* pcrel_offset */
-
-  /* A standard 16 bit relocation.  */
-  HOWTO (R_OR32_16,		/* type */
-	 0,	                /* rightshift */
-	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
-	 16,	                /* bitsize */
-	 FALSE,	                /* pc_relative */
-	 0,	                /* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 or32_elf_16_reloc, 	/* special_function */
-	 "R_OR32_16",		/* name */
-	 FALSE,	                /* partial_inplace */
-	 0x0000ffff,	        /* src_mask */
-	 0x0000ffff,   		/* dst_mask */
-	 FALSE),                /* pcrel_offset */
-
-  /* A standard 8 bit relocation.  */
-  HOWTO (R_OR32_8,		/* type */
-	 0,	                /* rightshift */
-	 0,	                /* size (0 = byte, 1 = short, 2 = long) */
-	 8,	                /* bitsize */
-	 FALSE,	                /* pc_relative */
-	 0,	                /* bitpos */
-	 complain_overflow_bitfield, /* complain_on_overflow */
-	 or32_elf_8_reloc, 	/* special_function */
-	 "R_OR32_8",		/* name */
-	 FALSE,	                /* partial_inplace */
-	 0x000000ff,	        /* src_mask */
-	 0x000000ff,   		/* dst_mask */
-	 FALSE),                /* pcrel_offset */
-
-  /* A standard low 16 bit relocation.  */
-  HOWTO (R_OR32_CONST,		/* type */
-	 0,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 16,			/* bitsize */
-	 FALSE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont, /* complain_on_overflow */
-	 or32_elf_const_reloc,	/* special_function */
-	 "R_OR32_CONST",	/* name */
-	 FALSE,			/* partial_inplace */
-	 0x0000ffff,		/* src_mask */
-	 0x0000ffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A standard high 16 bit relocation.  */
-  HOWTO (R_OR32_CONSTH,		/* type */
-	 16,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 16,			/* bitsize */
-	 TRUE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_dont, /* complain_on_overflow */
-	 or32_elf_consth_reloc,	/* special_function */
-	 "R_OR32_CONSTH",	/* name */
-	 FALSE,			/* partial_inplace */
-	 0xffff0000,		/* src_mask */
-	 0x0000ffff,		/* dst_mask */
-	 FALSE),		/* pcrel_offset */
-
-  /* A standard branch relocation.  */
-  HOWTO (R_OR32_JUMPTARG,	/* type */
-	 2,			/* rightshift */
-	 2,			/* size (0 = byte, 1 = short, 2 = long) */
-	 28,			/* bitsize */
-	 TRUE,			/* pc_relative */
-	 0,			/* bitpos */
-	 complain_overflow_signed, /* complain_on_overflow */
-	 or32_elf_jumptarg_reloc,/* special_function */
-	 "R_OR32_JUMPTARG",	/* name */
-	 FALSE,			/* partial_inplace */
-	 0,			/* src_mask */
-	 0x03ffffff,		/* dst_mask */
-	 TRUE), 		/* pcrel_offset */
-
-  /* GNU extension to record C++ vtable hierarchy.  */
-  HOWTO (R_OR32_GNU_VTINHERIT, /* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         0,                     /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_dont, /* complain_on_overflow */
-         NULL,                  /* special_function */
-         "R_OR32_GNU_VTINHERIT", /* name */
-         FALSE,                 /* partial_inplace */
-         0,                     /* src_mask */
-         0,                     /* dst_mask */
-         FALSE),                /* pcrel_offset */
-
-  /* GNU extension to record C++ vtable member usage.  */
-  HOWTO (R_OR32_GNU_VTENTRY,     /* type */
-         0,                     /* rightshift */
-         2,                     /* size (0 = byte, 1 = short, 2 = long) */
-         0,                     /* bitsize */
-         FALSE,                 /* pc_relative */
-         0,                     /* bitpos */
-         complain_overflow_dont, /* complain_on_overflow */
-         _bfd_elf_rel_vtable_reloc_fn,  /* special_function */
-         "R_OR32_GNU_VTENTRY",   /* name */
-         FALSE,                 /* partial_inplace */
-         0,                     /* src_mask */
-         0,                     /* dst_mask */
-         FALSE),                /* pcrel_offset */
-};
-
-/* Map BFD reloc types to OR32 ELF reloc types.  */
-
-struct or32_reloc_map
-{
-  bfd_reloc_code_real_type  bfd_reloc_val;
-  unsigned char             elf_reloc_val;
-};
-
-static const struct or32_reloc_map or32_reloc_map[] =
-{
-  { BFD_RELOC_NONE, R_OR32_NONE },
-  { BFD_RELOC_32, R_OR32_32 },
-  { BFD_RELOC_16, R_OR32_16 },
-  { BFD_RELOC_8, R_OR32_8 },
-  { BFD_RELOC_LO16, R_OR32_CONST },
-  { BFD_RELOC_HI16, R_OR32_CONSTH },
-  { BFD_RELOC_32_GOT_PCREL, R_OR32_JUMPTARG },
-  { BFD_RELOC_VTABLE_INHERIT, R_OR32_GNU_VTINHERIT },
-  { BFD_RELOC_VTABLE_ENTRY, R_OR32_GNU_VTENTRY },
-};
-
-static reloc_howto_type *
-bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
-				 bfd_reloc_code_real_type code)
-{
-  unsigned int i;
-
-  for (i = ARRAY_SIZE (or32_reloc_map); i--;)
-    if (or32_reloc_map[i].bfd_reloc_val == code)
-      return &elf_or32_howto_table[or32_reloc_map[i].elf_reloc_val];
-
-  return NULL;
-}
-
-static reloc_howto_type *
-bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
-				 const char *r_name)
-{
-  unsigned int i;
-
-  for (i = 0;
-       i < sizeof (elf_or32_howto_table) / sizeof (elf_or32_howto_table[0]);
-       i++)
-    if (elf_or32_howto_table[i].name != NULL
-	&& strcasecmp (elf_or32_howto_table[i].name, r_name) == 0)
-      return &elf_or32_howto_table[i];
-
-  return NULL;
-}
-
-/* Set the howto pointer for an OR32 ELF reloc.  */
-
-static void
-or32_info_to_howto_rel (bfd *abfd ATTRIBUTE_UNUSED,
-			arelent *cache_ptr,
-			Elf_Internal_Rela *dst)
-{
-  unsigned int r_type;
-
-  r_type = ELF32_R_TYPE (dst->r_info);
-  BFD_ASSERT (r_type < (unsigned int) R_OR32_max);
-  cache_ptr->howto = &elf_or32_howto_table[r_type];
-}
-
-#define TARGET_LITTLE_SYM	bfd_elf32_or32_little_vec
-#define TARGET_LITTLE_NAME	"elf32-littleor32"
-#define TARGET_BIG_SYM		bfd_elf32_or32_big_vec
-#define TARGET_BIG_NAME		"elf32-or32"
-#define ELF_ARCH		bfd_arch_or32
-#define ELF_MACHINE_CODE	EM_OR32
-#define ELF_MAXPAGESIZE		0x1000
-
-#define elf_info_to_howto	0
-#define elf_info_to_howto_rel	or32_info_to_howto_rel
-#define elf_backend_object_p	or32_elf_object_p
-#define elf_backend_final_write_processing \
-				or32_elf_final_write_processing
-
-#include "elf32-target.h"
--- a/bfd/libbfd.h
+++ b/bfd/libbfd.h
@@ -2355,8 +2355,30 @@
   "BFD_RELOC_860_HIGH",
   "BFD_RELOC_860_HIGOT",
   "BFD_RELOC_860_HIGOTOFF",
-  "BFD_RELOC_OPENRISC_ABS_26",
-  "BFD_RELOC_OPENRISC_REL_26",
+  "BFD_RELOC_OR1K_REL_26",
+  "BFD_RELOC_OR1K_GOTPC_HI16",
+  "BFD_RELOC_OR1K_GOTPC_LO16",
+  "BFD_RELOC_OR1K_GOT16",
+  "BFD_RELOC_OR1K_PLT26",
+  "BFD_RELOC_OR1K_GOTOFF_HI16",
+  "BFD_RELOC_OR1K_GOTOFF_LO16",
+  "BFD_RELOC_OR1K_COPY",
+  "BFD_RELOC_OR1K_GLOB_DAT",
+  "BFD_RELOC_OR1K_JMP_SLOT",
+  "BFD_RELOC_OR1K_RELATIVE",
+  "BFD_RELOC_OR1K_TLS_GD_HI16",
+  "BFD_RELOC_OR1K_TLS_GD_LO16",
+  "BFD_RELOC_OR1K_TLS_LDM_HI16",
+  "BFD_RELOC_OR1K_TLS_LDM_LO16",
+  "BFD_RELOC_OR1K_TLS_LDO_HI16",
+  "BFD_RELOC_OR1K_TLS_LDO_LO16",
+  "BFD_RELOC_OR1K_TLS_IE_HI16",
+  "BFD_RELOC_OR1K_TLS_IE_LO16",
+  "BFD_RELOC_OR1K_TLS_LE_HI16",
+  "BFD_RELOC_OR1K_TLS_LE_LO16",
+  "BFD_RELOC_OR1K_TLS_TPOFF",
+  "BFD_RELOC_OR1K_TLS_DTPOFF",
+  "BFD_RELOC_OR1K_TLS_DTPMOD",
   "BFD_RELOC_H8_DIR16A8",
   "BFD_RELOC_H8_DIR16R8",
   "BFD_RELOC_H8_DIR24A8",
--- a/bfd/reloc.c
+++ b/bfd/reloc.c
@@ -5599,11 +5599,55 @@
   Intel i860 Relocations.
 
 ENUM
-  BFD_RELOC_OPENRISC_ABS_26
+  BFD_RELOC_OR1K_REL_26
 ENUMX
-  BFD_RELOC_OPENRISC_REL_26
+  BFD_RELOC_OR1K_GOTPC_HI16
+ENUMX
+  BFD_RELOC_OR1K_GOTPC_LO16
+ENUMX
+  BFD_RELOC_OR1K_GOT16
+ENUMX
+  BFD_RELOC_OR1K_PLT26
+ENUMX
+  BFD_RELOC_OR1K_GOTOFF_HI16
+ENUMX
+  BFD_RELOC_OR1K_GOTOFF_LO16
+ENUMX
+  BFD_RELOC_OR1K_COPY
+ENUMX
+  BFD_RELOC_OR1K_GLOB_DAT
+ENUMX
+  BFD_RELOC_OR1K_JMP_SLOT
+ENUMX
+  BFD_RELOC_OR1K_RELATIVE
+ENUMX
+  BFD_RELOC_OR1K_TLS_GD_HI16
+ENUMX
+  BFD_RELOC_OR1K_TLS_GD_LO16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LDM_HI16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LDM_LO16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LDO_HI16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LDO_LO16
+ENUMX
+  BFD_RELOC_OR1K_TLS_IE_HI16
+ENUMX
+  BFD_RELOC_OR1K_TLS_IE_LO16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LE_HI16
+ENUMX
+  BFD_RELOC_OR1K_TLS_LE_LO16
+ENUMX
+  BFD_RELOC_OR1K_TLS_TPOFF
+ENUMX
+  BFD_RELOC_OR1K_TLS_DTPOFF
+ENUMX
+  BFD_RELOC_OR1K_TLS_DTPMOD
 ENUMDOC
-  OpenRISC Relocations.
+  OpenRISC 1000 Relocations.
 
 ENUM
   BFD_RELOC_H8_DIR16A8
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -673,8 +673,7 @@
 extern const bfd_target bfd_elf32_ntradlittlemips_vec;
 extern const bfd_target bfd_elf32_ntradbigmips_freebsd_vec;
 extern const bfd_target bfd_elf32_ntradlittlemips_freebsd_vec;
-extern const bfd_target bfd_elf32_openrisc_vec;
-extern const bfd_target bfd_elf32_or32_big_vec;
+extern const bfd_target bfd_elf32_or1k_vec;
 extern const bfd_target bfd_elf32_pj_vec;
 extern const bfd_target bfd_elf32_pjl_vec;
 extern const bfd_target bfd_elf32_powerpc_vec;
@@ -840,7 +839,6 @@
 extern const bfd_target nlm32_powerpc_vec;
 extern const bfd_target nlm32_sparc_vec;
 extern const bfd_target oasys_vec;
-extern const bfd_target or32coff_big_vec;
 extern const bfd_target pc532machaout_vec;
 extern const bfd_target pc532netbsd_vec;
 extern const bfd_target pdp11_aout_vec;
@@ -1061,8 +1059,7 @@
 	&bfd_elf32_ntradbigmips_freebsd_vec,
 	&bfd_elf32_ntradlittlemips_freebsd_vec,
 #endif
-	&bfd_elf32_openrisc_vec,
-	&bfd_elf32_or32_big_vec,
+	&bfd_elf32_or1k_vec,
 	&bfd_elf32_pj_vec,
 	&bfd_elf32_pjl_vec,
 	&bfd_elf32_powerpc_vec,
@@ -1272,8 +1269,6 @@
 	   can be annoying target mis-matches.  */
 	&oasys_vec,
 #endif
-	/* Entry for the OpenRISC family.  */
-	&or32coff_big_vec,
 
 	&pc532machaout_vec,
 	&pc532netbsd_vec,
--- a/binutils/readelf.c
+++ b/binutils/readelf.c
@@ -132,7 +132,7 @@
 #include "elf/mt.h"
 #include "elf/msp430.h"
 #include "elf/nios2.h"
-#include "elf/or32.h"
+#include "elf/or1k.h"
 #include "elf/pj.h"
 #include "elf/ppc.h"
 #include "elf/ppc64.h"
@@ -579,8 +579,6 @@
     case EM_MIPS:
     case EM_MIPS_RS3_LE:
     case EM_CYGNUS_M32R:
-    case EM_OPENRISC:
-    case EM_OR32:
     case EM_SCORE:
     case EM_XGATE:
       return FALSE;
@@ -627,6 +625,7 @@
     case EM_MSP430_OLD:
     case EM_MT:
     case EM_NIOS32:
+    case EM_OR1K:
     case EM_PPC64:
     case EM_PPC:
     case EM_RL78:
@@ -1179,9 +1178,8 @@
 	  rtype = elf_h8_reloc_type (type);
 	  break;
 
-	case EM_OPENRISC:
-	case EM_OR32:
-	  rtype = elf_or32_reloc_type (type);
+	case EM_OR1K:
+	  rtype = elf_or1k_reloc_type (type);
 	  break;
 
 	case EM_PJ:
@@ -2008,8 +2006,7 @@
     case EM_S390:		return "IBM S/390";
     case EM_SCORE:		return "SUNPLUS S+Core";
     case EM_XSTORMY16:		return "Sanyo XStormy16 CPU core";
-    case EM_OPENRISC:
-    case EM_OR32:		return "OpenRISC";
+    case EM_OR1K:		return "OpenRISC 1000";
     case EM_ARC_A5:		return "ARC International ARCompact processor";
     case EM_CRX:		return "National Semiconductor CRX microprocessor";
     case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
@@ -2682,6 +2679,11 @@
 	  if (e_flags & EF_SH_FDPIC)
 	    strcat (buf, ", fdpic");
 	  break;
+          
+        case EM_OR1K:
+          if (e_flags & EF_OR1K_NODELAY)
+            strcat (buf, ", no delay");
+          break;
 
 	case EM_SPARCV9:
 	  if (e_flags & EF_SPARC_32PLUS)
@@ -10261,9 +10263,8 @@
       return reloc_type == 12; /* R_NIOS2_BFD_RELOC_32.  */
     case EM_NIOS32:
       return reloc_type == 1; /* R_NIOS_32.  */
-    case EM_OPENRISC:
-    case EM_OR32:
-      return reloc_type == 1; /* R_OR32_32.  */
+    case EM_OR1K:
+      return reloc_type == 1; /* R_OR1K_32.  */
     case EM_PARISC:
       return (reloc_type == 1 /* R_PARISC_DIR32.  */
 	      || reloc_type == 41); /* R_PARISC_SECREL32.  */
@@ -10351,6 +10352,8 @@
       return reloc_type == 3;  /* R_ARM_REL32 */
     case EM_MICROBLAZE:
       return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
+    case EM_OR1K:
+      return reloc_type == 9; /* R_OR1K_32_PCREL.  */
     case EM_PARISC:
       return reloc_type == 9;  /* R_PARISC_PCREL32.  */
     case EM_PPC:
@@ -10510,6 +10513,8 @@
 	return reloc_type == 2; /* R_MSP430_ABS16.  */
     case EM_MSP430_OLD:
       return reloc_type == 5; /* R_MSP430_16_BYTE.  */
+    case EM_OR1K:
+      return reloc_type == 2; /* R_OR1K_16.  */
     case EM_ALTERA_NIOS2:
       return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
     case EM_NIOS32:
@@ -10570,6 +10575,7 @@
     case EM_C166:    /* R_XC16X_NONE.  */
     case EM_ALTERA_NIOS2: /* R_NIOS2_NONE.  */
     case EM_NIOS32:  /* R_NIOS_NONE.  */
+    case EM_OR1K:    /* R_OR1K_NONE. */
       return reloc_type == 0;
     case EM_AARCH64:
       return reloc_type == 0 || reloc_type == 256;
--- a/binutils/testsuite/binutils-all/objcopy.exp
+++ b/binutils/testsuite/binutils-all/objcopy.exp
@@ -86,7 +86,6 @@
 	setup_xfail "m68*-*-*coff" "m68*-*-hpux*" "m68*-*-lynxos*"
 	setup_xfail "m68*-*-sysv*" "m68*-apple-aux*"
 	setup_xfail "m8*-*"
-	setup_xfail "or32-*-rtems*" "or32-*-coff"
 	setup_xfail "sh-*-coff*"
 	setup_xfail "tic80-*-*" "w65-*"
 
--- a/binutils/testsuite/binutils-all/objdump.exp
+++ b/binutils/testsuite/binutils-all/objdump.exp
@@ -39,8 +39,8 @@
 lappend cpus_expected aarch64 alpha arc arm cris
 lappend cpus_expected d10v d30v fr30 fr500 fr550 h8 hppa i386 i860 i960 ip2022
 lappend cpus_expected m16c m32c m32r m68hc11 m68hc12 m68k m88k MCore MicroBlaze
-lappend cpus_expected mips mn10200 mn10300 ms1 msp ns32k pj powerpc pyramid
-lappend cpus_expected romp rs6000 s390 sh sparc
+lappend cpus_expected mips mn10200 mn10300 ms1 msp ns32k or1k or1knd pj powerpc
+lappend cpus_expected pyramid romp rs6000 s390 sh sparc
 lappend cpus_expected tahoe tic54x tic80 tilegx tms320c30 tms320c4x tms320c54x
 lappend cpus_expected v850 vax we32k x86-64 xscale xtensa z8k z8001 z8002
 
@@ -203,7 +203,7 @@
 }
 
 # Test objdump -WL on a file that contains line information for multiple files and search directories.
-# Not supported on mcore, moxie and openrisc targets because they do not (yet) support the generation
+# Not supported on mcore and moxie targets because they do not (yet) support the generation
 # of DWARF2 line debug information.
 
 if { ![is_elf_format]
@@ -213,12 +213,15 @@
      || [istarget "ia64*-*-*"]
      || [istarget "mcore-*-*"]
      || [istarget "moxie-*-*"]
-     || [istarget "openrisc-*-*"]
-     || [istarget "or32-*-*"]
 } then {
     unsupported "objump decode line"
 } else {
-    if { ![binutils_assemble $srcdir/$subdir/dw2-decodedline.S tmpdir/dw2-decodedline.o] } then {
+    if { [istarget "or1k*-*-*"] } then {
+        set decodedline_testsrc $srcdir/$subdir/dw2-decodedline-1.S
+    } else {
+        set decodedline_testsrc $srcdir/$subdir/dw2-decodedline.S
+    }
+    if { ![binutils_assemble $decodedline_testsrc tmpdir/dw2-decodedline.o] } then {
 	fail "objdump decoded line"
     }
 
--- a/config.guess
+++ b/config.guess
@@ -975,6 +975,9 @@
     or32:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
 	exit ;;
+    or1knd:Linux:*:*)
+	echo or1knd-unknown-linux-gnu
+	exit ;;
     padre:Linux:*:*)
 	echo sparc-unknown-linux-${LIBC}
 	exit ;;
--- a/config.sub
+++ b/config.sub
@@ -297,7 +297,7 @@
 	| nios | nios2 | nios2eb | nios2el \
 	| ns16k | ns32k \
 	| open8 \
-	| or1k | or32 \
+	| or1k | or1knd | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
@@ -920,9 +920,6 @@
 		basic_machine=hppa1.1-oki
 		os=-proelf
 		;;
-	openrisc | openrisc-*)
-		basic_machine=or32-unknown
-		;;
 	os400)
 		basic_machine=powerpc-ibm
 		os=-os400
@@ -1594,7 +1591,7 @@
 	mips*-*)
 		os=-elf
 		;;
-	or1k-*)
+	or1k-* | or1knd-*)
 		os=-elf
 		;;
 	or32-*)
--- a/cpu/openrisc.cpu
+++ /dev/null
@@ -1,774 +0,0 @@
-; OpenRISC family.  -*- Scheme -*-
-; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
-; Contributed by Johan Rydberg, jrydberg@opencores.org
-;
-; This program is free software; you can redistribute it and/or modify
-; it under the terms of the GNU General Public License as published by
-; the Free Software Foundation; either version 2 of the License, or
-; (at your option) any later version.
-;
-; This program is distributed in the hope that it will be useful,
-; but WITHOUT ANY WARRANTY; without even the implied warranty of
-; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-; GNU General Public License for more details.
-;
-; You should have received a copy of the GNU General Public License
-; along with this program; if not, write to the Free Software
-; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
-
-(include "simplify.inc")
-
-; OpenRISC 1000 is an architecture of a family of open source, 
-; synthesizeable RISC microprocessor cores. It is a 32-bit load 
-; and  store RISC architecture designed  with emphasis on speed,
-; compact instruction set and scalability. OpenRISC 1000 targets
-; wide range of embedded environments. 
-
-(define-arch
-  (name openrisc)
-  (comment "OpenRISC 1000")
-  (insn-lsb0? #t)
-  (machs openrisc or1300)
-  (isas or32)
-)
-
-
-; Attributes
-
-; An attribute to describe if a model has insn and/or data caches.
-(define-attr
-  (for model)
-  (type enum)
-  (name HAS-CACHE)
-  (comment "if this model has caches")
-  (values DATA-CACHE INSN-CACHE)
-)
-
-; An attribute to describe if an insn can be in the delay slot or not.
-(define-attr
-  (for insn)
-  (type boolean)
-  (name NOT-IN-DELAY-SLOT)
-  (comment "insn can't go in delay slot")
-)
-
-; IDOC attribute for instruction documentation.
-
-(define-attr
-  (for insn)
-  (type enum)
-  (name IDOC)
-  (comment "insn kind for documentation")
-  (attrs META)
-  (values
-   (MEM - () "Memory")
-   (ALU - () "ALU")
-   (FPU - () "FPU")
-   (BR - () "Branch")
-   (PRIV - () "Priviledged")
-   (MISC - () "Miscellaneous")
-  )
-)
-
-; Enum for exception vectors.
-(define-enum
-  (name e-exception)
-  (comment "exception vectors")
-  (attrs)
-  (prefix E_)
-  (values (("RESET") ("BUSERR" -) ("DPF" -) ("IPF" -) ("EXTINT" -) ("ALIGN" -) 
-          ("ILLEGAL" -) ("PEINT" -) ("DTLBMISS" -) ("ITLBMISS" -) ("RRANGE" -) 
-          ("SYSCALL" -) ("BREAK" -) ("RESERVED" -)))
-)
-
-
-; Instruction set parameters.
- 
-(define-isa
-  ; Name of the ISA.
-  (name or32)
-
-  ; Base insturction length.  The insns is always 32 bits wide.
-  (base-insn-bitsize 32)
-
-  ; Address of insn in delay slot
-  (setup-semantics (set-quiet (reg h-delay-insn) (add pc 4)))
-)
-
-
-; CPU family definitions.
-  
-(define-cpu
-  ; CPU names must be distinct from the architecture name and machine names.
-  ; The "b" suffix stands for "base" and is the convention.
-  ; The "f" suffix stands for "family" and is the convention.
-  (name openriscbf)
-  (comment "OpenRISC base family")
-  (endian big)
-  (word-bitsize 32)
-)
-
-; Generic machine
-(define-mach
-  (name openrisc)
-  (comment "Generic OpenRISC cpu")
-  (cpu openriscbf)
-  (bfd-name "openrisc")
-)
-
-; OpenRISC 1300 machine
-(define-mach
-  (name or1300)
-  (comment "OpenRISC 1300")
-  (cpu openriscbf)
-  (bfd-name "openrisc:1300")
-)
-
-
-; Model descriptions
-
-; Generic OpenRISC model 
-(define-model
-  (name openrisc-1) (comment "OpenRISC generic model")  (attrs)
-  (mach openrisc)
-
-  ; Nothing special about this.
-  (unit u-exec "Execution Unit" () 1 1 () () () ())
-)
-
-; OpenRISC 1320 
-(define-model
-  (name or1320-1) (comment "OpenRISC 1320 model") 
-
-  ; This model has both instruction and data cache
-  (attrs (HAS-CACHE INSN-CACHE,DATA-CACHE))
-  (mach or1300)
-
-  ; Nothing special about this.
-  (unit u-exec "Execution Unit" () 1 1 () () () ())
-)
-
-
-; Instruction fields.
-
-; Attributes:
-;  . PCREL-ADDR  pc relative value (for reloc and disassembly purposes)
-;  . ABS-ADDR    absolute address (for reloc and disassembly purposes?)
-;  . RESERVED    bits are not used to decode insn, must be all 0
-
-; Instruction classes.
-(dnf f-class     "insn class"          () 31 2)
-(dnf f-sub       "sub class"           () 29 4)
-
-; Register fields.
-(dnf f-r1        "r1"                  () 25 5)
-(dnf f-r2        "r2"                  () 20 5)
-(dnf f-r3        "r3"                  () 15 5)
-
-; Immediates.
-(df  f-simm16    "signed imm (16)"     () 15 16 INT #f #f)
-(dnf f-uimm16    "unsigned imm (16)"   () 15 16)
-(dnf f-uimm5     "unsigned imm (5)"    () 4  5)
-(df  f-hi16      "high 16"             () 15 16 INT #f #f)
-(df  f-lo16      "low 16"              () 15 16 INT #f #f)
-
-; Sub fields
-(dnf f-op1       "op1"                 () 31 2)
-(dnf f-op2       "op2"                 () 29 4)
-(dnf f-op3       "op3"                 () 25 2)
-(dnf f-op4       "op4"                 () 23 3)
-(dnf f-op5       "op3"                 () 25 5)
-(dnf f-op6       "op4"                 () 7  3)
-(dnf f-op7       "op5"                 () 3  4)
-
-(dnf f-i16-1     "uimm16-1"            () 10 11)
-(dnf f-i16-2     "uimm16-2"            () 25  5)
-
-; PC relative, 26-bit (2 shifted to right)
-(df f-disp26     "disp26"              (PCREL-ADDR) 25 26 INT
-    ((value pc) (sra WI (sub WI value pc) (const 2)))
-    ((value pc) (add WI (sll WI value (const 2)) pc)))
-
-; absolute, 26-bit (2 shifted to right)
-(df f-abs26      "abs26"               (ABS-ADDR) 25 26 INT
-    ((value pc) (sra WI pc     (const 2)))
-    ((value pc) (sll WI value  (const 2))))
-
-(define-multi-ifield
-  (name f-i16nc)
-  (comment "16 bit signed")
-  (attrs SIGN-OPT)
-  (mode HI)
-  (subfields f-i16-1 f-i16-2)
-  (insert (sequence ()
-                    (set (ifield f-i16-2) (and (sra (ifield f-i16nc) 
-                                                    (const 11)) 
-                                               (const #x1f)))
-                    (set (ifield f-i16-1) (and (ifield f-i16nc) 
-                                               (const #x7ff)))))
-  (extract (sequence ()
-                     (set (ifield f-i16nc) (c-raw-call SI "@arch@_sign_extend_16bit" 
-                                           (or (sll (ifield f-i16-2) 
-                                                    (const 11))
-                                               (ifield f-i16-1))))))
-)
-
-
-; Enums.
-
-; insn-class: bits 31-30
-(define-normal-insn-enum insn-class "FIXME" () OP1_ f-class
-  (.map .str (.iota 4))
-)
-
-(define-normal-insn-enum insn-sub "FIXME" () OP2_ f-sub
-  (.map .str (.iota 16))
-)
-
-(define-normal-insn-enum insn-op3 "FIXME" () OP3_ f-op3
-  (.map .str (.iota 4))
-)
-
-(define-normal-insn-enum insn-op4 "FIXME" () OP4_ f-op4
-  (.map .str (.iota 8))
-)
-
-(define-normal-insn-enum insn-op5  "FIXME" () OP5_ f-op5
-  (.map .str (.iota 32))
-)
-
-(define-normal-insn-enum insn-op6  "FIXME" () OP6_ f-op6
-  (.map .str (.iota 8))
-)
-
-(define-normal-insn-enum insn-op7  "FIXME" () OP7_ f-op7
-  (.map .str (.iota 16))
-)
-
-
-
-; Hardware pieces.
-; These entries list the elements of the raw hardware.
-; They're also used to provide tables and other elements of the assembly
-; language.
-
-(dnh h-pc "program counter" (PC PROFILE) (pc) () () ())
-
-(define-hardware
-  (name h-gr) (comment "general registers") (attrs PROFILE)
-  (type register WI (32))
-  (indices keyword ""
-           ((r0 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (r6 6) (r7 7)
-            (r8 8) (r9 9) (r10 10) (r11 11) (r12 12) (r13 13) (r14 14) 
-            (r15 15) (r16 16) (r17 17) (r18 18) (r19 19) (r20 20) 
-            (r21 21) (r22 22) (r23 23) (r24 24) (r25 25) (r26 26) 
-            (r27 27) (r28 28) (r29 29) (r30 30) (r31 31) (lr 11) 
-            (sp 1)  (fp 2)))
-)
-
-(define-hardware
-  (name h-sr) (comment "special registers")
-  (type register WI (#x20000))    
-  (get (index) (c-call SI "@arch@_h_sr_get_handler" index))
-  (set (index newval) (c-call VOID "@arch@_h_sr_set_handler" index newval))
-)
-
-(dnh h-hi16 "high 16 bits" () (immediate (INT 16)) () () ())
-(dnh h-lo16 "low 16 bits"  () (immediate (INT 16)) () () ())
-
-(dsh h-cbit "condition bit" () (register BI))
-(dsh h-delay-insn "delay insn addr" () (register SI))
-
-
-; Instruction operands.
-
-(dnop sr      "special register"           (SEM-ONLY)  h-sr   f-nil)
-(dnop cbit    "condition bit"              (SEM-ONLY)  h-cbit f-nil)
-(dnop simm-16 "16 bit signed immediate"    ()          h-sint f-simm16)
-(dnop uimm-16 "16 bit unsigned immediate"  ()          h-uint f-uimm16)
-(dnop disp-26 "pc-rel 26 bit"              ()          h-iaddr f-disp26)
-(dnop abs-26  "abs 26 bit"                 ()          h-iaddr f-abs26)
-(dnop uimm-5  "imm5"                       ()          h-uint f-uimm5)
-
-(dnop rD      "destination register"       ()          h-gr   f-r1)
-(dnop rA      "source register A"          ()          h-gr   f-r2)
-(dnop rB      "source register B"          ()          h-gr   f-r3)
-
-(dnop op-f-23 "f-op23"                     ()          h-uint f-op4)
-(dnop op-f-3  "f-op3"                      ()          h-uint f-op5)
-
-; For hi(foo).
-(define-operand
-  (name hi16) (comment "high 16 bit immediate, sign optional") 
-  (attrs SIGN-OPT)
-  (type h-hi16)
-  (index f-simm16)
-  (handlers (parse "hi16"))
-)
-
-; For lo(foo)
-(define-operand
-  (name lo16) (comment "low 16 bit immediate, sign optional")
-  (attrs SIGN-OPT)
-  (type h-lo16)
-  (index f-lo16)
-  (handlers (parse "lo16"))
-)
-
-(define-operand
-  (name ui16nc)
-  (comment "16 bit immediate, sign optional")
-  (attrs)
-  (type h-lo16)
-  (index f-i16nc)
-  (handlers (parse "lo16"))
-)
-
-
-; Instructions.
-
-; Branch releated instructions 
-
-(dni l-j "jump (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT) 
-
-     "l.j ${abs-26}"
-     (+ OP1_0 OP2_0 abs-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (delay 1 (set pc abs-26))
-     ()
-)
-
-(dni l-jal "jump and link (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jal ${abs-26}"
-     (+ OP1_0 OP2_1 abs-26)
-
-     ; We execute the delay slot before doin' the real branch
-     ; Set LR to (delay insn addr + 4)
-     (sequence ()
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc abs-26)))
-     ()
-)
-
-(dni l-jr "jump register (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jr $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_0 rA uimm-16)
-
-     ; We execute the delay slot before doin' the real branch
-     (delay 1 (set pc rA))
-     ()
-)
-
-(dni l-jalr "jump register and link (absolute iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.jalr $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_1 rA uimm-16)
-
-     ; We save the value of rA in a temporary slot before setting
-     ; the link register.  This because "l.jalr r11" would cause
-     ; a forever-and-ever loop otherwise.
-     ;
-     ; We execute the delay slot before doin' the real branch
-     (sequence ((WI tmp-slot))
-               (set tmp-slot rA)
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc tmp-slot)))
-     ()
-)
-
-(dni l-bal "branch and link (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bal ${disp-26}"
-     (+ OP1_0 OP2_2 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     ; Set LR to (delay insn addr + 4)
-     (sequence ()
-               (set (reg h-gr 11) (add (reg h-delay-insn) 4))
-               (delay 1 (set pc disp-26)))
-     ()
-)
-
-(dni l-bnf "branch if condition bit not set (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bnf ${disp-26}"
-     (+ OP1_0 OP2_3 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (if (eq cbit 0)
-         (sequence ()
-                   (delay 1 (set pc disp-26))))
-     ()
-)
-
-(dni l-bf "branch if condition bit is set (pc relative iaddr)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.bf ${disp-26}"
-     (+ OP1_0 OP2_4 disp-26)
-
-     ; We execute the delay slot before doin' the real branch
-     (if (eq cbit 1)
-         (sequence ()
-                   (delay 1 (set pc disp-26))))
-     ()
-)
-
-(dni l-brk "break (exception)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.brk ${uimm-16}"
-     (+ OP1_0 OP2_5 OP3_3 OP4_0 rA uimm-16)
-
-     ; FIXME should we do it like this ??
-     (c-call VOID "@cpu@_cpu_brk" uimm-16)
-     ()
-)
-
-(dni l-rfe "return from exception"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.rfe $rA"
-     (+ OP1_0 OP2_5 OP3_0 OP4_2 rA uimm-16)
-     (sequence ()
-               (delay 1 (set pc (c-call SI "@cpu@_cpu_rfe" rA))))
-     ()
-)
-
-(dni l-sys "syscall (exception)"
-     ; This function may not be in delay slot
-     (NOT-IN-DELAY-SLOT)
-
-     "l.sys ${uimm-16}"
-     (+ OP1_0 OP2_5 OP3_2 OP4_0 rA uimm-16)
-     (sequence()
-              (delay 1 (set pc (c-call SI "@cpu@_except" pc 
-                                       #xc00 uimm-16))))
-     ()
-)
-
-
-; Misc instructions
-
-(dni l-nop "nop"
-     ()
-     "l.nop"
-     (+ OP1_0 OP2_5 OP3_1 OP4_0 rA uimm-16)
-     (nop)
-     ()
-)
-
-(dnmi l-ret "ret" ()
-      "l.ret"
-      (emit l-jr (rA 11) (uimm-16 0))
-)
-
-(dni l-movhi "movhi"
-     (DELAY-SLOT)
-     "l.movhi $rD,$hi16"
-     (+ OP1_0 OP2_6 hi16 rD rA)
-     (set rD (sll WI hi16 (const 16)))
-     ()
-)
-
-
-; System releated instructions
-
-(dni l-mfsr "mfsr"
-     (DELAY-SLOT)
-     "l.mfsr $rD,$rA"
-     (+ OP1_0 OP2_7 rD rA uimm-16)
-     (set rD (c-call SI "@cpu@_cpu_mfsr" rA))
-     ()
-)
-
-(dni l-mtsr "mtsr"
-     (DELAY-SLOT)
-     "l.mtsr $rA,$rB"
-     (+ OP1_1 OP2_0 rA rB rD (f-i16-1 0))
-     (c-call VOID "@cpu@_cpu_mtsr" rA rB)
-     ()
-)
-
-
-
-; Load instructions
-
-(dni l-lw "load word"
-     (DELAY-SLOT)
-     "l.lw $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_0 rD rA simm-16)
-     (set rD (mem SI (add rA simm-16)))
-     ()
-)
-
-(dni l-lbz "load byte (zero extend)"
-     (DELAY-SLOT)
-     "l.lbz $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_1 rD rA simm-16)
-     (set rD (zext SI (mem QI (add rA simm-16))))
-     ()
-)
-
-(dni l-lbs "load byte (sign extend)"
-     (DELAY-SLOT)
-     "l.lbs $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_2 rD rA simm-16)
-     (set rD (ext SI (mem QI (add rA simm-16))))
-     ()
-)
-
-(dni l-lhz "load halfword (zero extend)"
-     (DELAY-SLOT)
-     "l.lhz $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_3 rD simm-16 rA)
-     (set rD (zext SI (mem HI (add rA simm-16))))
-     ()
-)
-
-(dni l-lhs "load halfword (sign extend)"
-     (DELAY-SLOT)
-     "l.lhs $rD,${simm-16}($rA)"
-     (+ OP1_2 OP2_4 rD rA simm-16)
-     (set rD (ext SI (mem HI (add rA simm-16))))
-     ()
-)
-
-
-; Store instructions
-;
-; We have to use a multi field since the integer is splited over 2 fields
-
-(define-pmacro (store-insn mnemonic op2-op mode-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " imm(reg)/reg")
-          (DELAY-SLOT)
-          (.str "l." mnemonic " ${ui16nc}($rA),$rB")
-          (+ OP1_3 op2-op rB rD ui16nc)
-          (set (mem mode-op (add rA ui16nc)) rB)
-          ()
-     )
-   )
-)
-
-(store-insn sw OP2_5 SI)
-(store-insn sb OP2_6 QI)
-(store-insn sh OP2_7 HI)
-
-
-
-; Shift and rotate instructions
-
-; Reserved fields.
-(dnf f-f-15-8 "nop" (RESERVED) 15 8)
-(dnf f-f-10-3 "nop" (RESERVED) 10 3)
-(dnf f-f-4-1  "nop" (RESERVED) 4  1)
-(dnf f-f-7-3  "nop" (RESERVED) 7  3)
-
-(define-pmacro (shift-insn mnemonic op4-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-3 0) op4-op (f-f-4-1 0) OP7_8)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/imm")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,${uimm-5}")
-          (+ OP1_2 OP2_13 rD rA (f-f-15-8 0) op4-op uimm-5)
-          (set rD (mnemonic rA uimm-5))
-          ()
-     )
-   )
-)
-
-(shift-insn sll OP6_0)
-(shift-insn srl OP6_1)
-(shift-insn sra OP6_2)
-(shift-insn ror OP6_4)
-
-
-; Arethmetic insns
-
-; Reserved fields.
-(dnf f-f-10-7 "nop" (RESERVED) 10 7)
-
-(define-pmacro (ar-insn-u mnemonic op2-op op5-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) op5-op)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/lo16")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,$lo16")
-          (+ OP1_2 op2-op rD rA lo16)
-          (set rD (mnemonic rA (and lo16 #xffff)))
-          ()
-     )
-   )
-)
-
-(define-pmacro (ar-insn-s mnemonic op2-op op5-op)
-  (begin
-     (dni (.sym l- mnemonic)
-          (.str "l." mnemonic " reg/reg/reg")
-          ()
-          (.str "l." mnemonic " $rD,$rA,$rB")
-          (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) op5-op)
-          (set rD (mnemonic rA rB))
-          ()
-     )
-     (dni (.sym l- mnemonic "i")
-          (.str "l." mnemonic " reg/reg/lo16")
-          ()
-          (.str "l." mnemonic "i $rD,$rA,$lo16")
-          (+ OP1_2 op2-op rD rA lo16)
-          (set rD (mnemonic rA lo16))
-          ()
-     )
-   )
-)
-
-(ar-insn-s add OP2_5  OP7_0)
-;;(ar-op-s addc OP2_5  OP7_0)
-(ar-insn-s sub OP2_7  OP7_2)
-(ar-insn-u and OP2_8  OP7_3)
-(ar-insn-u or  OP2_9  OP7_4)
-(ar-insn-u xor OP2_10 OP7_5)
-(ar-insn-u mul OP2_11 OP7_6)
-;;(ar-op-u mac OP2_12 OP7_7)
-
-
-(dni l-div "divide (signed)"
-     (DELAY-SLOT)
-     "l.div $rD,$rA,$rB"
-     (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) OP7_9)
-     (if VOID (eq rB (const 0))
-         (c-call VOID "@arch@_cpu_trap" pc (enum SI E_ILLEGAL))
-         (set rD (div rA rB)))
-     ()
-)
-
-(dni l-divu "divide (unsigned)"
-     (DELAY-SLOT)
-     "l.divu $rD,$rA,$rB"
-     (+ OP1_3 OP2_8 rD rA rB (f-f-10-7 0) OP7_10)
-     (if VOID (eq rB (const 0))
-         (c-call VOID "@arch@_cpu_trap" pc (enum SI E_ILLEGAL))
-         (set rD (udiv rA rB))) 
-     ()
-)
-
-
-; Compare instructions
-
-; Reserved fields.
-(dnf f-f-10-11 "nop" (RESERVED) 10 11)
-
-; Register compare (both signed and unsigned)
-(define-pmacro (sf-insn-r op1-op op2-op op3-op op3-op-2 sem-op)
-  (begin
-     (dni (.sym l- "sf" (.sym sem-op "s"))
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "s $rA,$rB")
-          (+ op1-op op2-op op3-op-2 rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "u"))
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "u $rA,$rB")
-          (+ op1-op op2-op op3-op rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-   )
-)
-
-; Immediate compare (both signed and unsigned)
-(define-pmacro (sf-insn-i op1-op op2-op op3-op op3-op-2 sem-op)
-  (begin
-     (dni (.sym l- "sf" (.sym sem-op "si"))
-          (.str "l." mnemonic "si reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "si $rA,${simm-16}")
-          (+ op1-op op2-op op3-op-2 rA simm-16)
-          (set cbit (sem-op rA simm-16))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "ui"))
-          (.str "l." mnemonic "ui reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "ui $rA,${uimm-16}")
-          (+ op1-op op2-op op3-op rA uimm-16)
-          (set cbit (sem-op rA uimm-16))
-          ()
-     )
-   )
-)
-
-(define-pmacro (sf-insn op5-op sem-op)
-  (begin
-     (dni (.sym l- "sf" sem-op)
-          (.str "l." mnemonic " reg/reg")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) " $rA,$rB")
-          (+ OP1_3 OP2_9 op5-op rA rB (f-f-10-11 0))
-          (set cbit (sem-op rA rB))
-          ()
-     )
-     (dni (.sym l- "sf" (.sym sem-op "i"))
-          (.str "l." mnemonic "i reg/imm")
-          (DELAY-SLOT)
-          (.str "l.sf" (.str sem-op) "i $rA,${simm-16}")
-          (+ OP1_2 OP2_14 op5-op rA simm-16)
-          (set cbit (sem-op rA simm-16))
-          ()
-     )
-   )
-)
-
-
-(sf-insn-r OP1_3 OP2_9 OP5_2 OP5_6 gt)
-(sf-insn-r OP1_3 OP2_9 OP5_3 OP5_7 ge)
-(sf-insn-r OP1_3 OP2_9 OP5_4 OP5_8 lt)
-(sf-insn-r OP1_3 OP2_9 OP5_5 OP5_9 le)
-
-(sf-insn-i OP1_2 OP2_14 OP5_2 OP5_6 gt)
-(sf-insn-i OP1_2 OP2_14 OP5_3 OP5_7 ge)
-(sf-insn-i OP1_2 OP2_14 OP5_4 OP5_8 lt)
-(sf-insn-i OP1_2 OP2_14 OP5_5 OP5_9 le)
-
-(sf-insn   OP5_0 eq)
-(sf-insn   OP5_1 ne)
--- a/cpu/openrisc.opc
+++ /dev/null
@@ -1,164 +0,0 @@
-/* OpenRISC opcode support.  -*- C -*-
-   Copyright 2000, 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
-
-   Contributed by Red Hat Inc;
-
-   This file is part of the GNU Binutils.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* This file is an addendum to or32.cpu.  Heavy use of C code isn't
-   appropriate in .cpu files, so it resides here.  This especially applies
-   to assembly/disassembly where parsing/printing can be quite involved.
-   Such things aren't really part of the specification of the cpu, per se,
-   so .cpu files provide the general framework and .opc files handle the
-   nitty-gritty details as necessary.
-
-   Each section is delimited with start and end markers.
-
-   <arch>-opc.h additions use: "-- opc.h"
-   <arch>-opc.c additions use: "-- opc.c"
-   <arch>-asm.c additions use: "-- asm.c"
-   <arch>-dis.c additions use: "-- dis.c"
-   <arch>-ibd.h additions use: "-- ibd.h"  */
-
-/* -- opc.h */
-#undef  CGEN_DIS_HASH_SIZE
-#define CGEN_DIS_HASH_SIZE 64
-#undef  CGEN_DIS_HASH
-#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)
-
-extern long openrisc_sign_extend_16bit (long);
-/* -- */
-
-/* -- opc.c */
-/* -- */
-
-/* -- asm.c */
-
-static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
-
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-long
-openrisc_sign_extend_16bit (long value)
-{
-  return ((value & 0xffff) ^ 0x8000) - 0x8000;
-}
-
-/* Handle hi().  */
-
-static const char *
-parse_hi16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "hi(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      if (errmsg == NULL
-          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-        value >>= 16;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* Handle lo().  */
-
-static const char *
-parse_lo16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "lo(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* -- */
-
-/* -- ibd.h */
-extern long openrisc_sign_extend_16bit (long);
-
-/* -- */
--- /dev/null
+++ b/cpu/or1k.cpu
@@ -0,0 +1,133 @@
+ ; OpenRISC 1000 architecture.  -*- Scheme -*-
+; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
+; Contributed by Johan Rydberg, jrydberg@opencores.org
+; Modified by Julius Baxter, juliusbaxter@gmail.com
+; Modified by Peter Gavin, pgavin@gmail.com
+;
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 2 of the License, or
+; (at your option) any later version.
+;
+; This program is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with this program; if not, write to the Free Software
+; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, 
+; MA 02110-1301, USA.
+
+(include "simplify.inc")
+
+; The OpenRISC family is a set of RISC microprocessor architectures with an 
+; emphasis on scalability and is targetted at embedded use.
+; The CPU RTL development is a collaborative open source effort.
+; http://opencores.org/or1k
+; http://openrisc.net
+
+(define-arch
+  (name or1k)
+  (comment "OpenRISC 1000")
+  (default-alignment aligned)
+  (insn-lsb0? #t)
+  (machs or32 or32nd or64 or64nd)
+  (isas openrisc)
+)
+
+; Instruction set parameters.
+(define-isa
+  ; Name of the ISA.
+  (name openrisc)
+  ; Base insturction length.  The insns are always 32 bits wide.
+  (base-insn-bitsize 32)
+  )
+
+(define-pmacro OR32-MACHS    or32,or32nd)
+(define-pmacro OR64-MACHS    or64,or64nd)
+(define-pmacro ORBIS-MACHS   or32,or32nd,or64,or64nd)
+(define-pmacro ORFPX-MACHS   or32,or32nd,or64,or64nd)
+(define-pmacro ORFPX32-MACHS or32,or32nd,or64,or64nd)
+(define-pmacro ORFPX64-MACHS or64,or64nd)
+
+(define-attr
+  (for model)
+  (type boolean)
+  (name NO-DELAY-SLOT)
+  (comment "does not have delay slots")
+  )
+
+(if (keep-mach? (or32 or32nd))
+    (begin
+      (define-cpu
+        (name or1k32bf)
+        (comment "OpenRISC 1000 32-bit CPU family")
+        (insn-endian big)
+        (data-endian big)
+        (word-bitsize 32)
+        (file-transform "")
+        )
+
+      (define-mach
+        (name or32)
+        (comment "Generic OpenRISC 1000 32-bit CPU")
+        (cpu or1k32bf)
+        (bfd-name "or1k")
+        )
+
+      (define-mach
+        (name or32nd)
+        (comment "Generic OpenRISC 1000 32-bit CPU")
+        (cpu or1k32bf)
+        (bfd-name "or1knd")
+        )
+
+      ; OpenRISC 1200 - 32-bit or1k CPU implementation
+      (define-model
+        (name or1200) (comment "OpenRISC 1200 model") 
+        (attrs)
+        (mach or32)
+        (unit u-exec "Execution Unit" () 1 1 () () () ())
+        )
+
+      ; OpenRISC 1200 - 32-bit or1k CPU implementation
+      (define-model
+        (name or1200nd) (comment "OpenRISC 1200 model") 
+        (attrs NO-DELAY-SLOT)
+        (mach or32nd)
+        (unit u-exec "Execution Unit" () 1 1 () () () ())
+        )
+      )
+    )
+
+(if (keep-mach? (or64 or64nd))
+    (begin
+      (define-cpu
+        (name or1k64bf)
+        (comment "OpenRISC 1000 64-bit CPU family")
+        (insn-endian big)
+        (data-endian big)
+        (word-bitsize 64)
+        (file-transform "64")
+        )
+
+      (define-mach
+        (name or64)
+        (comment "Generic OpenRISC 1000 64-bit CPU")
+        (cpu or1k64bf)
+        (bfd-name "or1k64")
+        )
+
+      (define-mach
+        (name or64nd)
+        (comment "Generic OpenRISC 1000 ND 64-bit CPU")
+        (cpu or1k64bf)
+        (bfd-name "or1k64nd")
+        )
+      )
+    )
+
+(include "or1kcommon.cpu")
+(include "or1korbis.cpu")
+(include "or1korfpx.cpu")
--- /dev/null
+++ b/cpu/or1k.opc
@@ -0,0 +1,424 @@
+/* OpenRISC 1000 opcode support.  -*- C -*-
+   Copyright 2000, 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+
+   Contributed by Red Hat Inc;
+
+   This file is part of the GNU Binutils.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
+   MA 02110-1301, USA.  */
+
+/* This file is an addendum to or1k.cpu.  Heavy use of C code isn't
+   appropriate in .cpu files, so it resides here.  This especially applies
+   to assembly/disassembly where parsing/printing can be quite involved.
+   Such things aren't really part of the specification of the cpu, per se,
+   so .cpu files provide the general framework and .opc files handle the
+   nitty-gritty details as necessary.
+
+   Each section is delimited with start and end markers.
+
+   <arch>-opc.h additions use: "-- opc.h"
+   <arch>-opc.c additions use: "-- opc.c"
+   <arch>-asm.c additions use: "-- asm.c"
+   <arch>-dis.c additions use: "-- dis.c"
+   <arch>-ibd.h additions use: "-- ibd.h"  */
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)
+
+/* -- */
+
+/* -- opc.c */
+/* -- */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+parse_disp26 (CGEN_CPU_DESC cd,
+              const char ** strp,
+              int opindex,
+              int opinfo,
+              enum cgen_parse_operand_result * resultp,
+              bfd_vma * valuep)
+{
+  const char *errmsg = NULL;
+  enum cgen_parse_operand_result result_type;
+
+  if (strncasecmp (*strp, "plt(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_OR1K_PLT26,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 2) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  return cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep);
+}
+
+static const char *
+parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+        			   & result_type, & value);
+      if (**strp != ')')
+        errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      
+      ret = value;
+      
+      if (errmsg == NULL &&
+          result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER) {
+        ret >>= 16;
+        ret &= 0xffff;
+        ret = (ret ^ 0x8000) - 0x8000;
+      }
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+        			   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER) {
+        ret &= 0xffff;
+        ret = (ret ^ 0x8000) - 0x8000;
+      }
+      
+    }
+  else if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_OR1K_GOT16,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotpchi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTPC_HI16,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotpclo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTPC_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotoffhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTOFF_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotofflo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTOFF_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsgdhi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_GD_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsgdlo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_GD_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsldmhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDM_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsldmlo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDM_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "dtpoffhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDO_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "dtpofflo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDO_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gottpoffhi(", 11) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 11;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_IE_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gottpofflo(", 11) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 11;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_IE_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tpoffhi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LE_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tpofflo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LE_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+  
+  if (errmsg == NULL) {
+
+    *valuep = ret;
+
+  }
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm16(cd, strp, opindex, (long *) valuep);
+  if (errmsg == NULL)
+    *valuep &= 0xffff;
+  return errmsg;
+}
+
+/* -- */
+
+/* -- ibd.h */
+
+/* -- */
--- /dev/null
+++ b/cpu/or1kcommon.cpu
@@ -0,0 +1,347 @@
+; OpenRISC 1000 32-bit CPU hardware description.  -*- Scheme -*-
+; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
+; Contributed by Johan Rydberg, jrydberg@opencores.org
+; Modified by Julius Baxter, juliusbaxter@gmail.com
+
+; Hardware pieces.
+; These entries list the elements of the raw hardware.
+; They're also used to provide tables and other elements of the assembly
+; language.
+
+(define-hardware
+  (name h-pc)
+  (comment "program counter")
+  (attrs PC (MACH ORBIS-MACHS))
+  (type pc UWI)
+  )
+
+(define-pmacro REG-INDICES
+  ((r0 0)
+   (r1 1)
+   (r2 2)
+   (r3 3)
+   (r4 4)
+   (r5 5)
+   (r6 6)
+   (r7 7)
+   (r8 8)
+   (r9 9)
+   (r10 10)
+   (r11 11)
+   (r12 12)
+   (r13 13)
+   (r14 14) 
+   (r15 15)
+   (r16 16)
+   (r17 17)
+   (r18 18)
+   (r19 19)
+   (r20 20) 
+   (r21 21)
+   (r22 22)
+   (r23 23)
+   (r24 24)
+   (r25 25)
+   (r26 26) 
+   (r27 27)
+   (r28 28)
+   (r29 29)
+   (r30 30)
+   (r31 31)
+   (lr 9) 
+   (sp 1)
+   (fp 2))
+  )
+
+(define-hardware
+  (name h-fsr)
+  (comment "floating point registers (single, virtual)")
+  (attrs VIRTUAL (MACH ORFPX32-MACHS))
+  (type register SF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword SF (trunc SI (reg h-gpr index)) 0))
+  (set (index newval) (set UWI (reg h-gpr index) (zext UWI (subword SI newval 0))))
+  )
+
+(define-hardware
+  (name h-fdr) (comment "floating point registers (double, virtual)")
+  (attrs VIRTUAL (MACH ORFPX64-MACHS))
+  (type register DF (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (subword DF (trunc DI (reg h-gpr index)) 0))
+  (set (index newval) (set UDI (reg h-gpr index) (zext UDI (subword DI newval 0))))
+  )
+
+(define-hardware
+  (name h-spr) (comment "special purpose registers")
+  (attrs VIRTUAL (MACH ORBIS-MACHS))
+  (type register UWI (#x20000))
+  (get (index) (c-call UWI "@cpu@_h_spr_get_raw" index))
+  (set (index newval) (c-call VOID "@cpu@_h_spr_set_raw" index newval))
+)
+
+(define-pmacro spr-shift 11)
+(define-pmacro (spr-address spr-group spr-index)
+  (or (sll UWI (enum UWI (.sym "SPR-GROUP-" spr-group)) spr-shift)
+      (enum UWI (.sym "SPR-INDEX-" spr-group "-" spr-index))))
+
+(define-hardware
+  (name h-gpr) (comment "general registers")
+  (attrs (MACH ORBIS-MACHS))
+  (type register UWI (32))
+  (indices keyword "" REG-INDICES)
+  (get (index) (reg UWI h-spr (add index (spr-address SYS GPR0))))
+  (set (index newval) (set UWI (reg UWI h-spr (add index (spr-address SYS GPR0))) newval))
+  )
+
+(define-normal-enum
+  except-number
+  "Exception numbers"
+  ()
+  EXCEPT-
+  (("NONE"     #x00)
+   ("RESET"    #x01)
+   ("BUSERR"   #x02)
+   ("DPF"      #x03)
+   ("IPF"      #x04)
+   ("TICK"     #x05)
+   ("ALIGN"    #x06)
+   ("ILLEGAL"  #x07)
+   ("INT"      #x08)
+   ("DTLBMISS" #x09)
+   ("ITLBMISS" #x0a)
+   ("RANGE"    #x0b)
+   ("SYSCALL"  #x0c)
+   ("FPE"      #x0d)
+   ("TRAP"     #x0e)
+   )
+  )
+
+(define-pmacro (raise-exception exnum)
+  (c-call VOID "@cpu@_exception" pc exnum))
+
+(define-normal-enum
+  spr-groups
+  "special purpose register groups"
+  ()
+  SPR-GROUP-
+  (("SYS"          #x0)
+   ("DMMU"         #x1)
+   ("IMMU"         #x2)
+   ("DCACHE"       #x3)
+   ("ICACHE"       #x4)
+   ("MAC"          #x5)
+   ("DEBUG"        #x6)
+   ("PERF"         #x7)
+   ("POWER"        #x8)
+   ("PIC"          #x9)
+   ("TICK"         #xa)
+   ("FPU"          #xb)
+   )
+  )
+
+(define-pmacro (spr-reg-info)
+  (.splice
+   (SYS VR       #x000 "version register")
+   (SYS UPR      #x001 "unit present register")
+   (SYS CPUCFGR  #x002 "cpu configuration register")
+   (SYS DMMUCFGR #x003 "Data MMU configuration register")
+   (SYS IMMUCFGR #x004 "Insn MMU configuration register")
+   (SYS DCCFGR   #x005 "Data cache configuration register")
+   (SYS ICCFGR   #x006 "Insn cache configuration register")
+   (SYS DCFGR    #x007 "Debug configuration register")
+   (SYS PCCFGR   #x008 "Performance counters configuration register")
+   (SYS NPC      #x010 "Next program counter")
+   (SYS SR       #x011 "Supervision Regsiter")
+   (SYS PPC      #x012 "Previous program counter")
+   (SYS FPCSR    #x014 "Floating point control status register")
+   (.unsplice
+    (.map (.pmacro (n) (.splice SYS (.sym "EPCR" n) (.add n #x20) (.str "Exception PC register " n)))
+          (.iota #x10)))
+   (.unsplice
+    (.map (.pmacro (n) (.splice SYS (.sym "EEAR" n) (.add n #x30) (.str "Exception effective address register " n)))
+          (.iota #x10)))
+   (.unsplice
+    (.map (.pmacro (n) (.splice SYS (.sym "ESR" n) (.add n #x40) (.str "Exception supervision register " n)))
+          (.iota #x10)))
+   (.unsplice
+    (.map (.pmacro (n) (.splice SYS (.sym "GPR" n) (.add n #x400) (.str "General purpose register " n)))
+          (.iota #x200)))
+
+   (MAC MACLO    #x001 "Multiply and accumulate result (low)")
+   (MAC MACHI    #x002 "Multiply and accumulate result (high)")
+   (TICK TTMR    #x000 "Tick timer mode register")
+   )
+  )
+
+(define-normal-enum
+  spr-reg-indices
+  "special purpose register indicies"
+  ()
+  SPR-INDEX-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (group index n comment)
+                                  ((.sym group "-" index) n))
+                         args)
+                 )
+        (spr-reg-info)
+        )
+  )
+
+(define-pmacro (define-h-spr-reg spr-group spr-index n spr-comment)
+  (define-hardware
+    (name (.sym "h-" (.downcase spr-group) "-" (.downcase spr-index)))
+    (comment spr-comment)
+    (attrs VIRTUAL (MACH ORBIS-MACHS))
+    (type register UWI)
+    (get ()       (reg UWI h-spr (spr-address spr-group spr-index)))
+    (set (newval) (set (reg UWI h-spr (spr-address spr-group spr-index)) newval))
+    )
+  )
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-spr-reg args)) (spr-reg-info))))
+
+(define-pmacro (spr-field-info)
+  ((SYS VR      REV    5  0 "revision field")
+   (SYS VR      CFG   23 16 "configuration template field")
+   (SYS VR      VER   31 24 "version field")
+   (SYS UPR     UP     0  0 "UPR present bit")
+   (SYS UPR     DCP    1  1 "data cache present bit")
+   (SYS UPR     ICP    2  2 "insn cache present bit")
+   (SYS UPR     DMP    3  3 "data MMU present bit")
+   (SYS UPR     MP     4  4 "MAC unit present bit")
+   (SYS UPR     IMP    5  5 "insn MMU present bit")
+   (SYS UPR     DUP    6  6 "debug unit present bit")
+   (SYS UPR     PCUP   7  7 "performance counters unit present bit")
+   (SYS UPR     PICP   8  8 "programmable interrupt controller present bit")
+   (SYS UPR     PMP    9  9 "power management present bit")
+   (SYS UPR     TTP   10 10 "tick timer present bit")
+   (SYS UPR     CUP   31 24 "custom units present field")
+   (SYS CPUCFGR NSGR   3  0 "number of shadow GPR files field")
+   (SYS CPUCFGR CGF    4  4 "custom GPR file bit")
+   (SYS CPUCFGR OB32S  5  5 "ORBIS32 supported bit")
+   (SYS CPUCFGR OB64S  6  6 "ORBIS64 supported bit")
+   (SYS CPUCFGR OF32S  7  7 "ORFPX32 supported bit")
+   (SYS CPUCFGR OF64S  8  8 "ORFPX64 supported bit")
+   (SYS CPUCFGR OV64S  9  9 "ORVDX64 supported bit")
+   (SYS CPUCFGR ND    10 10 "no transfer delay bit")
+   (SYS SR      SM     0  0 "supervisor mode bit")
+   (SYS SR      TEE    1  1 "tick timer exception enabled bit")
+   (SYS SR      IEE    2  2 "interrupt exception enabled bit")
+   (SYS SR      DCE    3  3 "data cache enabled bit")
+   (SYS SR      ICE    4  4 "insn cache enabled bit")
+   (SYS SR      DME    5  5 "data MMU enabled bit")
+   (SYS SR      IME    6  6 "insn MMU enabled bit")
+   (SYS SR      LEE    7  7 "little endian enabled bit")
+   (SYS SR      CE     8  8 "CID enable bit")
+   (SYS SR      F      9  9 "flag bit")
+   (SYS SR      CY    10 10 "carry bit")
+   (SYS SR      OV    11 11 "overflow bit")
+   (SYS SR      OVE   12 12 "overflow exception enabled bit")
+   (SYS SR      DSX   13 13 "delay slot exception bit")
+   (SYS SR      EPH   14 14 "exception prefix high bit")
+   (SYS SR      FO    15 15 "fixed one bit")
+   (SYS SR      SUMRA 16 16 "SPRs user mode read access bit")
+   (SYS SR      CID   31 28 "context ID field")
+   (SYS FPCSR   FPEE   0  0 "floating point exceptions enabled bit")
+   (SYS FPCSR   RM     2  1 "floating point rounding mode field")
+   (SYS FPCSR   OVF    3  3 "floating point overflow flag bit")
+   (SYS FPCSR   UNF    4  4 "floating point underflow bit")
+   (SYS FPCSR   SNF    5  5 "floating point SNAN flag bit")
+   (SYS FPCSR   QNF    6  6 "floating point QNAN flag bit")
+   (SYS FPCSR   ZF     7  7 "floating point zero flag bit")
+   (SYS FPCSR   IXF    8  8 "floating point inexact flag bit")
+   (SYS FPCSR   IVF    9  9 "floating point invalid flag bit")
+   (SYS FPCSR   INF   10 10 "floating point infinity flag bit")
+   (SYS FPCSR   DZF   11 11 "floating point divide by zero flag bit")
+   )
+  )
+
+(define-normal-enum
+  spr-field-msbs
+  "SPR field msb positions"
+  ()
+  SPR-FIELD-MSB-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (group index field msb lsb comment)
+                                  ((.sym group "-" index "-" field) msb)
+                                  )
+                         args
+                         )
+                 )
+        (spr-field-info)
+        )
+  )
+
+(define-normal-enum
+  spr-field-lsbs
+  "SPR field lsb positions"
+  ()
+  SPR-FIELD-SIZE-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (group index field msb lsb comment)
+                                  ((.sym group "-" index "-" field) lsb)
+                                  )
+                         args
+                         )
+                 )
+        (spr-field-info)
+        )
+  )
+
+(define-normal-enum
+  spr-field-masks
+  "SPR field masks"
+  ()
+  SPR-FIELD-MASK-
+  (.map (.pmacro (args)
+                 (.apply (.pmacro (group index field msb lsb comment)
+                                  (.splice (.str group "-" index "-" field) (.sll (.inv (.sll (.inv 0) (.add (.sub msb lsb) 1))) lsb))
+                                  )
+                         args
+                         )
+                 )
+        (spr-field-info)
+        )
+  )
+
+(define-pmacro (define-h-spr-field spr-group spr-index spr-field spr-field-msb spr-field-lsb spr-field-comment)
+  (.let ((spr-field-name (.sym "h-" (.downcase spr-group) "-" (.downcase spr-index) "-" (.downcase spr-field)))
+         )
+        (begin
+          (define-hardware
+            (name spr-field-name)
+            (comment spr-field-comment)
+            (attrs VIRTUAL (MACH ORBIS-MACHS))
+            (type register UWI)
+            (get ()      (c-call UWI  "@cpu@_h_spr_field_get_raw" (spr-address spr-group spr-index) spr-field-msb spr-field-lsb))
+            (set (value) (c-call VOID "@cpu@_h_spr_field_set_raw" (spr-address spr-group spr-index) spr-field-msb spr-field-lsb value))
+            )
+          )
+        )
+  )
+(.splice begin (.unsplice (.map (.pmacro (args) (.apply define-h-spr-field args)) (spr-field-info))))
+
+(define-attr
+  (type boolean)
+  (for insn)
+  (name DELAYED-CTI)
+  (comment "delayed control transfer instruction")
+  (values #f #t)
+  (default #f)
+  )
+
+(define-attr
+  (for insn)
+  (type boolean)
+  (name NOT-IN-DELAY-SLOT)
+  (comment "instruction cannot be in delay slot")
+  (values #f #t)
+  (default #f)
+  )
+
+(define-attr
+  (for insn)
+  (type boolean)
+  (name FORCED-CTI)
+  (comment "instruction may forcefully transfer control (e.g., rfe)")
+  )
--- /dev/null
+++ b/cpu/or1korbis.cpu
@@ -0,0 +1,1067 @@
+; OpenRISC Basic Instruction Set 32-bit (ORBIS)  -*- Scheme -*-
+; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
+; Contributed by Johan Rydberg, jrydberg@opencores.org
+; Modified by Julius Baxter, juliusbaxter@gmail.com
+; Modified by Peter Gavin, pgavin@gmail.com
+
+; Instruction fields.
+
+; Hardware for immediate operands
+(dnh h-simm16      "16-bit signed immediate"   ((MACH ORBIS-MACHS)) (immediate (INT 16)) () () ())
+(dnh h-uimm16      "16-bit unsigned immediate" ()                   (immediate (UINT 16)) () () ())
+(dnh h-uimm6       "6-bit unsigned immediate"  ()                   (immediate (UINT 6)) () () ())
+
+; Instruction classes.
+(dnf f-opcode      "insn opcode"               ((MACH ORBIS-MACHS)) 31 6)
+
+; Register fields.
+(dnf f-r1          "r1"                        ((MACH ORBIS-MACHS)) 25 5)
+(dnf f-r2          "r2"                        ((MACH ORBIS-MACHS)) 20 5)
+(dnf f-r3          "r3"                        ((MACH ORBIS-MACHS)) 15 5)
+
+; Sub fields
+(dnf f-op-25-2     "op-25-2"                   ((MACH ORBIS-MACHS)) 25 2) ;; nop
+(dnf f-op-25-5     "op-25-5"                   ((MACH ORBIS-MACHS)) 25 5) ;; sys, trap, *sync, sf*
+(dnf f-op-16-1     "op-16-1"                   ((MACH ORBIS-MACHS)) 16 1) ;; movhi,macrc
+(dnf f-op-7-4      "op-7-4"                    ((MACH ORBIS-MACHS)) 7 4)
+(dnf f-op-3-4      "op-3-4"                    ((MACH ORBIS-MACHS)) 3 4)
+(dnf f-op-9-2      "op-9-2"                    ((MACH ORBIS-MACHS)) 9 2) ;; alu ops upper opcode
+(dnf f-op-9-4      "op-9-4"                    ((MACH ORBIS-MACHS)) 9 4) ;;
+(dnf f-op-7-8      "op-7-8"                    ((MACH ORBIS-MACHS)) 7 8)
+(dnf f-op-7-2      "op-7-2"                    ((MACH ORBIS-MACHS)) 7 2) ;; alu lower upper opc,shroti
+
+; Reserved fields
+(dnf f-resv-25-26  "resv-25-26"                ((MACH ORBIS-MACHS) RESERVED) 25 26)
+(dnf f-resv-25-10  "resv-25-10"                ((MACH ORBIS-MACHS) RESERVED) 25 10)
+(dnf f-resv-25-5   "resv-25-5"                 ((MACH ORBIS-MACHS) RESERVED) 25 5)
+(dnf f-resv-23-8   "resv-23-8"                 ((MACH ORBIS-MACHS) RESERVED) 23 8)
+(dnf f-resv-20-5   "resv-20-5"                 ((MACH ORBIS-MACHS) RESERVED) 20 5)
+(dnf f-resv-20-4   "resv-20-4"                 ((MACH ORBIS-MACHS) RESERVED) 20 4)
+(dnf f-resv-15-8   "resv-15-8"                 ((MACH ORBIS-MACHS) RESERVED) 15 8)
+(dnf f-resv-15-6   "resv-15-6"                 ((MACH ORBIS-MACHS) RESERVED) 15 6)
+(dnf f-resv-10-11  "resv-10-11"                ((MACH ORBIS-MACHS) RESERVED) 10 11)
+(dnf f-resv-10-7   "resv-10-7"                 ((MACH ORBIS-MACHS) RESERVED) 10 7)
+(dnf f-resv-10-3   "resv-10-3"                 ((MACH ORBIS-MACHS) RESERVED) 10 3)
+(dnf f-resv-10-1   "resv-10-1"                 ((MACH ORBIS-MACHS) RESERVED) 10 1)
+(dnf f-resv-7-4    "resv-7-4"                  ((MACH ORBIS-MACHS) RESERVED) 7 4)
+(dnf f-resv-5-2    "resv-5-2"                  ((MACH ORBIS-MACHS) RESERVED) 5 2)
+
+(dnf f-imm16-25-5  "imm16-25-5"                ((MACH ORBIS-MACHS)) 25  5)
+(dnf f-imm16-10-11 "imm16-10-11"               ((MACH ORBIS-MACHS)) 10 11)
+
+; PC relative, 26-bit (2 shifted to right)
+(df f-disp26
+    "disp26"
+    ((MACH ORBIS-MACHS) PCREL-ADDR)
+    25
+    26
+    INT
+    ((value pc) (sra SI (sub IAI value pc) (const 2)))
+    ((value pc) (add IAI (sll IAI value (const 2)) pc))
+    )
+
+; Immediates.
+(dnf f-uimm16    "uimm16"                      ((MACH ORBIS-MACHS))          15 16)
+(df  f-simm16    "simm16"                      ((MACH ORBIS-MACHS) SIGN-OPT) 15 16 INT #f #f)
+(dnf f-uimm6     "uimm6"                       ((MACH ORBIS-MACHS))          5  6) ;; shroti
+
+(define-multi-ifield
+  (name f-uimm16-split)
+  (comment "16-bit split unsigned immediate")
+  (attrs (MACH ORBIS-MACHS))
+  (mode UINT)
+  (subfields f-imm16-25-5 f-imm16-10-11)
+  (insert (sequence ()
+                    (set (ifield f-imm16-25-5)
+                         (and (srl (ifield f-uimm16-split)
+                                   (const 11))
+                              (const #x1f)))
+                    (set (ifield f-imm16-10-11)
+                         (and (ifield f-uimm16-split)
+                              (const #x7ff)))))
+  (extract 
+           (set (ifield f-uimm16-split)
+                (trunc UHI
+                       (or (sll (ifield f-imm16-25-5)
+                                (const 11))
+                           (ifield f-imm16-10-11)))))
+  )
+
+(define-multi-ifield
+  (name f-simm16-split)
+  (comment "16-bit split signed immediate")
+  (attrs (MACH ORBIS-MACHS) SIGN-OPT)
+  (mode INT)
+  (subfields f-imm16-25-5 f-imm16-10-11)
+  (insert (sequence ()
+                    (set (ifield f-imm16-25-5)
+                         (and (sra (ifield f-simm16-split)
+                                   (const 11))
+                              (const #x1f)))
+                    (set (ifield f-imm16-10-11)
+                         (and (ifield f-simm16-split)
+                              (const #x7ff)))))
+  (extract 
+           (set (ifield f-simm16-split)
+                (trunc HI
+                       (or (sll (ifield f-imm16-25-5)
+                                (const 11))
+                           (ifield f-imm16-10-11)))))
+  )
+
+; Enums.
+
+; insn-opcode: bits 31-26
+(define-normal-insn-enum 
+  insn-opcode "insn main opcode enums" ((MACH ORBIS-MACHS)) OPC_ f-opcode
+  (("J"            #x00)
+   ("JAL"          #x01)
+   ("BNF"          #x03)
+   ("BF"           #x04)
+   ("NOP"          #x05)
+   ("MOVHIMACRC"   #x06)
+   ("SYSTRAPSYNCS" #x08)
+   ("RFE"          #x09)
+   ("VECTOR"       #x0a)
+   ("JR"           #x11)
+   ("JALR"         #x12)
+   ("MACI"         #x13)
+   ("CUST1"        #x1c)
+   ("CUST2"        #x1d)
+   ("CUST3"        #x1e)
+   ("CUST4"        #x1f)
+   ("LD"           #x20)
+   ("LWZ"          #x21)
+   ("LWS"          #x22)
+   ("LBZ"          #x23)
+   ("LBS"          #x24)
+   ("LHZ"          #x25)
+   ("LHS"          #x26)
+   ("ADDI"         #x27)
+   ("ADDIC"        #x28)
+   ("ANDI"         #x29)
+   ("ORI"          #x2a)
+   ("XORI"         #x2b)
+   ("MULI"         #x2c)
+   ("MFSPR"        #x2d)
+   ("SHROTI"       #x2e)
+   ("SFI"          #x2f)
+   ("MTSPR"        #x30)
+   ("MAC"          #x31)
+   ("FLOAT"        #x32)
+   ("SD"           #x34)
+   ("SW"           #x35)
+   ("SB"           #x36)
+   ("SH"           #x37)
+   ("ALU"          #x38)
+   ("SF"           #x39)
+   ("CUST5"        #x3c)
+   ("CUST6"        #x3d)
+   ("CUST7"        #x3e)
+   ("CUST8"        #x3f) 
+  )
+)
+
+(define-normal-insn-enum insn-opcode-systrapsyncs 
+  "systrapsync insn opcode enums" ((MACH ORBIS-MACHS)) 
+  OPC_SYSTRAPSYNCS_ f-op-25-5
+    (("SYSCALL" #x00 )
+     ("TRAP" #x08 )
+     ("MSYNC" #x10 )
+     ("PSYNC" #x14 )
+     ("CSYNC" #x18 )
+    )
+)
+
+(define-normal-insn-enum insn-opcode-movehimacrc
+  "movhi/macrc insn opcode enums" ((MACH ORBIS-MACHS))
+  OPC_MOVHIMACRC_ f-op-16-1
+  (("MOVHI" #x0)
+   ("MACRC" #x1)
+  )
+)
+
+(define-normal-insn-enum insn-opcode-mac
+  "multiply/accumulate insn opcode enums" ((MACH ORBIS-MACHS))
+  OPC_MAC_ f-op-3-4
+  (("MAC" #x1)
+   ("MSB" #x2)
+   )
+  )
+
+(define-normal-insn-enum insn-opcode-shorts 
+  "shift/rotate insn opcode enums" ((MACH ORBIS-MACHS))
+  OPC_SHROTS_ f-op-7-2
+    (("SLL" #x0 )
+     ("SRL" #x1 )
+     ("SRA" #x2 )
+     ("ROR" #x3 )
+    )
+)
+
+(define-normal-insn-enum insn-opcode-extbhs
+  "extend byte/half opcode enums" ((MACH ORBIS-MACHS))
+  OPC_EXTBHS_ f-op-9-4
+  (("EXTHS" #x0)
+   ("EXTBS" #x1)
+   ("EXTHZ" #x2)
+   ("EXTBZ" #x3)
+   )
+)
+
+(define-normal-insn-enum insn-opcode-extws
+  "extend word opcode enums" ((MACH ORBIS-MACHS))
+  OPC_EXTWS_ f-op-9-4
+  (("EXTWS" #x0)
+   ("EXTWZ" #x1)
+   )
+)
+
+(define-normal-insn-enum insn-opcode-alu-regreg 
+  "alu reg/reg insn opcode enums" ((MACH ORBIS-MACHS))
+  OPC_ALU_REGREG_ f-op-3-4
+  (("ADD"   #x0)
+   ("ADDC"  #x1)
+   ("SUB"   #x2)
+   ("AND"   #x3)
+   ("OR"    #x4)
+   ("XOR"   #x5)
+   ("MUL"   #x6)
+   ("SHROT" #x8)
+   ("DIV"   #x9)
+   ("DIVU"  #xA)
+   ("MULU"  #xB)
+   ("EXTBH" #xC)
+   ("EXTW"  #xD)
+   ("CMOV"  #xE)
+   ("FFL1"  #xF)
+   )
+)
+
+(define-normal-insn-enum insn-opcode-setflag
+  "setflag insn opcode enums" ((MACH ORBIS-MACHS))
+  OPC_SF_ f-op-25-5
+    (("EQ"  #x00)
+     ("NE"  #x01)
+     ("GTU" #x02)
+     ("GEU" #x03)
+     ("LTU" #x04)
+     ("LEU" #x05)
+     ("GTS" #x0A)
+     ("GES" #x0B)
+     ("LTS" #x0C)
+     ("LES" #x0D)
+    )
+)
+
+
+; Instruction operands.
+
+(dnop sys-sr            "supervision register"             ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr            f-nil)
+(dnop sys-esr0          "exception supervision register 0" ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-esr0          f-nil)
+(dnop sys-epcr0         "exception PC register 0"          ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-epcr0         f-nil)
+
+(dnop sys-sr-lee        "SR little endian enable bit"      ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr-lee        f-nil)
+(dnop sys-sr-f          "SR flag bit"                      ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr-f          f-nil)
+(dnop sys-sr-cy         "SR carry bit"                     ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr-cy         f-nil)
+(dnop sys-sr-ov         "SR overflow bit"                  ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr-ov         f-nil)
+(dnop sys-sr-ove        "SR overflow exception enable bit" ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-sr-ove        f-nil)
+(dnop sys-cpucfgr-ob64s "CPUCFGR ORBIS64 supported bit"    ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-cpucfgr-ob64s f-nil)
+(dnop sys-cpucfgr-nd    "CPUCFGR no delay bit"             ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-cpucfgr-nd    f-nil)
+(dnop sys-fpcsr-rm      "floating point round mode"        ((MACH ORBIS-MACHS) SEM-ONLY) h-sys-fpcsr-rm      f-nil)
+
+(dnop mac-machi         "MAC HI result register"           ((MACH ORBIS-MACHS) SEM-ONLY) h-mac-machi         f-nil)
+(dnop mac-maclo         "MAC LO result register"           ((MACH ORBIS-MACHS) SEM-ONLY) h-mac-maclo         f-nil)
+
+(dnop uimm6             "uimm6"                            ((MACH ORBIS-MACHS))          h-uimm6             f-uimm6)
+
+(dnop rD                "destination register"             ((MACH ORBIS-MACHS))          h-gpr               f-r1)
+(dnop rA                "source register A"                ((MACH ORBIS-MACHS))          h-gpr               f-r2)
+(dnop rB                "source register B"                ((MACH ORBIS-MACHS))          h-gpr               f-r3)
+
+(define-operand
+  (name disp26)
+  (comment "pc-rel 26 bit")
+  (attrs (MACH ORBIS-MACHS))
+  (type h-iaddr)
+  (index f-disp26)
+  (handlers (parse "disp26"))
+  )
+
+(define-operand
+  (name simm16)
+  (comment "16-bit signed immediate")
+  (attrs (MACH ORBIS-MACHS) SIGN-OPT)
+  (type h-simm16)
+  (index f-simm16)
+  (handlers (parse "simm16"))
+  )
+
+(define-operand
+  (name uimm16)
+  (comment "16-bit unsigned immediate")
+  (attrs (MACH ORBIS-MACHS))
+  (type h-uimm16)
+  (index f-uimm16)
+  (handlers (parse "uimm16"))
+  )
+
+(define-operand
+  (name simm16-split)
+  (comment "split 16-bit signed immediate")
+  (attrs (MACH ORBIS-MACHS) SIGN-OPT)
+  (type h-simm16)
+  (index f-simm16-split)
+  (handlers (parse "simm16"))
+)
+
+(define-operand
+  (name uimm16-split)
+  (comment "split 16-bit unsigned immediate")
+  (attrs (MACH ORBIS-MACHS))
+  (type h-uimm16)
+  (index f-uimm16-split)
+  (handlers (parse "uimm16"))
+)
+
+; Instructions.
+
+; Branch releated instructions 
+
+(define-pmacro (cti-link-return)
+  (set IAI (reg h-gpr 9) (add pc (if sys-cpucfgr-nd 4 8)))
+  )
+(define-pmacro (cti-transfer-control condition target)
+  ;; this mess is necessary because we're
+  ;; skipping the delay slot, but it's
+  ;; actually the start of the next basic
+  ;; block
+  (sequence ()
+            (if condition
+                (delay 1 (set IAI pc target))
+                (if sys-cpucfgr-nd
+                    (delay 1 (set IAI pc (add pc 4))))
+                )
+            (if sys-cpucfgr-nd
+                (skip 1)
+                )
+            )
+  )
+
+(define-pmacro
+  (define-cti
+    cti-name
+    cti-comment
+    cti-attrs
+    cti-syntax
+    cti-format
+    cti-semantics)
+  (begin
+    (dni
+      cti-name
+      cti-comment
+      (.splice (MACH ORBIS-MACHS) DELAYED-CTI NOT-IN-DELAY-SLOT (.unsplice cti-attrs))
+      cti-syntax
+      cti-format
+      (cti-semantics)
+      ()
+      )
+    )
+  )
+
+(define-cti
+  l-j
+  "jump (pc-relative iaddr)"
+  (!COND-CTI UNCOND-CTI)
+  "l.j ${disp26}"
+  (+ OPC_J disp26)
+  (.pmacro ()
+           (cti-transfer-control 1 disp26)
+           )
+  )
+
+(define-cti
+  l-jal
+  "jump and link (pc-relative iaddr)"
+  (!COND-CTI UNCOND-CTI)
+  "l.jal ${disp26}"
+  (+ OPC_JAL disp26)
+  (.pmacro ()
+           (sequence ()
+                     (cti-link-return)
+                     (cti-transfer-control 1 disp26)
+                     )
+           )
+  )
+
+(define-cti
+  l-jr
+  "jump register (absolute iaddr)"
+  (!COND-CTI UNCOND-CTI)
+  "l.jr $rB"
+  (+ OPC_JR (f-resv-25-10 0) rB (f-resv-10-11 0))
+  (.pmacro ()
+           (cti-transfer-control 1 rB)
+           )
+  )
+
+(define-cti
+  l-jalr
+  "jump register and link (absolute iaddr)"
+  (!COND-CTI UNCOND-CTI)
+  "l.jalr $rB"
+  (+ OPC_JALR (f-resv-25-10 0) rB (f-resv-10-11 0) )
+  (.pmacro ()
+           (sequence ()
+                     (cti-link-return)
+                     (cti-transfer-control 1 rB)
+                     )
+           )
+  )
+
+(define-cti
+  l-bnf
+  "branch if condition bit not set (pc relative iaddr)"
+  (COND-CTI !UNCOND-CTI)
+  "l.bnf ${disp26}"
+  (+ OPC_BNF disp26)
+  (.pmacro ()
+           (cti-transfer-control (not sys-sr-f) disp26)
+           )
+  )
+
+(define-cti
+  l-bf
+  "branch if condition bit set (pc relative iaddr)"
+  (COND-CTI !UNCOND-CTI)
+  "l.bf ${disp26}"
+  (+ OPC_BF disp26)
+  (.pmacro ()
+           (cti-transfer-control sys-sr-f disp26)
+           )
+  )
+
+(dni l-trap "trap (exception)"
+     ((MACH ORBIS-MACHS) NOT-IN-DELAY-SLOT)
+     "l.trap ${uimm16}"
+     (+ OPC_SYSTRAPSYNCS OPC_SYSTRAPSYNCS_TRAP (f-resv-20-5 0) uimm16)
+     ; Do exception entry handling in C function, PC set based on SR state
+     (raise-exception EXCEPT-TRAP)
+     ()
+)
+
+
+(dni l-sys "syscall (exception)"
+     ; This function may not be in delay slot
+     ((MACH ORBIS-MACHS) NOT-IN-DELAY-SLOT)
+
+     "l.sys ${uimm16}"
+     (+ OPC_SYSTRAPSYNCS OPC_SYSTRAPSYNCS_SYSCALL (f-resv-20-5 0) uimm16)
+     ; Do exception entry handling in C function, PC set based on SR state
+     (raise-exception EXCEPT-SYSCALL)
+     ()
+)
+
+
+(dni l-rfe "return from exception"
+     ; This function may not be in delay slot
+     ((MACH ORBIS-MACHS) NOT-IN-DELAY-SLOT FORCED-CTI)
+
+     "l.rfe"
+     (+ OPC_RFE (f-resv-25-26 0))
+     (c-call VOID "@cpu@_rfe")
+     ()
+)
+
+
+; Misc instructions
+
+; l.nop with immediate must be first so it handles all l.nops in sim
+(dni l-nop-imm "nop uimm16"
+     ((MACH ORBIS-MACHS))
+     "l.nop ${uimm16}"
+     (+ OPC_NOP (f-op-25-2 #x1) (f-resv-23-8 0) uimm16)
+     (c-call VOID "@cpu@_nop" (zext UWI uimm16))
+     ()
+     )
+
+(if (application-is? SIMULATOR)
+    (begin)
+    (begin
+      (dni l-nop "nop"
+           ((MACH ORBIS-MACHS))
+           "l.nop"
+           (+ OPC_NOP (f-op-25-2 #x1) (f-resv-23-8 0) uimm16)
+           (nop)
+           ()
+           )
+      )
+)
+
+(dni l-movhi "movhi reg/uimm16"
+     ((MACH ORBIS-MACHS))
+     "l.movhi $rD,$uimm16"
+     (+ OPC_MOVHIMACRC rD (f-resv-20-4 0) OPC_MOVHIMACRC_MOVHI uimm16)
+     (set UWI rD (sll UWI (zext UWI uimm16) (const 16)))
+     ()
+)
+
+(dni l-macrc "macrc reg"
+     ((MACH ORBIS-MACHS))
+     "l.macrc $rD"
+     (+ OPC_MOVHIMACRC rD (f-resv-20-4 0) OPC_MOVHIMACRC_MACRC (f-uimm16 0))
+     (sequence ()
+               (set UWI rD mac-maclo)
+               (set UWI mac-maclo 0)
+               (set UWI mac-machi 0)
+               )
+     ()
+     )
+
+
+; System releated instructions
+
+(dni l-mfspr "mfspr"
+     ((MACH ORBIS-MACHS))
+     "l.mfspr $rD,$rA,${uimm16}"
+     (+ OPC_MFSPR rD rA uimm16)
+     (set UWI rD (c-call UWI "@cpu@_mfspr" (or rA (zext UWI uimm16))))
+     ()
+)
+
+(dni l-mtspr "mtspr"
+     ((MACH ORBIS-MACHS))
+     "l.mtspr $rA,$rB,${uimm16-split}"
+     (+ OPC_MTSPR rA rB uimm16-split )
+     (c-call VOID "@cpu@_mtspr" (or rA (zext WI uimm16-split)) rB)
+     ()
+)
+
+
+; Load instructions
+(define-pmacro (load-store-addr base offset size)
+  (c-call AI "@cpu@_make_load_store_addr" base (ext SI offset) size))
+
+(dni l-lwz "l.lwz reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lwz $rD,${simm16}($rA)"
+     (+ OPC_LWZ rD rA simm16)
+     (set UWI rD (zext UWI (mem USI (load-store-addr rA simm16 4))))
+     ()
+)
+
+
+(dni l-lws "l.lws reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lws $rD,${simm16}($rA)"
+     (+ OPC_LWS rD rA simm16)
+     (set WI rD (ext WI (mem SI (load-store-addr rA simm16 4))))
+     ()
+)
+
+(dni l-lbz "l.lbz reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lbz $rD,${simm16}($rA)"
+     (+ OPC_LBZ rD rA simm16)
+     (set UWI rD (zext UWI (mem UQI (load-store-addr rA simm16 1))))
+     ()
+)
+
+(dni l-lbs "l.lbz reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lbs $rD,${simm16}($rA)"
+     (+ OPC_LBS rD rA simm16)
+     (set WI rD (ext WI (mem QI (load-store-addr rA simm16 1))))
+     ()
+)
+
+(dni l-lhz "l.lhz reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lhz $rD,${simm16}($rA)"
+     (+ OPC_LHZ rD simm16 rA)
+     (set UWI rD (zext UWI (mem UHI (load-store-addr rA simm16 2))))
+     ()
+)
+
+(dni l-lhs "l.lhs reg/simm16(reg)"
+     ((MACH ORBIS-MACHS))
+     "l.lhs $rD,${simm16}($rA)"
+     (+ OPC_LHS rD rA simm16)
+     (set WI rD (ext WI (mem HI (load-store-addr rA simm16 2))))
+     ()
+)
+
+
+; Store instructions
+
+(define-pmacro (store-insn mnemonic opc-op mode size)
+  (begin
+     (dni (.sym l- mnemonic)
+          (.str "l." mnemonic " simm16(reg)/reg")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic " ${simm16-split}($rA),$rB")
+          (+ opc-op rB rD simm16-split)
+          (set mode (mem mode (load-store-addr rA simm16-split size)) (trunc mode rB))
+          ()
+     )
+   )
+)
+
+(store-insn sw OPC_SW USI 4)
+(store-insn sb OPC_SB UQI 1)
+(store-insn sh OPC_SH UHI 2)
+
+
+
+; Shift and rotate instructions
+
+(define-pmacro (shift-insn mnemonic)
+  (begin
+     (dni (.sym l- mnemonic)
+          (.str "l." mnemonic " reg/reg/reg")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic " $rD,$rA,$rB")
+          (+ OPC_ALU rD rA rB (f-resv-10-3 0) (.sym OPC_SHROTS_ (.upcase mnemonic)) (f-resv-5-2 0) 
+	     OPC_ALU_REGREG_SHROT )
+          (set UWI rD (mnemonic rA rB))
+          ()
+     )
+     (dni (.sym l- mnemonic "i")
+          (.str "l." mnemonic " reg/reg/uimm6")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic "i $rD,$rA,${uimm6}")
+          (+ OPC_SHROTI rD rA (f-resv-15-8 0) (.sym OPC_SHROTS_ (.upcase mnemonic)) uimm6)
+          (set rD (mnemonic rA uimm6))
+          ()
+     )
+   )
+)
+
+(shift-insn sll)
+(shift-insn srl)
+(shift-insn sra)
+(shift-insn ror)
+
+
+; Arithmetic insns
+
+; ALU op macro
+(define-pmacro (alu-insn mnemonic)
+  (begin
+     (dni (.sym l- mnemonic)
+          (.str "l." mnemonic " reg/reg/reg")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic " $rD,$rA,$rB")
+          (+ OPC_ALU rD rA rB (f-resv-10-7 0) (.sym OPC_ALU_REGREG_ (.upcase mnemonic)))
+          (set rD (mnemonic rA rB))
+          ()
+     )
+  )
+)
+
+(alu-insn and)
+(alu-insn or)
+(alu-insn xor)
+
+(define-pmacro (alu-carry-insn mnemonic)
+  (begin
+    (dni (.sym l- mnemonic)
+         (.str "l." mnemonic " reg/reg/reg")
+         ((MACH ORBIS-MACHS))
+         (.str "l." mnemonic " $rD,$rA,$rB")
+         (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) (.sym OPC_ALU_REGREG_ (.upcase mnemonic)))
+         (sequence ()
+                   (sequence ()
+                             (set BI sys-sr-cy ((.sym mnemonic "c-cflag") WI rA rB 0))
+                             (set BI sys-sr-ov ((.sym mnemonic "c-oflag") WI rA rB 0))
+                             (set rD (mnemonic WI rA rB))
+                             )
+                   (if (andif sys-sr-ov sys-sr-ove)
+                       (raise-exception EXCEPT-RANGE))
+                   )
+         ()
+         )
+    )
+  )
+
+(alu-carry-insn add)
+(alu-carry-insn sub)
+
+(dni (l-addc) "l.addc reg/reg/reg"
+          ((MACH ORBIS-MACHS))
+          ("l.addc $rD,$rA,$rB")
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_ADDC)
+          (sequence ()
+                    (sequence ((BI tmp-sys-sr-cy))
+                              (set BI tmp-sys-sr-cy sys-sr-cy)
+                              (set BI sys-sr-cy (addc-cflag WI rA rB tmp-sys-sr-cy))
+                              (set BI sys-sr-ov (addc-oflag WI rA rB tmp-sys-sr-cy))
+                              (set rD (addc WI rA rB tmp-sys-sr-cy))
+                              )
+                   (if (andif sys-sr-ov sys-sr-ove)
+                       (raise-exception EXCEPT-RANGE))
+                   )
+          ()
+)
+
+(dni (l-mul) "l.mul reg/reg/reg"
+          ((MACH ORBIS-MACHS))
+          ("l.mul $rD,$rA,$rB")
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_MUL)
+          (sequence ()
+                    (sequence ()
+                              ; 2's complement overflow
+                              (set BI sys-sr-ov (mul-o2flag WI rA rB))
+                              ; 1's complement overflow
+                              (set BI sys-sr-cy (mul-o1flag WI rA rB))
+                              (set rD (mul WI rA rB))
+                              )
+                    (if (andif sys-sr-ov sys-sr-ove)
+                        (raise-exception EXCEPT-RANGE))
+                    )
+          ()
+)
+
+(dni (l-mulu) "l.mulu reg/reg/reg"
+          ((MACH ORBIS-MACHS))
+          ("l.mulu $rD,$rA,$rB")
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_MULU)
+          (sequence ()
+                    (sequence ()
+                              ; 2's complement overflow
+                              (set BI sys-sr-ov 0)
+                              ; 1's complement overflow
+                              (set BI sys-sr-cy (mul-o1flag UWI rA rB))
+                              (set rD (mul UWI rA rB))
+                              )
+                    (if (andif sys-sr-ov sys-sr-ove)
+                        (raise-exception EXCEPT-RANGE))
+                    )
+          ()
+)
+
+(dni l-div "divide (signed)"
+          ((MACH ORBIS-MACHS))
+          "l.div $rD,$rA,$rB"
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_DIV)
+          (sequence ()
+                    (if (ne rB 0)
+                        (sequence ()
+                                  (set BI sys-sr-cy 0)
+                                  (set WI rD (div WI rA rB))
+                                  )
+                        (set BI sys-sr-cy 1)
+                        )
+                    (set BI sys-sr-ov 0)
+                    (if (andif sys-sr-cy sys-sr-ove)
+                        (raise-exception EXCEPT-RANGE))
+                    )
+          ()
+)
+
+(dni l-divu "divide (unsigned)"
+          ((MACH ORBIS-MACHS))
+          "l.divu $rD,$rA,$rB"
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x30) OPC_ALU_REGREG_DIVU)
+          (sequence ()
+                    (if (ne rB 0)
+                        (sequence ()
+                                  (set BI sys-sr-cy 0)
+                                  (set rD (udiv UWI rA rB))
+                                  )
+                        (set BI sys-sr-cy 1)
+                        )
+                    (set BI sys-sr-ov 0)
+                    (if (andif sys-sr-cy sys-sr-ove)
+                        (raise-exception EXCEPT-RANGE))
+                    )
+          ()
+)
+
+(dni l-ff1 "find first '1'"
+          ((MACH ORBIS-MACHS))
+          "l.ff1 $rD,$rA"
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x00) OPC_ALU_REGREG_FFL1)
+          (set rD (c-call UWI "@cpu@_ff1" rA))
+          ()
+)
+
+(dni l-fl1 "find last '1'"
+          ((MACH ORBIS-MACHS))
+          "l.fl1 $rD,$rA"
+          (+ OPC_ALU rD rA rB (f-resv-10-7 #x10) OPC_ALU_REGREG_FFL1)
+          (set rD (c-call UWI "@cpu@_fl1" rA))
+          ()
+)
+
+
+(define-pmacro (alu-insn-simm  mnemonic)
+  (begin
+      (dni (.sym l- mnemonic "i")
+          (.str "l." mnemonic " reg/reg/simm16")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic "i $rD,$rA,$simm16")
+          (+ (.sym OPC_ (.upcase mnemonic) "I") rD rA simm16)
+          (set rD (mnemonic rA (ext WI simm16)))
+          ()
+     )
+   )
+)
+
+(define-pmacro (alu-insn-uimm  mnemonic)
+  (begin
+      (dni (.sym l- mnemonic "i")
+          (.str "l." mnemonic " reg/reg/uimm16")
+          ((MACH ORBIS-MACHS))
+          (.str "l." mnemonic "i $rD,$rA,$uimm16")
+          (+ (.sym OPC_ (.upcase mnemonic) "I") rD rA uimm16)
+          (set rD (mnemonic rA (zext UWI uimm16)))
+          ()
+     )
+   )
+)
+
+(alu-insn-uimm and)
+(alu-insn-uimm or)
+(alu-insn-simm xor)
+
+(define-pmacro (alu-carry-insn-simm mnemonic)
+  (begin
+    (dni (.sym l- mnemonic "i")
+         (.str "l." mnemonic "i reg/reg/simm16")
+         ((MACH ORBIS-MACHS))
+         (.str "l." mnemonic "i $rD,$rA,$simm16")
+         (+ (.sym OPC_ (.upcase mnemonic) "I") rD rA simm16)
+         (sequence ()
+                   (sequence ()
+                             (set BI sys-sr-cy ((.sym mnemonic "c-cflag") WI rA (ext WI simm16) 0))
+                             (set BI sys-sr-ov ((.sym mnemonic "c-oflag") WI rA (ext WI simm16) 0))
+                             (set rD (mnemonic WI rA (ext WI simm16)))
+                             )
+                   (if (andif sys-sr-ov sys-sr-ove)
+                       (raise-exception EXCEPT-RANGE))
+                   )
+         ()
+         )
+    )
+  )
+
+(alu-carry-insn-simm add)
+
+(dni (l-addic)
+     ("l.addic reg/reg/simm16")
+     ((MACH ORBIS-MACHS))
+     ("l.addic $rD,$rA,$simm16")
+     (+ OPC_ADDIC rD rA simm16)
+     (sequence ()
+               (sequence ((BI tmp-sys-sr-cy))
+                         (set BI tmp-sys-sr-cy sys-sr-cy)
+                         (set BI sys-sr-cy (addc-cflag WI rA (ext WI simm16) tmp-sys-sr-cy))
+                         (set BI sys-sr-ov (addc-oflag WI rA (ext WI simm16) tmp-sys-sr-cy))
+                         (set WI rD (addc WI rA (ext WI simm16) tmp-sys-sr-cy))
+                         )
+               (if (andif sys-sr-ov sys-sr-ove)
+                   (raise-exception EXCEPT-RANGE))
+               )
+     ()
+)
+
+(dni (l-muli)
+     "l.muli reg/reg/simm16"
+     ((MACH ORBIS-MACHS))
+     ("l.muli $rD,$rA,$simm16")
+     (+ OPC_MULI rD rA simm16)
+     (sequence ()
+               (sequence ()
+                         ; 2's complement overflow
+                         (set sys-sr-ov (mul-o2flag WI rA (ext WI simm16)))
+                         ; 1's complement overflow
+                         (set sys-sr-cy (mul-o1flag UWI rA (ext UWI simm16)))
+                         (set rD (mul WI rA (ext WI simm16)))
+                         )
+               (if (andif sys-sr-ov sys-sr-ove)
+                   (raise-exception EXCEPT-RANGE))
+               )
+     ()
+     )
+
+(define-pmacro (extbh-insn mnemonic extop extmode truncmode)
+  (begin
+    (dni (.sym l- mnemonic)
+         (.str "l." mnemonic " reg/reg")
+         ((MACH ORBIS-MACHS))
+         (.str "l." mnemonic " $rD,$rA")
+         (+ OPC_ALU rD rA (f-resv-15-6 0) (.sym OPC_EXTBHS_ (.upcase mnemonic)) (f-resv-5-2 0) OPC_ALU_REGREG_EXTBH)
+         (set rD (extop extmode (trunc truncmode rA)))
+         ()
+         )
+    )
+  )
+
+(extbh-insn exths ext  WI  HI)
+(extbh-insn extbs ext  WI  QI)
+(extbh-insn exthz zext UWI UHI)
+(extbh-insn extbz zext UWI UQI)
+
+(define-pmacro (extw-insn mnemonic extop extmode truncmode)
+  (begin
+    (dni (.sym l- mnemonic)
+         (.str "l." mnemonic " reg/reg")
+         ((MACH ORBIS-MACHS))
+         (.str "l." mnemonic " $rD,$rA")
+         (+ OPC_ALU rD rA (f-resv-15-6 0) (.sym OPC_EXTWS_ (.upcase mnemonic)) (f-resv-5-2 0) OPC_ALU_REGREG_EXTW)
+         (set rD (extop extmode (trunc truncmode rA)))
+         ()
+         )
+    )
+  )
+
+(extw-insn extws ext  WI  SI)
+(extw-insn extwz zext USI USI)
+
+(dni l-cmov
+     "l.cmov reg/reg/reg"
+     ((MACH ORBIS-MACHS))
+     "l.cmov $rD,$rA,$rB"
+     (+ OPC_ALU rD rA rB (f-resv-10-1 0) (f-op-9-2 0) (f-resv-7-4 0) OPC_ALU_REGREG_CMOV)
+     (if sys-sr-f
+         (set UWI rD rA)
+         (set UWI rD rB)
+         )
+     ()
+     )
+
+; Compare instructions
+
+; Ordering compare
+(define-pmacro (sf-insn op)
+  (begin
+     (dni (.sym l- "sf" op "s")                                               ; l-sfgts
+          (.str "l.sf" op "s reg/reg")                                        ; "l.sfgts reg/reg"
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op "s $rA,$rB")                                        ; "l.sfgts $rA,$rB"
+          (+ OPC_SF (.sym "OPC_SF_" (.upcase op) "S") rA rB (f-resv-10-11 0)) ; (+ OPC_SF OPC_SF_GTS rA rB (f-resv-10-11 0))
+          (set sys-sr-f (op WI rA rB))                                        ; (set sys-sr-f (gt WI rA rB))
+          ()
+          )
+     (dni (.sym l- "sf" op "si")                                              ; l-sfgtsi
+          (.str "l.sf" op "si reg/simm16")                                    ; "l.sfgtsi reg/simm16"
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op "si $rA,$simm16")                                   ; "l.sfgtsi $rA,$simm16"
+          (+ OPC_SFI (.sym "OPC_SF_" (.upcase op) "S") rA simm16)             ; (+ OPC_SFI OPC_SF_GTS rA simm16)
+          (set sys-sr-f (op WI rA (ext WI simm16)))                           ; (set sys-sr-f (gt WI rA (ext WI simm16)))
+          ()
+          )
+     (dni (.sym l- "sf" op "u")                                               ; l-sfgtu
+          (.str "l.sf" op "u reg/reg")                                        ; "l.sfgtu reg/reg"
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op "u $rA,$rB")                                        ; "l.sfgtu $rA,$rB"
+          (+ OPC_SF (.sym "OPC_SF_" (.upcase op) "U") rA rB (f-resv-10-11 0)) ; (+ OPC_SF OPC_SF_GTU rA rB (f-resv-10-11 0))
+          (set sys-sr-f ((.sym op "u") WI rA rB))                             ; (set sys-sr-f (gtu WI rA rB))
+          ()
+          )
+     ; immediate is sign extended even for unsigned compare
+     (dni (.sym l- "sf" op "ui")                                              ; l-sfgtui
+          (.str "l.sf" op "ui reg/simm16")                                    ; "l.sfgtui reg/uimm16"
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op "ui $rA,$simm16")                                   ; "l.sfgtui $rA,$simm16"
+          (+ OPC_SFI (.sym "OPC_SF_" (.upcase op) "U") rA simm16)             ; (+ OPC_SFI OPC_SF_GTU rA simm16)
+          (set sys-sr-f ((.sym op "u") WI rA (ext WI simm16)))                ; (set sys-sr-f (gtu WI rA (ext WI simm16)))
+          ()
+          )
+     )
+  )
+
+(sf-insn gt)
+(sf-insn ge)
+(sf-insn lt)
+(sf-insn le)
+
+; Equality compare
+(define-pmacro (sf-insn-eq op)
+  (begin
+     (dni (.sym l- "sf" op)
+          (.str "l." op " reg/reg")
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op " $rA,$rB")
+          (+ OPC_SF (.sym "OPC_SF_" (.upcase op)) rA rB (f-resv-10-11 0))
+          (set sys-sr-f (op WI rA rB))
+          ()
+     )
+     (dni (.sym l- "sf" op "i")
+          (.str "l.sf" op "i reg/simm16")
+          ((MACH ORBIS-MACHS))
+          (.str "l.sf" op "i $rA,$simm16")
+          (+ OPC_SFI (.sym "OPC_SF_" (.upcase op)) rA simm16)
+          (set sys-sr-f (op WI rA (ext WI simm16)))
+          ()
+     )
+   )
+)
+
+(sf-insn-eq eq)
+(sf-insn-eq ne)
+
+(dni l-mac
+     "l.mac reg/reg"
+     ((MACH ORBIS-MACHS))
+     "l.mac $rA,$rB"
+     (+  OPC_MAC (f-op-25-5 0) rA rB (f-resv-10-7 0) OPC_MAC_MAC)
+     (sequence ((WI prod) (DI result))
+               (set WI prod (mul WI rA rB))
+               (set DI result (add (join DI SI mac-machi mac-maclo) (ext DI prod)))
+               (set SI mac-machi (subword SI result 0))
+               (set SI mac-maclo (subword SI result 1))
+               )
+     ()
+     )
+
+(dni l-msb
+     "l.msb reg/reg"
+     ((MACH ORBIS-MACHS))
+     "l.msb $rA,$rB"
+     (+  OPC_MAC (f-op-25-5 0) rA rB (f-resv-10-7 0) OPC_MAC_MSB)
+     (sequence ((WI prod) (DI result))
+               (set WI prod (mul WI rA rB))
+               (set DI result (sub (join DI SI mac-machi mac-maclo) (ext DI prod)))
+               (set SI mac-machi (subword SI result 0))
+               (set SI mac-maclo (subword SI result 1))
+               )
+     ()
+     )
+
+(dni l-maci
+     "l.maci reg/simm16"
+     ((MACH ORBIS-MACHS))
+     "l.maci $rA,${simm16}"
+     (+ OPC_MACI (f-resv-25-5 0) rA simm16)
+     (sequence ((WI prod) (DI result))
+               (set WI prod (mul WI (ext WI simm16) rA))
+               (set DI result (add (join DI SI mac-machi mac-maclo) (ext DI prod)))
+               (set SI mac-machi (subword SI result 0))
+               (set SI mac-maclo (subword SI result 1))
+               )
+     ()
+     )
+
+(define-pmacro (cust-insn cust-num)
+  (begin
+    (dni (.sym l- "cust" cust-num)
+         (.str "l.cust" cust-num)
+         ((MACH ORBIS-MACHS))
+         (.str "l.cust" cust-num)
+         (+ (.sym OPC_CUST cust-num) (f-resv-25-26 0))
+         (nop)
+         ()
+         )
+    )
+  )
+
+(cust-insn "1")
+(cust-insn "2")
+(cust-insn "3")
+(cust-insn "4")
+(cust-insn "5")
+(cust-insn "6")
+(cust-insn "7")
+(cust-insn "8")
--- /dev/null
+++ b/cpu/or1korfpx.cpu
@@ -0,0 +1,224 @@
+; OpenRISC 1000 architecture.  -*- Scheme -*-
+; Copyright 2000, 2001, 2011 Free Software Foundation, Inc.
+; Contributed by Peter Gavin, pgavin@gmail.com
+;
+; This program is free software; you can redistribute it and/or modify
+; it under the terms of the GNU General Public License as published by
+; the Free Software Foundation; either version 2 of the License, or
+; (at your option) any later version.
+;
+; This program is distributed in the hope that it will be useful,
+; but WITHOUT ANY WARRANTY; without even the implied warranty of
+; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+; GNU General Public License for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with this program; if not, write to the Free Software
+; Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, 
+; MA 02110-1301, USA.
+
+; Initial ORFPX32 instruction set
+
+; I'm not sure how CGEN handles rounding in FP operations, except for
+; in conversions to/from integers.  So lf.add, lf.sub, lf.mul, and
+; lf.div do not round according to the FPCSR RM field.
+; NaN, overflow, and underflow are not yet handled either.
+
+(define-normal-insn-enum insn-opcode-float-regreg
+  "floating point reg/reg insn opcode enums" ()
+  OPC_FLOAT_REGREG_ f-op-7-8
+  (("ADD_S"  #x00)
+   ("SUB_S"  #x01)
+   ("MUL_S"  #x02)
+   ("DIV_S"  #x03)
+   ("ITOF_S" #x04)
+   ("FTOI_S" #x05)
+   ("REM_S"  #x06)
+   ("MADD_S" #x07)
+   ("SFEQ_S" #x08)
+   ("SFNE_S" #x09)
+   ("SFGT_S" #x0a)
+   ("SFGE_S" #x0b)
+   ("SFLT_S" #x0c)
+   ("SFLE_S" #x0d)
+   ("ADD_D"  #x10)
+   ("SUB_D"  #x11)
+   ("MUL_D"  #x12)
+   ("DIV_D"  #x13)
+   ("ITOF_D" #x14)
+   ("FTOI_D" #x15)
+   ("REM_D"  #x16)
+   ("MADD_D" #x17)
+   ("SFEQ_D" #x18)
+   ("SFNE_D" #x19)
+   ("SFGT_D" #x1a)
+   ("SFGE_D" #x1b)
+   ("SFLT_D" #x1c)
+   ("SFLE_D" #x1d)
+   ("CUST1_S" #xd0)
+   ("CUST1_D" #xe0)
+   )
+  )
+
+(dnop rDSF "destination register (single floating point mode)" () h-fsr f-r1)
+(dnop rASF "source register A (single floating point mode)"    () h-fsr f-r2)
+(dnop rBSF "source register B (single floating point mode)"    () h-fsr f-r3)
+
+(dnop rDDF "destination register (double floating point mode)" ((MACH ORFPX64-MACHS)) h-fdr f-r1)
+(dnop rADF "source register A (double floating point mode)"    ((MACH ORFPX64-MACHS)) h-fdr f-r1)
+(dnop rBDF "source register B (double floating point mode)"    ((MACH ORFPX64-MACHS)) h-fdr f-r1)
+
+(define-pmacro (float-regreg-insn mnemonic)
+  (begin
+    (dni (.sym lf- mnemonic -s)
+         (.str "lf." mnemonic ".s reg/reg/reg")
+         ((MACH ORFPX-MACHS))
+         (.str "lf." mnemonic ".s $rDSF,$rASF,$rBSF")
+         (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_ (.upcase mnemonic) _S))
+         (set SF rDSF (mnemonic SF rASF rBSF))
+         ()
+         )
+    (dni (.sym lf- mnemonic -d)
+         (.str "lf." mnemonic ".d reg/reg/reg")
+         ((MACH ORFPX64-MACHS))
+         (.str "lf." mnemonic ".d $rDDF,$rADF,$rBDF")
+         (+ OPC_FLOAT rDDF rADF rBDF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_ (.upcase mnemonic) _D))
+         (set DF rDDF (mnemonic DF rADF rBDF))
+         ()
+         )
+    )
+  )
+
+(float-regreg-insn add)
+(float-regreg-insn sub)
+(float-regreg-insn mul)
+(float-regreg-insn div)
+
+(dni lf-rem-s
+     "lf.rem.s reg/reg/reg"
+     ((MACH ORFPX-MACHS))
+     "lf.rem.s $rDSF,$rASF,$rBSF"
+     (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) OPC_FLOAT_REGREG_REM_S)
+     (set SF rDSF (rem SF rASF rBSF))
+     ()
+     )
+(dni lf-rem-d
+     "lf.rem.d reg/reg/reg"
+     ((MACH ORFPX64-MACHS))
+     "lf.rem.d $rDDF,$rADF,$rBDF"
+     (+ OPC_FLOAT rDDF rADF rBDF (f-resv-10-3 0) OPC_FLOAT_REGREG_REM_D)
+     (set DF rDDF (mod DF rADF rBDF))
+     ()
+     )
+
+(define-pmacro (get-rounding-mode)
+  (case INT sys-fpcsr-rm
+        ((0) 1) ; TIES-TO-EVEN -- I'm assuming this is what is meant by "round to nearest"
+        ((1) 3) ; TOWARD-ZERO
+        ((2) 4) ; TOWARD-POSITIVE
+        (else 5) ; TOWARD-NEGATIVE
+        )
+  )
+
+(dni lf-itof-s
+     "lf.itof.s reg/reg"
+     ((MACH ORFPX-MACHS))
+     "lf.itof.s $rDSF,$rA"
+     (+ OPC_FLOAT rDSF rA (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_ITOF_S)
+     (set SF rDSF (float SF (get-rounding-mode) (trunc SI rA)))
+     ()
+     )
+(dni lf-itof-d
+     "lf.itof.d reg/reg"
+     ((MACH ORFPX64-MACHS))
+     "lf.itof.d $rDSF,$rA"
+     (+ OPC_FLOAT rDSF rA (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_ITOF_D)
+     (set DF rDDF (float DF (get-rounding-mode) rA))
+     ()
+     )
+
+(dni lf-ftoi-s
+     "lf.ftoi.s reg/reg"
+     ((MACH ORFPX-MACHS))
+     "lf.ftoi.s $rD,$rASF"
+     (+ OPC_FLOAT rD rASF (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_FTOI_S)
+     (set WI rD (ext WI (fix SI (get-rounding-mode) rASF)))
+     ()
+     )
+
+(dni lf-ftoi-d
+     "lf.ftoi.d reg/reg"
+     ((MACH ORFPX64-MACHS))
+     "lf.ftoi.d $rD,$rADF"
+     (+ OPC_FLOAT rD rADF (f-r3 0) (f-resv-10-3 0) OPC_FLOAT_REGREG_FTOI_D)
+     (set DI rD (fix DI (get-rounding-mode) rADF))
+     ()
+     )
+
+(define-pmacro (float-setflag-insn mnemonic)
+  (begin
+    (dni (.sym lf- mnemonic -s)
+         (.str "lf.sf" mnemonic ".s reg/reg")
+         ((MACH ORFPX-MACHS))
+         (.str "lf.sf" mnemonic ".s $rASF,$rBSF")
+         (+ OPC_FLOAT (f-r1 0) rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _S))
+         (set BI sys-sr-f (mnemonic SF rASF rBSF))
+         ()
+         )
+    (dni (.sym lf- mnemonic -d)
+         (.str "lf.sf" mnemonic ".d reg/reg")
+         ((MACH ORFPX64-MACHS))
+         (.str "lf.sf" mnemonic ".d $rASF,$rBSF")
+         (+ OPC_FLOAT (f-r1 0) rASF rBSF (f-resv-10-3 0) (.sym OPC_FLOAT_REGREG_SF (.upcase mnemonic) _D))
+         (set BI sys-sr-f (mnemonic DF rADF rBDF))
+         ()
+         )
+    )
+  )
+
+(float-setflag-insn eq)
+(float-setflag-insn ne)
+(float-setflag-insn ge)
+(float-setflag-insn gt)
+(float-setflag-insn lt)
+(float-setflag-insn le)
+
+(dni lf-madd-s
+     "lf.madd.s reg/reg/reg"
+     ((MACH ORFPX-MACHS))
+     "lf.madd.s $rDSF,$rASF,$rBSF"
+     (+ OPC_FLOAT rDSF rASF rBSF (f-resv-10-3 0) OPC_FLOAT_REGREG_MADD_S)
+     (set SF rDSF (add SF (mul SF rASF rBSF) rDSF))
+     ()
+     )
+(dni lf-madd-d
+     "lf.madd.d reg/reg/reg"
+     ((MACH ORFPX64-MACHS))
+     "lf.madd.d $rDDF,$rADF,$rBDF"
+     (+ OPC_FLOAT rDDF rADF rBDF (f-resv-10-3 0) OPC_FLOAT_REGREG_MADD_D)
+     (set DF rDDF (add DF (mul DF rADF rBDF) rDDF))
+     ()
+     )
+
+(define-pmacro (float-cust-insn cust-num)
+  (begin
+    (dni (.sym "lf-cust" cust-num "-s")
+         (.str "lf.cust" cust-num ".s")
+         ((MACH ORFPX-MACHS))
+         (.str "lf.cust" cust-num ".s $rASF,$rBSF")
+         (+ OPC_FLOAT (f-resv-25-5 0) rASF rBSF (f-resv-10-3 0) (.sym "OPC_FLOAT_REGREG_CUST" cust-num "_S"))
+         (nop)
+         ()
+         )
+    (dni (.sym "lf-cust" cust-num "-d")
+         (.str "lf.cust" cust-num ".d")
+         ((MACH ORFPX64-MACHS))
+         (.str "lf.cust" cust-num ".d")
+         (+ OPC_FLOAT (f-resv-25-5 0) rADF rBDF (f-resv-10-3 0) (.sym "OPC_FLOAT_REGREG_CUST" cust-num "_D"))
+         (nop)
+         ()
+         )
+    )
+  )
+
+(float-cust-insn "1")
--- /dev/null
+++ b/dw2-decodedline-1.S
@@ -0,0 +1,16 @@
+	.file	"dw2-decodedline.c"
+	.file 1 "dw2-decodedline.c"
+	.file 2 "directory/file1.c"
+	.text
+.globl f1
+	.type	f1, %function
+f1:
+	.loc 2 1 0
+	l.nop
+	.size	f1, .-f1
+.globl main
+	.type	main, %function
+main:
+	.loc 1 2 0
+	l.nop
+	.size	main, .-main
--- a/gas/Makefile.am
+++ b/gas/Makefile.am
@@ -166,8 +166,7 @@
 	config/tc-mt.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
-	config/tc-openrisc.c \
-	config/tc-or32.c \
+	config/tc-or1k.c \
 	config/tc-pdp11.c \
 	config/tc-pj.c \
 	config/tc-ppc.c \
@@ -237,8 +236,7 @@
 	config/tc-mt.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
-	config/tc-openrisc.h \
-	config/tc-or32.h \
+	config/tc-or1k.h \
 	config/tc-pdp11.h \
 	config/tc-pj.h \
 	config/tc-ppc.h \
--- a/gas/Makefile.in
+++ b/gas/Makefile.in
@@ -435,8 +435,7 @@
 	config/tc-mt.c \
 	config/tc-nios2.c \
 	config/tc-ns32k.c \
-	config/tc-openrisc.c \
-	config/tc-or32.c \
+	config/tc-or1k.c \
 	config/tc-pdp11.c \
 	config/tc-pj.c \
 	config/tc-ppc.c \
@@ -506,8 +505,7 @@
 	config/tc-mt.h \
 	config/tc-nios2.h \
 	config/tc-ns32k.h \
-	config/tc-openrisc.h \
-	config/tc-or32.h \
+	config/tc-or1k.h \
 	config/tc-pdp11.h \
 	config/tc-pj.h \
 	config/tc-ppc.h \
@@ -856,8 +854,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-mt.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-nios2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-ns32k.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-openrisc.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-or32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-or1k.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-pdp11.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-pj.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tc-ppc.Po@am__quote@
@@ -1496,33 +1493,19 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-ns32k.obj `if test -f 'config/tc-ns32k.c'; then $(CYGPATH_W) 'config/tc-ns32k.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-ns32k.c'; fi`
 
-tc-openrisc.o: config/tc-openrisc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-openrisc.o -MD -MP -MF $(DEPDIR)/tc-openrisc.Tpo -c -o tc-openrisc.o `test -f 'config/tc-openrisc.c' || echo '$(srcdir)/'`config/tc-openrisc.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-openrisc.Tpo $(DEPDIR)/tc-openrisc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-openrisc.c' object='tc-openrisc.o' libtool=no @AMDEPBACKSLASH@
+tc-or1k.o: config/tc-or1k.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-or1k.o -MD -MP -MF $(DEPDIR)/tc-or1k.Tpo -c -o tc-or1k.o `test -f 'config/tc-or1k.c' || echo '$(srcdir)/'`config/tc-or1k.c
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-or1k.Tpo $(DEPDIR)/tc-or1k.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-or1k.c' object='tc-or1k.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-or1k.o `test -f 'config/tc-or1k.c' || echo '$(srcdir)/'`config/tc-or1k.c
+
+tc-or1k.obj: config/tc-or1k.c
+@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-or1k.obj -MD -MP -MF $(DEPDIR)/tc-or1k.Tpo -c -o tc-or1k.obj `if test -f 'config/tc-or1k.c'; then $(CYGPATH_W) 'config/tc-or1k.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-or1k.c'; fi`
+@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-or1k.Tpo $(DEPDIR)/tc-or1k.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-or1k.c' object='tc-or1k.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-openrisc.o `test -f 'config/tc-openrisc.c' || echo '$(srcdir)/'`config/tc-openrisc.c
-
-tc-openrisc.obj: config/tc-openrisc.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-openrisc.obj -MD -MP -MF $(DEPDIR)/tc-openrisc.Tpo -c -o tc-openrisc.obj `if test -f 'config/tc-openrisc.c'; then $(CYGPATH_W) 'config/tc-openrisc.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-openrisc.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-openrisc.Tpo $(DEPDIR)/tc-openrisc.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-openrisc.c' object='tc-openrisc.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-openrisc.obj `if test -f 'config/tc-openrisc.c'; then $(CYGPATH_W) 'config/tc-openrisc.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-openrisc.c'; fi`
-
-tc-or32.o: config/tc-or32.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-or32.o -MD -MP -MF $(DEPDIR)/tc-or32.Tpo -c -o tc-or32.o `test -f 'config/tc-or32.c' || echo '$(srcdir)/'`config/tc-or32.c
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-or32.Tpo $(DEPDIR)/tc-or32.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-or32.c' object='tc-or32.o' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-or32.o `test -f 'config/tc-or32.c' || echo '$(srcdir)/'`config/tc-or32.c
-
-tc-or32.obj: config/tc-or32.c
-@am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-or32.obj -MD -MP -MF $(DEPDIR)/tc-or32.Tpo -c -o tc-or32.obj `if test -f 'config/tc-or32.c'; then $(CYGPATH_W) 'config/tc-or32.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-or32.c'; fi`
-@am__fastdepCC_TRUE@	$(am__mv) $(DEPDIR)/tc-or32.Tpo $(DEPDIR)/tc-or32.Po
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='config/tc-or32.c' object='tc-or32.obj' libtool=no @AMDEPBACKSLASH@
-@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
-@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-or32.obj `if test -f 'config/tc-or32.c'; then $(CYGPATH_W) 'config/tc-or32.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-or32.c'; fi`
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o tc-or1k.obj `if test -f 'config/tc-or1k.c'; then $(CYGPATH_W) 'config/tc-or1k.c'; else $(CYGPATH_W) '$(srcdir)/config/tc-or1k.c'; fi`
 
 tc-pdp11.o: config/tc-pdp11.c
 @am__fastdepCC_TRUE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT tc-pdp11.o -MD -MP -MF $(DEPDIR)/tc-pdp11.Tpo -c -o tc-pdp11.o `test -f 'config/tc-pdp11.c' || echo '$(srcdir)/'`config/tc-pdp11.c
--- a/gas/config/obj-coff.h
+++ b/gas/config/obj-coff.h
@@ -77,11 +77,6 @@
 #endif
 #endif
 
-#ifdef TC_OR32
-#include "coff/or32.h"
-#define TARGET_FORMAT "coff-or32-big"
-#endif
-
 #ifdef TC_I960
 #include "coff/i960.h"
 #define TARGET_FORMAT "coff-Intel-little"
--- a/gas/config/tc-openrisc.c
+++ /dev/null
@@ -1,363 +0,0 @@
-/* tc-openrisc.c -- Assembler for the OpenRISC family.
-   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2009
-   Free Software Foundation.
-   Contributed by Johan Rydberg, jrydberg@opencores.org
-
-   This file is part of GAS, the GNU Assembler.
-
-   GAS is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GAS is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GAS; see the file COPYING.  If not, write to
-   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-#include "as.h"
-#include "subsegs.h"
-#include "symcat.h"
-#include "opcodes/openrisc-desc.h"
-#include "opcodes/openrisc-opc.h"
-#include "cgen.h"
-
-/* Structure to hold all of the different components describing
-   an individual instruction.  */
-typedef struct openrisc_insn openrisc_insn;
-
-struct openrisc_insn
-{
-  const CGEN_INSN *	insn;
-  const CGEN_INSN *	orig_insn;
-  CGEN_FIELDS		fields;
-#if CGEN_INT_INSN_P
-  CGEN_INSN_INT         buffer [1];
-#define INSN_VALUE(buf) (*(buf))
-#else
-  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
-#define INSN_VALUE(buf) (buf)
-#endif
-  char *		addr;
-  fragS *		frag;
-  int                   num_fixups;
-  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
-  int                   indices [MAX_OPERAND_INSTANCES];
-};
-
-
-const char comment_chars[]        = "#";
-const char line_comment_chars[]   = "#";
-const char line_separator_chars[] = ";";
-const char EXP_CHARS[]            = "eE";
-const char FLT_CHARS[]            = "dD";
-
-
-#define OPENRISC_SHORTOPTS "m:"
-const char * md_shortopts = OPENRISC_SHORTOPTS;
-
-struct option md_longopts[] =
-{
-  {NULL, no_argument, NULL, 0}
-};
-size_t md_longopts_size = sizeof (md_longopts);
-
-unsigned long openrisc_machine = 0; /* default */
-
-int
-md_parse_option (int c ATTRIBUTE_UNUSED, char * arg ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-void
-md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
-{
-}
-
-static void
-ignore_pseudo (int val ATTRIBUTE_UNUSED)
-{
-  discard_rest_of_line ();
-}
-
-const char openrisc_comment_chars [] = ";#";
-
-/* The target specific pseudo-ops which we support.  */
-const pseudo_typeS md_pseudo_table[] =
-{
-  { "word",     cons,           4 },
-  { "proc",     ignore_pseudo,  0 },
-  { "endproc",  ignore_pseudo,  0 },
-  { NULL, 	NULL, 		0 }
-};
-
-
-
-void
-md_begin (void)
-{
-  /* Initialize the `cgen' interface.  */
-
-  /* Set the machine number and endian.  */
-  gas_cgen_cpu_desc = openrisc_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
-                                              CGEN_CPU_OPEN_ENDIAN,
-                                              CGEN_ENDIAN_BIG,
-                                              CGEN_CPU_OPEN_END);
-  openrisc_cgen_init_asm (gas_cgen_cpu_desc);
-
-  /* This is a callback from cgen to gas to parse operands.  */
-  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
-}
-
-void
-md_assemble (char * str)
-{
-  static int last_insn_had_delay_slot = 0;
-  openrisc_insn insn;
-  char *    errmsg;
-
-  /* Initialize GAS's cgen interface for a new instruction.  */
-  gas_cgen_init_parse ();
-
-  insn.insn = openrisc_cgen_assemble_insn
-    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);
-
-  if (!insn.insn)
-    {
-      as_bad ("%s", errmsg);
-      return;
-    }
-
-  /* Doesn't really matter what we pass for RELAX_P here.  */
-  gas_cgen_finish_insn (insn.insn, insn.buffer,
-			CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);
-
-  last_insn_had_delay_slot
-    = CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);
-}
-
-
-/* The syntax in the manual says constants begin with '#'.
-   We just ignore it.  */
-
-void
-md_operand (expressionS * expressionP)
-{
-  if (* input_line_pointer == '#')
-    {
-      input_line_pointer ++;
-      expression (expressionP);
-    }
-}
-
-valueT
-md_section_align (segT segment, valueT size)
-{
-  int align = bfd_get_section_alignment (stdoutput, segment);
-  return ((size + (1 << align) - 1) & (-1 << align));
-}
-
-symbolS *
-md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-
-/* Interface to relax_segment.  */
-
-/* FIXME: Look through this.  */
-
-const relax_typeS md_relax_table[] =
-{
-/* The fields are:
-   1) most positive reach of this state,
-   2) most negative reach of this state,
-   3) how many bytes this mode will add to the size of the current frag
-   4) which index into the table to try if we can't fit into this one.  */
-
-  /* The first entry must be unused because an `rlx_more' value of zero ends
-     each list.  */
-  {1, 1, 0, 0},
-
-  /* The displacement used by GAS is from the end of the 2 byte insn,
-     so we subtract 2 from the following.  */
-  /* 16 bit insn, 8 bit disp -> 10 bit range.
-     This doesn't handle a branch in the right slot at the border:
-     the "& -4" isn't taken into account.  It's not important enough to
-     complicate things over it, so we subtract an extra 2 (or + 2 in -ve
-     case).  */
-  {511 - 2 - 2, -512 - 2 + 2, 0, 2 },
-  /* 32 bit insn, 24 bit disp -> 26 bit range.  */
-  {0x2000000 - 1 - 2, -0x2000000 - 2, 2, 0 },
-  /* Same thing, but with leading nop for alignment.  */
-  {0x2000000 - 1 - 2, -0x2000000 - 2, 4, 0 }
-};
-
-/* Return an initial guess of the length by which a fragment must grow to
-   hold a branch to reach its destination.
-   Also updates fr_type/fr_subtype as necessary.
-
-   Called just before doing relaxation.
-   Any symbol that is now undefined will not become defined.
-   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
-   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
-   Although it may not be explicit in the frag, pretend fr_var starts with a
-   0 value.  */
-
-int
-md_estimate_size_before_relax (fragS * fragP, segT segment)
-{
-  /* The only thing we have to handle here are symbols outside of the
-     current segment.  They may be undefined or in a different segment in
-     which case linker scripts may place them anywhere.
-     However, we can't finish the fragment here and emit the reloc as insn
-     alignment requirements may move the insn about.  */
-
-  if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
-    {
-      /* The symbol is undefined in this segment.
-	 Change the relaxation subtype to the max allowable and leave
-	 all further handling to md_convert_frag.  */
-      fragP->fr_subtype = 2;
-
-      {
-	const CGEN_INSN * insn;
-	int               i;
-
-	/* Update the recorded insn.
-	   Fortunately we don't have to look very far.
-	   FIXME: Change this to record in the instruction the next higher
-	   relaxable insn to use.  */
-	for (i = 0, insn = fragP->fr_cgen.insn; i < 4; i++, insn++)
-	  {
-	    if ((strcmp (CGEN_INSN_MNEMONIC (insn),
-			 CGEN_INSN_MNEMONIC (fragP->fr_cgen.insn))
-		 == 0)
-		&& CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED))
-	      break;
-	  }
-	if (i == 4)
-	  abort ();
-
-	fragP->fr_cgen.insn = insn;
-	return 2;
-      }
-    }
-
-  return md_relax_table[fragP->fr_subtype].rlx_length;
-}
-
-/* *fragP has been relaxed to its final size, and now needs to have
-   the bytes inside it modified to conform to the new size.
-
-   Called after relaxation is finished.
-   fragP->fr_type == rs_machine_dependent.
-   fragP->fr_subtype is the subtype of what the address relaxed to.  */
-
-void
-md_convert_frag (bfd *   abfd ATTRIBUTE_UNUSED,
-		 segT    sec  ATTRIBUTE_UNUSED,
-		 fragS * fragP ATTRIBUTE_UNUSED)
-{
-  /* FIXME */
-}
-
-
-/* Functions concerning relocs.  */
-
-/* The location from which a PC relative jump should be calculated,
-   given a PC relative reloc.  */
-
-long
-md_pcrel_from_section (fixS * fixP, segT sec)
-{
-  if (fixP->fx_addsy != (symbolS *) NULL
-      && (! S_IS_DEFINED (fixP->fx_addsy)
-	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
-    /* The symbol is undefined (or is defined but not in this section).
-       Let the linker figure it out.  */
-    return 0;
-
-  return (fixP->fx_frag->fr_address + fixP->fx_where) & ~1;
-}
-
-
-/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
-   Returns BFD_RELOC_NONE if no reloc type can be found.
-   *FIXP may be modified if desired.  */
-
-bfd_reloc_code_real_type
-md_cgen_lookup_reloc (const CGEN_INSN *    insn ATTRIBUTE_UNUSED,
-		      const CGEN_OPERAND * operand,
-		      fixS *               fixP)
-{
-  bfd_reloc_code_real_type type;
-
-  switch (operand->type)
-    {
-    case OPENRISC_OPERAND_ABS_26:
-      fixP->fx_pcrel = 0;
-      type = BFD_RELOC_OPENRISC_ABS_26;
-      goto emit;
-    case OPENRISC_OPERAND_DISP_26:
-      fixP->fx_pcrel = 1;
-      type = BFD_RELOC_OPENRISC_REL_26;
-      goto emit;
-
-    case OPENRISC_OPERAND_HI16:
-      type = BFD_RELOC_HI16;
-      goto emit;
-
-    case OPENRISC_OPERAND_LO16:
-      type = BFD_RELOC_LO16;
-      goto emit;
-
-    emit:
-      return type;
-
-    default : /* avoid -Wall warning */
-      break;
-    }
-
-  return BFD_RELOC_NONE;
-}
-
-/* Write a value out to the object file, using the appropriate endianness.  */
-
-void
-md_number_to_chars (char * buf, valueT val, int n)
-{
-  number_to_chars_bigendian (buf, val, n);
-}
-
-/* Turn a string in input_line_pointer into a floating point constant of type
-   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
-   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
-*/
-
-/* Equal to MAX_PRECISION in atof-ieee.c */
-#define MAX_LITTLENUMS 6
-
-char *
-md_atof (int type, char * litP, int *  sizeP)
-{
-  return ieee_md_atof (type, litP, sizeP, TRUE);
-}
-
-bfd_boolean
-openrisc_fix_adjustable (fixS * fixP)
-{
-  /* We need the symbol name for the VTABLE entries.  */
-  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
-      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
-    return 0;
-
-  return 1;
-}
--- a/gas/config/tc-openrisc.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* tc-openrisc.h -- Header file for tc-openrisc.c.
-   Copyright 2001, 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
-
-   This file is part of GAS, the GNU Assembler.
-
-   GAS is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GAS is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GAS; see the file COPYING.  If not, write to
-   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-#define TC_OPENRISC
-
-#define LISTING_HEADER "OpenRISC GAS "
-
-/* The target BFD architecture.  */
-#define TARGET_ARCH bfd_arch_openrisc
-
-extern unsigned long openrisc_machine;
-#define TARGET_MACH (openrisc_machine)
-
-#define TARGET_FORMAT		"elf32-openrisc"
-#define TARGET_BYTES_BIG_ENDIAN	1
-
-extern const char openrisc_comment_chars [];
-#define tc_comment_chars openrisc_comment_chars
-
-/* Permit temporary numeric labels.  */
-#define LOCAL_LABELS_FB	1
-
-#define DIFF_EXPR_OK	1	/* .-foo gets turned into PC relative relocs */
-
-/* We don't need to handle .word strangely.  */
-#define WORKING_DOT_WORD
-
-/* Values passed to md_apply_fix don't include the symbol value.  */
-#define MD_APPLY_SYM_VALUE(FIX) 0
-
-#define md_apply_fix gas_cgen_md_apply_fix
-
-extern bfd_boolean openrisc_fix_adjustable (struct fix *);
-#define tc_fix_adjustable(FIX) openrisc_fix_adjustable (FIX)
-
-#define tc_gen_reloc gas_cgen_tc_gen_reloc
-
-/* Call md_pcrel_from_section(), not md_pcrel_from().  */
-extern long md_pcrel_from_section (struct fix *, segT);
-#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
-
-/* For 8 vs 16 vs 32 bit branch selection.  */
-extern const struct relax_type md_relax_table[];
-#define TC_GENERIC_RELAX_TABLE md_relax_table
--- /dev/null
+++ b/gas/config/tc-or1k.c
@@ -0,0 +1,368 @@
+/* tc-or1k.c -- Assembler for the OpenRISC family.
+   Copyright 2001, 2002, 2003, 2005, 2006, 2007, 2009
+   Free Software Foundation.
+   Contributed by Johan Rydberg, jrydberg@opencores.org
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+#include "as.h"
+#include "safe-ctype.h"
+#include "subsegs.h"
+#include "symcat.h"
+#include "opcodes/or1k-desc.h"
+#include "opcodes/or1k-opc.h"
+#include "cgen.h"
+#include "elf/or1k.h"
+#include "dw2gencfi.h"
+
+/* Structure to hold all of the different components describing
+   an individual instruction.  */
+//typedef struct or1k_insn or1k_insn;
+
+typedef struct// or1k_insn
+{
+  const CGEN_INSN *	insn;
+  const CGEN_INSN *	orig_insn;
+  CGEN_FIELDS		fields;
+#if CGEN_INT_INSN_P
+  CGEN_INSN_INT         buffer [1];
+#define INSN_VALUE(buf) (*(buf))
+#else
+  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
+#define INSN_VALUE(buf) (buf)
+#endif
+  char *		addr;
+  fragS *		frag;
+  int                   num_fixups;
+  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
+  int                   indices [MAX_OPERAND_INSTANCES];
+} 
+or1k_insn;
+
+const char comment_chars[]        = "#";
+const char line_comment_chars[]   = "#";
+const char line_separator_chars[] = ";";
+const char EXP_CHARS[]            = "eE";
+const char FLT_CHARS[]            = "dD";
+
+
+#define OR1K_SHORTOPTS "m:"
+const char * md_shortopts = OR1K_SHORTOPTS;
+
+struct option md_longopts[] =
+{
+  {NULL, no_argument, NULL, 0}
+};
+size_t md_longopts_size = sizeof (md_longopts);
+
+unsigned long or1k_machine = 0; /* default */
+
+int
+md_parse_option (int c ATTRIBUTE_UNUSED, char * arg ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+void
+md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
+{
+}
+
+static void
+ignore_pseudo (int val ATTRIBUTE_UNUSED)
+{
+  discard_rest_of_line ();
+}
+
+static bfd_boolean nodelay = FALSE;
+static void
+s_nodelay (int val ATTRIBUTE_UNUSED)
+{
+  nodelay = TRUE;
+}
+
+const char or1k_comment_chars [] = ";#";
+
+/* The target specific pseudo-ops which we support.  */
+const pseudo_typeS md_pseudo_table[] =
+{
+  { "align",    s_align_bytes,  0 },
+  { "word",     cons,           4 },
+  { "proc",     ignore_pseudo,  0 },
+  { "endproc",  ignore_pseudo,  0 },
+  { "nodelay",  s_nodelay,      0 },
+  { NULL, 	NULL, 		0 }
+};
+
+
+
+void
+md_begin (void)
+{
+  /* Initialize the `cgen' interface.  */
+
+  /* Set the machine number and endian.  */
+  gas_cgen_cpu_desc = or1k_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
+                                              CGEN_CPU_OPEN_ENDIAN,
+                                              CGEN_ENDIAN_BIG,
+                                              CGEN_CPU_OPEN_END);
+  or1k_cgen_init_asm (gas_cgen_cpu_desc);
+
+  /* This is a callback from cgen to gas to parse operands.  */
+  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);
+}
+
+void
+md_assemble (char * str)
+{
+  static int last_insn_had_delay_slot = 0;
+  or1k_insn insn;
+  char *    errmsg;
+
+  /* Initialize GAS's cgen interface for a new instruction.  */
+  gas_cgen_init_parse ();
+
+  insn.insn = or1k_cgen_assemble_insn
+    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);
+
+  if (!insn.insn)
+    {
+      as_bad ("%s", errmsg);
+      return;
+    }
+
+  /* Doesn't really matter what we pass for RELAX_P here.  */
+  gas_cgen_finish_insn (insn.insn, insn.buffer,
+			CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);
+
+  last_insn_had_delay_slot
+    = CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_DELAY_SLOT);
+  (void) last_insn_had_delay_slot;
+}
+
+
+/* The syntax in the manual says constants begin with '#'.
+   We just ignore it.  */
+
+void
+md_operand (expressionS * expressionP)
+{
+  if (* input_line_pointer == '#')
+    {
+      input_line_pointer ++;
+      expression (expressionP);
+    }
+}
+
+valueT
+md_section_align (segT segment, valueT size)
+{
+  int align = bfd_get_section_alignment (stdoutput, segment);
+  return ((size + (1 << align) - 1) & (-1 << align));
+}
+
+symbolS *
+md_undefined_symbol (char * name ATTRIBUTE_UNUSED)
+{
+  return 0;
+}
+
+
+/* Interface to relax_segment.  */
+
+const relax_typeS md_relax_table[] =
+{
+/* The fields are:
+   1) most positive reach of this state,
+   2) most negative reach of this state,
+   3) how many bytes this mode will add to the size of the current frag
+   4) which index into the table to try if we can't fit into this one.  */
+
+  /* The first entry must be unused because an `rlx_more' value of zero ends
+     each list.  */
+  {1, 1, 0, 0},
+
+  /* The displacement used by GAS is from the end of the 4 byte insn,
+     so we subtract 4 from the following.  */
+  {(((1 << 25) - 1) << 2) - 4, -(1 << 25) - 4, 0, 0},
+};
+
+int
+md_estimate_size_before_relax (fragS * fragP, segT segment ATTRIBUTE_UNUSED)
+{
+  return md_relax_table[fragP->fr_subtype].rlx_length;
+}
+
+/* *fragP has been relaxed to its final size, and now needs to have
+   the bytes inside it modified to conform to the new size.
+
+   Called after relaxation is finished.
+   fragP->fr_type == rs_machine_dependent.
+   fragP->fr_subtype is the subtype of what the address relaxed to.  */
+
+void
+md_convert_frag (bfd *   abfd ATTRIBUTE_UNUSED,
+		 segT    sec  ATTRIBUTE_UNUSED,
+		 fragS * fragP ATTRIBUTE_UNUSED)
+{
+  /* FIXME */
+}
+
+
+/* Functions concerning relocs.  */
+
+/* The location from which a PC relative jump should be calculated,
+   given a PC relative reloc.  */
+
+long
+md_pcrel_from_section (fixS * fixP, segT sec)
+{
+  if (fixP->fx_addsy != (symbolS *) NULL
+      && (! S_IS_DEFINED (fixP->fx_addsy)
+	  || (S_GET_SEGMENT (fixP->fx_addsy) != sec)
+	  || S_IS_EXTERNAL (fixP->fx_addsy)
+	  || S_IS_WEAK (fixP->fx_addsy)))
+    {
+        /* The symbol is undefined (or is defined but not in this section).
+         Let the linker figure it out.  */
+      return 0;
+    }
+
+  return fixP->fx_frag->fr_address + fixP->fx_where;
+}
+
+
+/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
+   Returns BFD_RELOC_NONE if no reloc type can be found.
+   *FIXP may be modified if desired.  */
+
+bfd_reloc_code_real_type
+md_cgen_lookup_reloc (const CGEN_INSN *    insn ATTRIBUTE_UNUSED,
+		      const CGEN_OPERAND * operand,
+		      fixS *               fixP)
+{
+  if (fixP->fx_cgen.opinfo) {
+      return fixP->fx_cgen.opinfo;
+  } else {
+    switch (operand->type)
+      {
+      case OR1K_OPERAND_DISP26:
+        fixP->fx_pcrel = 1;
+        return BFD_RELOC_OR1K_REL_26;
+        
+      default: /* avoid -Wall warning */
+        return BFD_RELOC_NONE;
+      }
+  }
+}
+
+/* Write a value out to the object file, using the appropriate endianness.  */
+
+void
+md_number_to_chars (char * buf, valueT val, int n)
+{
+  number_to_chars_bigendian (buf, val, n);
+}
+
+/* Turn a string in input_line_pointer into a floating point constant of type
+   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
+   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
+*/
+
+/* Equal to MAX_PRECISION in atof-ieee.c */
+#define MAX_LITTLENUMS 6
+
+char *
+md_atof (int type, char * litP, int *  sizeP)
+{
+  return ieee_md_atof (type, litP, sizeP, TRUE);
+}
+
+bfd_boolean
+or1k_fix_adjustable (fixS * fixP)
+{
+  /* We need the symbol name for the VTABLE entries.  */
+  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
+      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
+    return 0;
+
+  return 1;
+}
+
+#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
+
+arelent *
+tc_gen_reloc (asection *sec, fixS *fx)
+{
+  bfd_reloc_code_real_type code = fx->fx_r_type;
+
+  if (fx->fx_addsy != NULL
+      && strcmp (S_GET_NAME (fx->fx_addsy), GOT_NAME) == 0
+      && (code == BFD_RELOC_OR1K_GOTPC_HI16
+	  || code == BFD_RELOC_OR1K_GOTPC_LO16))
+    {
+      arelent * reloc;
+
+      reloc = xmalloc (sizeof (* reloc));
+      reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
+      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fx->fx_addsy);
+      reloc->address = fx->fx_frag->fr_address + fx->fx_where;
+      reloc->howto = bfd_reloc_type_lookup (stdoutput, fx->fx_r_type);
+      reloc->addend = fx->fx_offset;
+      return reloc;
+    }
+
+  return gas_cgen_tc_gen_reloc (sec, fx);
+}
+
+void
+or1k_apply_fix (struct fix *f, valueT *t, segT s)
+{
+  gas_cgen_md_apply_fix (f, t, s);
+  switch(f->fx_r_type)
+  {
+    case BFD_RELOC_OR1K_TLS_GD_HI16:
+    case BFD_RELOC_OR1K_TLS_GD_LO16:
+    case BFD_RELOC_OR1K_TLS_LDM_HI16:
+    case BFD_RELOC_OR1K_TLS_LDM_LO16:
+    case BFD_RELOC_OR1K_TLS_LDO_HI16:
+    case BFD_RELOC_OR1K_TLS_LDO_LO16:
+    case BFD_RELOC_OR1K_TLS_IE_HI16:
+    case BFD_RELOC_OR1K_TLS_IE_LO16:
+    case BFD_RELOC_OR1K_TLS_LE_HI16:
+    case BFD_RELOC_OR1K_TLS_LE_LO16:
+      S_SET_THREAD_LOCAL (f->fx_addsy);
+      break;
+    default:
+      break;
+  }
+}
+
+void
+or1k_elf_final_processing (void)
+{
+  if (nodelay)
+    elf_elfheader (stdoutput)->e_flags |= EF_OR1K_NODELAY;
+}
+
+/* Standard calling conventions leave the CFA at SP on entry.  */
+void
+or1k_cfi_frame_initial_instructions (void)
+{
+    cfi_add_CFA_def_cfa_register (1);
+}
+
--- /dev/null
+++ b/gas/config/tc-or1k.h
@@ -0,0 +1,81 @@
+/* tc-or1k.h -- Header file for tc-or1k.c.
+   Copyright 2001, 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
+
+   This file is part of GAS, the GNU Assembler.
+
+   GAS is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GAS is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GAS; see the file COPYING.  If not, write to
+   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#define TC_OR1K
+
+#define LISTING_HEADER "Or1k GAS "
+
+/* The target BFD architecture.  */
+#define TARGET_ARCH bfd_arch_or1k
+
+extern unsigned long or1k_machine;
+#define TARGET_MACH (or1k_machine)
+
+#define TARGET_FORMAT		"elf32-or1k"
+#define TARGET_BYTES_BIG_ENDIAN	1
+
+extern const char or1k_comment_chars [];
+#define tc_comment_chars or1k_comment_chars
+
+/* Permit temporary numeric labels.  */
+#define LOCAL_LABELS_FB	1
+
+#define DIFF_EXPR_OK	1	/* .-foo gets turned into PC relative relocs */
+
+/* We don't need to handle .word strangely.  */
+#define WORKING_DOT_WORD
+
+/* Values passed to md_apply_fix don't include the symbol value.  */
+#define MD_APPLY_SYM_VALUE(FIX) 0
+
+#define md_apply_fix or1k_apply_fix
+extern void or1k_apply_fix (struct fix *, valueT *, segT);
+
+extern bfd_boolean or1k_fix_adjustable (struct fix *);
+#define tc_fix_adjustable(FIX) or1k_fix_adjustable (FIX)
+
+/* Call md_pcrel_from_section(), not md_pcrel_from().  */
+extern long md_pcrel_from_section (struct fix *, segT);
+#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from_section (FIX, SEC)
+
+/* For 8 vs 16 vs 32 bit branch selection.  */
+extern const struct relax_type md_relax_table[];
+#define TC_GENERIC_RELAX_TABLE md_relax_table
+
+#define GAS_CGEN_PCREL_R_TYPE(r_type) gas_cgen_pcrel_r_type(r_type)
+
+#define elf_tc_final_processing or1k_elf_final_processing
+void or1k_elf_final_processing (void);
+
+/* Enable cfi directives.  */
+#define TARGET_USE_CFIPOP 1
+
+/* Stack grows to lower addresses and wants 4 byte boundary */
+#define DWARF2_CIE_DATA_ALIGNMENT -4
+
+/* Define the column that represents the PC.  */
+#define DWARF2_DEFAULT_RETURN_COLUMN 9
+
+/* or1k instructions are 4 bytes long.  */
+#define DWARF2_LINE_MIN_INSN_LENGTH 	4
+
+#define tc_cfi_frame_initial_instructions \
+    or1k_cfi_frame_initial_instructions
+extern void or1k_cfi_frame_initial_instructions (void);
--- a/gas/config/tc-or32.c
+++ /dev/null
@@ -1,967 +0,0 @@
-/* Assembly backend for the OpenRISC 1000.
-   Copyright (C) 2002, 2003, 2005, 2007, 2009, 2010, 2012
-   Free Software Foundation, Inc.
-   Contributed by Damjan Lampret <lampret@opencores.org>.
-   Modified bu Johan Rydberg, <johan.rydberg@netinsight.se>.
-   Based upon a29k port.
-
-   This file is part of GAS, the GNU Assembler.
-
-   GAS is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GAS is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GAS; see the file COPYING.  If not, write to
-   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-/* tc-a29k.c used as a template.  */
-
-#include "as.h"
-#include "safe-ctype.h"
-#include "opcode/or32.h"
-#include "elf/or32.h"
-
-#define DEBUG 0
-
-#ifndef REGISTER_PREFIX
-#define REGISTER_PREFIX   '%'
-#endif
-
-/* Make it easier to clone this machine desc into another one.  */
-#define machine_opcode  or32_opcode
-#define machine_opcodes or32_opcodes
-#define machine_ip      or32_ip
-#define machine_it      or32_it
-
-/* Handle of the OPCODE hash table.  */
-static struct hash_control *op_hash = NULL;
-
-struct machine_it
-{
-  char *          error;
-  unsigned long   opcode;
-  struct nlist *  nlistp;
-  expressionS     exp;
-  int             pcrel;
-  int             reloc_offset;   /* Offset of reloc within insn.  */
-  int             reloc;
-}
-the_insn;
-
-const pseudo_typeS md_pseudo_table[] =
-{
-  {"align",   s_align_bytes,  4 },
-  {"space",   s_space,        0 },
-  {"cputype", s_ignore,       0 },
-  {"reg",     s_lsym,         0 },  /* Register equate, same as equ.  */
-  {"sect",    s_ignore,       0 },  /* Creation of coff sections.  */
-  {"proc",    s_ignore,       0 },  /* Start of a function.  */
-  {"endproc", s_ignore,       0 },  /* Function end.  */
-  {"word",    cons,           4 },
-  {NULL,      0,              0 },
-};
-
-int md_short_jump_size  = 4;
-int md_long_jump_size   = 4;
-
-/* This array holds the chars that always start a comment.
-   If the pre-processor is disabled, these aren't very useful.  */
-const char comment_chars[] = "#";
-
-/* This array holds the chars that only start a comment at the beginning of
-   a line.  If the line seems to have the form '# 123 filename'
-   .line and .file directives will appear in the pre-processed output.  */
-/* Note that input_file.c hand checks for '#' at the beginning of the
-   first line of the input file.  This is because the compiler outputs
-   #NO_APP at the beginning of its output.  */
-/* Also note that comments like this one will always work.  */
-const char line_comment_chars[] = "#";
-
-/* We needed an unused char for line separation to work around the
-   lack of macros, using sed and such.  */
-const char line_separator_chars[] = ";";
-
-/* Chars that can be used to separate mant from exp in floating point nums.  */
-const char EXP_CHARS[] = "eE";
-
-/* Chars that mean this number is a floating point constant.
-   As in 0f12.456
-   or    0d1.2345e12.  */
-const char FLT_CHARS[] = "rRsSfFdDxXpP";
-
-/* "l.jalr r9" precalculated opcode.  */
-static unsigned long jalr_r9_opcode;
-
-static void machine_ip (char *);
-
-
-/* Set bits in machine opcode according to insn->encoding
-   description and passed operand.  */
-
-static void
-encode (const struct machine_opcode *insn,
-	unsigned long *opcode,
-	signed long param_val,
-	char param_ch)
-{
-  int opc_pos = 0;
-  int param_pos = 0;
-  char *enc;
-
-#if DEBUG
-  printf ("    encode:  opcode=%.8lx  param_val=%.8lx abs=%.8lx param_ch=%c\n",
-	  *opcode, param_val, abs (param_val), param_ch);
-#endif
-  for (enc = insn->encoding; *enc != '\0'; enc++)
-    if (*enc == param_ch)
-      {
-	if (enc - 2 >= insn->encoding && (*(enc - 2) == '0') && (*(enc - 1) == 'x'))
-	  continue;
-	else
-	  param_pos ++;
-      }
-
-  opc_pos = 32;
-
-  for (enc = insn->encoding; *enc != '\0';)
-    {
-      if ((*enc == '0') && (*(enc + 1) == 'x'))
-	{
-	  int tmp = strtol (enc, NULL, 16);
-
-	  opc_pos -= 4;
-	  *opcode |= tmp << opc_pos;
-	  enc += 3;
-	}
-      else if ((*enc == '0') || (*enc == '-'))
-	{
-	  opc_pos--;
-	  enc++;
-	}
-      else if (*enc == '1')
-	{
-	  opc_pos--;
-	  *opcode |= 1 << opc_pos;
-	  enc++;
-	}
-      else if (*enc == param_ch)
-	{
-	  opc_pos--;
-	  param_pos--;
-	  *opcode |= ((param_val >> param_pos) & 0x1) << opc_pos;
-	  enc++;
-	}
-      else if (ISALPHA (*enc))
-	{
-	  opc_pos--;
-	  enc++;
-	}
-      else
-	enc++;
-    }
-
-#if DEBUG
-  printf ("    opcode=%.8lx\n", *opcode);
-#endif
-}
-
-/* This function is called once, at assembler startup time.  It should
-   set up all the tables, etc., that the MD part of the assembler will
-   need.  */
-
-void
-md_begin (void)
-{
-  const char *retval = NULL;
-  int lose = 0;
-  int skipnext = 0;
-  unsigned int i;
-
-  /* Hash up all the opcodes for fast use later.  */
-  op_hash = hash_new ();
-
-  for (i = 0; i < or32_num_opcodes; i++)
-    {
-      const char *name = machine_opcodes[i].name;
-
-      if (skipnext)
-        {
-          skipnext = 0;
-          continue;
-        }
-
-      retval = hash_insert (op_hash, name, (void *) &machine_opcodes[i]);
-      if (retval != NULL)
-        {
-          fprintf (stderr, "internal error: can't hash `%s': %s\n",
-                   machine_opcodes[i].name, retval);
-          lose = 1;
-        }
-    }
-
-  if (lose)
-    as_fatal (_("Broken assembler.  No assembly attempted."));
-
-  encode (&machine_opcodes[insn_index ("l.jalr")], &jalr_r9_opcode, 9, 'B');
-}
-
-/* Returns non zero if instruction is to be used.  */
-
-static int
-check_invalid_opcode (unsigned long opcode)
-{
-  return opcode == jalr_r9_opcode;
-}
-
-/* Assemble a single instruction.  Its label has already been handled
-   by the generic front end.  We just parse opcode and operands, and
-   produce the bytes of data and relocation.  */
-
-void
-md_assemble (char *str)
-{
-  char *toP;
-
-#if DEBUG
-  printf ("NEW INSTRUCTION\n");
-#endif
-
-  know (str);
-  machine_ip (str);
-  toP = frag_more (4);
-
-  /* Put out the opcode.  */
-  md_number_to_chars (toP, the_insn.opcode, 4);
-
-  /* Put out the symbol-dependent stuff.  */
-  if (the_insn.reloc != BFD_RELOC_NONE)
-    {
-      fix_new_exp (frag_now,
-                   (toP - frag_now->fr_literal + the_insn.reloc_offset),
-                   4,   /* size */
-                   &the_insn.exp,
-                   the_insn.pcrel,
-                   the_insn.reloc);
-    }
-}
-
-/* This is true of the we have issued a "lo(" or "hi"(.  */
-static int waiting_for_shift = 0;
-
-static int mask_or_shift = 0;
-
-static char *
-parse_operand (char *s, expressionS *operandp, int opt)
-{
-  char *save = input_line_pointer;
-  char *new_pointer;
-
-#if DEBUG
-  printf ("  PROCESS NEW OPERAND(%s) == %c (%d)\n", s, opt ? opt : '!', opt);
-#endif
-
-  input_line_pointer = s;
-
-  if (strncasecmp (s, "HI(", 3) == 0)
-    {
-      waiting_for_shift = 1;
-      mask_or_shift = BFD_RELOC_HI16;
-
-      input_line_pointer += 3;
-    }
-  else if (strncasecmp (s, "LO(", 3) == 0)
-    {
-      mask_or_shift = BFD_RELOC_LO16;
-
-      input_line_pointer += 3;
-    }
-  else
-    mask_or_shift = 0;
-
-  if ((*s == '(') && (*(s+1) == 'r'))
-    s++;
-
-  if ((*s == 'r') && ISDIGIT (*(s + 1)))
-    {
-      operandp->X_add_number = strtol (s + 1, NULL, 10);
-      operandp->X_op = O_register;
-      for (; (*s != ',') && (*s != '\0');)
-        s++;
-      input_line_pointer = save;
-      return s;
-    }
-
-  expression (operandp);
-
-  if (operandp->X_op == O_absent)
-    {
-      if (! opt)
-        as_bad (_("missing operand"));
-      else
-        {
-          operandp->X_add_number = 0;
-          operandp->X_op = O_constant;
-        }
-    }
-
-  new_pointer = input_line_pointer;
-  input_line_pointer = save;
-
-#if DEBUG
-  printf ("  %s=parse_operand(%s): operandp->X_op = %u\n", new_pointer, s,
-          operandp->X_op);
-#endif
-
-  return new_pointer;
-}
-
-/* Instruction parsing.  Takes a string containing the opcode.
-   Operands are at input_line_pointer.  Output is in the_insn.
-   Warnings or errors are generated.  */
-
-static void
-machine_ip (char *str)
-{
-  char *s;
-  const char *args;
-  const struct machine_opcode *insn;
-  unsigned long opcode;
-  expressionS the_operand;
-  expressionS *operand = &the_operand;
-  unsigned int regno;
-  int reloc = BFD_RELOC_NONE;
-
-#if DEBUG
-  printf ("machine_ip(%s)\n", str);
-#endif
-
-  s = str;
-  for (; ISALNUM (*s) || *s == '.'; ++s)
-    if (ISUPPER (*s))
-      *s = TOLOWER (*s);
-
-  switch (*s)
-    {
-    case '\0':
-      break;
-
-    case ' ':     /* FIXME-SOMEDAY more whitespace.  */
-      *s++ = '\0';
-      break;
-
-    default:
-      as_bad (_("unknown opcode1: `%s'"), str);
-      return;
-    }
-
-  if ((insn = (struct machine_opcode *) hash_find (op_hash, str)) == NULL)
-    {
-      as_bad (_("unknown opcode2 `%s'."), str);
-      return;
-    }
-
-  opcode = 0;
-  memset (&the_insn, '\0', sizeof (the_insn));
-  the_insn.reloc = BFD_RELOC_NONE;
-
-  reloc = BFD_RELOC_NONE;
-
-  /* Build the opcode, checking as we go to make sure that the
-     operands match.
-
-     If an operand matches, we modify the_insn or opcode appropriately,
-     and do a "continue".  If an operand fails to match, we "break".  */
-  if (insn->args[0] != '\0')
-    /* Prime the pump.  */
-    s = parse_operand (s, operand, insn->args[0] == 'I');
-
-  for (args = insn->args;; ++args)
-    {
-#if DEBUG
-      printf ("  args = %s\n", args);
-#endif
-      switch (*args)
-        {
-        case '\0':    /* End of args.  */
-          /* We have have 0 args, do the bazoooka!  */
-          if (args == insn->args)
-	    encode (insn, &opcode, 0, 0);
-
-          if (*s == '\0')
-            {
-              /* We are truly done.  */
-              the_insn.opcode = opcode;
-              if (check_invalid_opcode (opcode))
-                as_bad (_("instruction not allowed: %s"), str);
-              return;
-            }
-          as_bad (_("too many operands: %s"), s);
-          break;
-
-        case ',':   /* Must match a comma.  */
-          if (*s++ == ',')
-            {
-              reloc = BFD_RELOC_NONE;
-
-              /* Parse next operand.  */
-              s = parse_operand (s, operand, args[1] == 'I');
-#if DEBUG
-	      printf ("    ',' case: operand->X_add_number = %d, *args = %s, *s = %s\n",
-		      operand->X_add_number, args, s);
-#endif
-              continue;
-            }
-          break;
-
-        case '(':   /* Must match a (.  */
-          s = parse_operand (s, operand, args[1] == 'I');
-          continue;
-
-        case ')':   /* Must match a ).  */
-          continue;
-
-        case 'r':   /* A general register.  */
-          args++;
-
-          if (operand->X_op != O_register)
-            break;    /* Only registers.  */
-
-          know (operand->X_add_symbol == 0);
-          know (operand->X_op_symbol == 0);
-          regno = operand->X_add_number;
-          encode (insn, &opcode, regno, *args);
-#if DEBUG
-          printf ("    r: operand->X_op = %d\n", operand->X_op);
-#endif
-          continue;
-
-        default:
-          /* if (! ISALPHA (*args))
-               break;  */   /* Only immediate values.  */
-
-          if (mask_or_shift)
-	    {
-#if DEBUG
-	      printf ("mask_or_shift = %d\n", mask_or_shift);
-#endif
-	      reloc = mask_or_shift;
-	    }
-          mask_or_shift = 0;
-
-          if (strncasecmp (args, "LO(", 3) == 0)
-            {
-#if DEBUG
-              printf ("reloc_const\n");
-#endif
-              reloc = BFD_RELOC_LO16;
-            }
-          else if (strncasecmp (args, "HI(", 3) == 0)
-            {
-#if DEBUG
-              printf ("reloc_consth\n");
-#endif
-              reloc = BFD_RELOC_HI16;
-            }
-
-          if (*s == '(')
-	    operand->X_op = O_constant;
-          else if (*s == ')')
-            s += 1;
-#if DEBUG
-          printf ("    default case: operand->X_add_number = %d, *args = %s, *s = %s\n", operand->X_add_number, args, s);
-#endif
-          if (operand->X_op == O_constant)
-            {
-	      if (reloc == BFD_RELOC_NONE)
-		{
-		  bfd_vma v, mask;
-
-		  mask = 0x3ffffff;
-		  v = abs (operand->X_add_number) & ~ mask;
-		  if (v)
-		    as_bad (_("call/jmp target out of range (1)"));
-		}
-
-              if (reloc == BFD_RELOC_HI16)
-		operand->X_add_number = ((operand->X_add_number >> 16) & 0xffff);
-
-              the_insn.pcrel = 0;
-              encode (insn, &opcode, operand->X_add_number, *args);
- /*             the_insn.reloc = BFD_RELOC_NONE; */
-              continue;
-            }
-
-          if (reloc == BFD_RELOC_NONE)
-            the_insn.reloc = BFD_RELOC_32_GOT_PCREL;
-          else
-            the_insn.reloc = reloc;
-
-          /* the_insn.reloc = insn->reloc;  */
-#if DEBUG
-          printf ("    reloc sym=%d\n", the_insn.reloc);
-          printf ("    BFD_RELOC_NONE=%d\n", BFD_RELOC_NONE);
-#endif
-          the_insn.exp = *operand;
-
-          /*  the_insn.reloc_offset = 1;  */
-          the_insn.pcrel = 1; /* Assume PC-relative jump.  */
-
-          /* FIXME-SOON, Do we figure out whether abs later, after
-             know sym val?  */
-          if (reloc == BFD_RELOC_LO16 || reloc == BFD_RELOC_HI16)
-            the_insn.pcrel = 0;
-
-          encode (insn, &opcode, operand->X_add_number, *args);
-          continue;
-        }
-
-      /* Types or values of args don't match.  */
-      as_bad (_("invalid operands"));
-      return;
-    }
-}
-
-char *
-md_atof (int type, char * litP, int *  sizeP)
-{
-  return ieee_md_atof (type, litP, sizeP, TRUE);
-}
-
-/* Write out big-endian.  */
-
-void
-md_number_to_chars (char *buf, valueT val, int n)
-{
-  number_to_chars_bigendian (buf, val, n);
-}
-
-void
-md_apply_fix (fixS * fixP, valueT * val, segT seg ATTRIBUTE_UNUSED)
-{
-  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
-  long t_val;
-
-  t_val = (long) *val;
-
-#if DEBUG
-  printf ("md_apply_fix val:%x\n", t_val);
-#endif
-
-  fixP->fx_addnumber = t_val; /* Remember value for emit_reloc.  */
-
-  switch (fixP->fx_r_type)
-    {
-    case BFD_RELOC_32:      /* XXXXXXXX pattern in a word.  */
-#if DEBUG
-      printf ("reloc_const: val=%x\n", t_val);
-#endif
-      buf[0] = t_val >> 24;
-      buf[1] = t_val >> 16;
-      buf[2] = t_val >> 8;
-      buf[3] = t_val;
-      break;
-
-    case BFD_RELOC_16:      /* XXXX0000 pattern in a word.  */
-#if DEBUG
-      printf ("reloc_const: val=%x\n", t_val);
-#endif
-      buf[0] = t_val >> 8;
-      buf[1] = t_val;
-      break;
-
-    case BFD_RELOC_8:      /* XX000000 pattern in a word.  */
-#if DEBUG
-      printf ("reloc_const: val=%x\n", t_val);
-#endif
-      buf[0] = t_val;
-      break;
-
-    case BFD_RELOC_LO16:      /* 0000XXXX pattern in a word.  */
-#if DEBUG
-      printf ("reloc_const: val=%x\n", t_val);
-#endif
-      buf[2] = t_val >> 8;  /* Holds bits 0000XXXX.  */
-      buf[3] = t_val;
-      break;
-
-    case BFD_RELOC_HI16:    /* 0000XXXX pattern in a word.  */
-#if DEBUG
-      printf ("reloc_consth: val=%x\n", t_val);
-#endif
-      buf[2] = t_val >> 24; /* Holds bits XXXX0000.  */
-      buf[3] = t_val >> 16;
-      break;
-
-    case BFD_RELOC_32_GOT_PCREL:  /* 0000XXXX pattern in a word.  */
-      if (!fixP->fx_done)
-        ;
-      else if (fixP->fx_pcrel)
-        {
-          long v = t_val >> 28;
-
-          if (v != 0 && v != -1)
-            as_bad_where (fixP->fx_file, fixP->fx_line,
-                          _("call/jmp target out of range (2)"));
-        }
-      else
-        /* This case was supposed to be handled in machine_ip.  */
-        abort ();
-
-      buf[0] |= (t_val >> 26) & 0x03; /* Holds bits 0FFFFFFC of address.  */
-      buf[1] = t_val >> 18;
-      buf[2] = t_val >> 10;
-      buf[3] = t_val >> 2;
-      break;
-
-    case BFD_RELOC_VTABLE_INHERIT:
-    case BFD_RELOC_VTABLE_ENTRY:
-      fixP->fx_done = 0;
-      break;
-
-    case BFD_RELOC_NONE:
-    default:
-      as_bad (_("bad relocation type: 0x%02x"), fixP->fx_r_type);
-      break;
-    }
-
-  if (fixP->fx_addsy == (symbolS *) NULL)
-    fixP->fx_done = 1;
-}
-
-/* Should never be called for or32.  */
-
-void
-md_create_short_jump (char *    ptr       ATTRIBUTE_UNUSED,
-		      addressT  from_addr ATTRIBUTE_UNUSED,
-		      addressT  to_addr   ATTRIBUTE_UNUSED,
-		      fragS *   frag      ATTRIBUTE_UNUSED,
-		      symbolS * to_symbol ATTRIBUTE_UNUSED)
-{
-  as_fatal ("or32_create_short_jmp\n");
-}
-
-/* Should never be called for or32.  */
-
-void
-md_convert_frag (bfd *   headers ATTRIBUTE_UNUSED,
-		 segT    seg     ATTRIBUTE_UNUSED,
-		 fragS * fragP   ATTRIBUTE_UNUSED)
-{
-  as_fatal ("or32_convert_frag\n");
-}
-
-/* Should never be called for or32.  */
-
-void
-md_create_long_jump (char *    ptr       ATTRIBUTE_UNUSED,
-		     addressT  from_addr ATTRIBUTE_UNUSED,
-		     addressT  to_addr   ATTRIBUTE_UNUSED,
-		     fragS *   frag      ATTRIBUTE_UNUSED,
-		     symbolS * to_symbol ATTRIBUTE_UNUSED)
-{
-  as_fatal ("or32_create_long_jump\n");
-}
-
-/* Should never be called for or32.  */
-
-int
-md_estimate_size_before_relax (fragS * fragP   ATTRIBUTE_UNUSED,
-			       segT    segtype ATTRIBUTE_UNUSED)
-{
-  as_fatal ("or32_estimate_size_before_relax\n");
-  return 0;
-}
-
-/* Translate internal representation of relocation info to target format.
-
-   On sparc/29k: first 4 bytes are normal unsigned long address, next three
-   bytes are index, most sig. byte first.  Byte 7 is broken up with
-   bit 7 as external, bits 6 & 5 unused, and the lower
-   five bits as relocation type.  Next 4 bytes are long addend.  */
-/* Thanx and a tip of the hat to Michael Bloom, mb@ttidca.tti.com.  */
-
-#ifdef OBJ_AOUT
-void
-tc_aout_fix_to_chars (char *where,
-		      fixS *fixP,
-		      relax_addressT segment_address_in_file)
-{
-  long r_symbolnum;
-
-#if DEBUG
-  printf ("tc_aout_fix_to_chars\n");
-#endif
-
-  know (fixP->fx_r_type < BFD_RELOC_NONE);
-  know (fixP->fx_addsy != NULL);
-
-  md_number_to_chars
-    (where,
-     fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
-     4);
-
-  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
-     ? S_GET_TYPE (fixP->fx_addsy)
-     : fixP->fx_addsy->sy_number);
-
-  where[4] = (r_symbolnum >> 16) & 0x0ff;
-  where[5] = (r_symbolnum >> 8) & 0x0ff;
-  where[6] = r_symbolnum & 0x0ff;
-  where[7] = (((!S_IS_DEFINED (fixP->fx_addsy)) << 7) & 0x80) | (0 & 0x60) | (fixP->fx_r_type & 0x1F);
-
-  /* Also easy.  */
-  md_number_to_chars (&where[8], fixP->fx_addnumber, 4);
-}
-
-#endif /* OBJ_AOUT */
-
-const char *md_shortopts = "";
-
-struct option md_longopts[] =
-{
-  { NULL, no_argument, NULL, 0 }
-};
-size_t md_longopts_size = sizeof (md_longopts);
-
-int
-md_parse_option (int c ATTRIBUTE_UNUSED, char * arg ATTRIBUTE_UNUSED)
-{
-  return 0;
-}
-
-void
-md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
-{
-}
-
-/* This is called when a line is unrecognized.  This is used to handle
-   definitions of or32 style local labels.  */
-
-int
-or32_unrecognized_line (int c)
-{
-  int lab;
-  char *s;
-
-  if (c != '$'
-      || ! ISDIGIT ((unsigned char) input_line_pointer[0]))
-    return 0;
-
-  s = input_line_pointer;
-
-  lab = 0;
-  while (ISDIGIT ((unsigned char) *s))
-    {
-      lab = lab * 10 + *s - '0';
-      ++s;
-    }
-
-  if (*s != ':')
-    /* Not a label definition.  */
-    return 0;
-
-  if (dollar_label_defined (lab))
-    {
-      as_bad (_("label \"$%d\" redefined"), lab);
-      return 0;
-    }
-
-  define_dollar_label (lab);
-  colon (dollar_label_name (lab, 0));
-  input_line_pointer = s + 1;
-
-  return 1;
-}
-
-/* Default the values of symbols known that should be "predefined".  We
-   don't bother to predefine them unless you actually use one, since there
-   are a lot of them.  */
-
-symbolS *
-md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
-{
-  return NULL;
-}
-
-/* Parse an operand that is machine-specific.  */
-
-void
-md_operand (expressionS *expressionP)
-{
-#if DEBUG
-  printf ("  md_operand(input_line_pointer = %s)\n", input_line_pointer);
-#endif
-
-  if (input_line_pointer[0] == REGISTER_PREFIX && input_line_pointer[1] == 'r')
-    {
-      /* We have a numeric register expression.  No biggy.  */
-      input_line_pointer += 2;  /* Skip %r */
-      (void) expression (expressionP);
-
-      if (expressionP->X_op != O_constant
-          || expressionP->X_add_number > 255)
-        as_bad (_("Invalid expression after %%%%\n"));
-      expressionP->X_op = O_register;
-    }
-  else if (input_line_pointer[0] == '&')
-    {
-      /* We are taking the 'address' of a register...this one is not
-         in the manual, but it *is* in traps/fpsymbol.h!  What they
-         seem to want is the register number, as an absolute number.  */
-      input_line_pointer++; /* Skip & */
-      (void) expression (expressionP);
-
-      if (expressionP->X_op != O_register)
-        as_bad (_("invalid register in & expression"));
-      else
-        expressionP->X_op = O_constant;
-    }
-  else if (input_line_pointer[0] == '$'
-           && ISDIGIT ((unsigned char) input_line_pointer[1]))
-    {
-      long lab;
-      char *name;
-      symbolS *sym;
-
-      /* This is a local label.  */
-      ++input_line_pointer;
-      lab = (long) get_absolute_expression ();
-
-      if (dollar_label_defined (lab))
-        {
-          name = dollar_label_name (lab, 0);
-          sym = symbol_find (name);
-        }
-      else
-        {
-          name = dollar_label_name (lab, 1);
-          sym = symbol_find_or_make (name);
-        }
-
-      expressionP->X_op = O_symbol;
-      expressionP->X_add_symbol = sym;
-      expressionP->X_add_number = 0;
-    }
-  else if (input_line_pointer[0] == '$')
-    {
-      char *s;
-      char type;
-      int fieldnum, fieldlimit;
-      LITTLENUM_TYPE floatbuf[8];
-
-      /* $float(), $doubleN(), or $extendN() convert floating values
-         to integers.  */
-      s = input_line_pointer;
-
-      ++s;
-
-      fieldnum = 0;
-      if (strncmp (s, "double", sizeof "double" - 1) == 0)
-        {
-          s += sizeof "double" - 1;
-          type = 'd';
-          fieldlimit = 2;
-        }
-      else if (strncmp (s, "float", sizeof "float" - 1) == 0)
-        {
-          s += sizeof "float" - 1;
-          type = 'f';
-          fieldlimit = 1;
-        }
-      else if (strncmp (s, "extend", sizeof "extend" - 1) == 0)
-        {
-          s += sizeof "extend" - 1;
-          type = 'x';
-          fieldlimit = 4;
-        }
-      else
-	return;
-
-      if (ISDIGIT (*s))
-        {
-          fieldnum = *s - '0';
-          ++s;
-        }
-      if (fieldnum >= fieldlimit)
-        return;
-
-      SKIP_WHITESPACE ();
-      if (*s != '(')
-        return;
-      ++s;
-      SKIP_WHITESPACE ();
-
-      s = atof_ieee (s, type, floatbuf);
-      if (s == NULL)
-        return;
-      s = s;
-
-      SKIP_WHITESPACE ();
-      if (*s != ')')
-        return;
-      ++s;
-      SKIP_WHITESPACE ();
-
-      input_line_pointer = s;
-      expressionP->X_op = O_constant;
-      expressionP->X_unsigned = 1;
-      expressionP->X_add_number = ((floatbuf[fieldnum * 2]
-                                    << LITTLENUM_NUMBER_OF_BITS)
-                                   + floatbuf[fieldnum * 2 + 1]);
-    }
-}
-
-/* Round up a section size to the appropriate boundary.  */
-
-valueT
-md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size ATTRIBUTE_UNUSED)
-{
-  return size;      /* Byte alignment is fine.  */
-}
-
-/* Exactly what point is a PC-relative offset relative TO?
-   On the 29000, they're relative to the address of the instruction,
-   which we have set up as the address of the fixup too.  */
-
-long
-md_pcrel_from (fixS *fixP)
-{
-  return fixP->fx_where + fixP->fx_frag->fr_address;
-}
-
-/* Generate a reloc for a fixup.  */
-
-arelent *
-tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
-{
-  arelent *reloc;
-
-  reloc = xmalloc (sizeof (arelent));
-  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
-  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
-  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
-  /*  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where + fixp->fx_addnumber;*/
-  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
-
-  if (reloc->howto == (reloc_howto_type *) NULL)
-    {
-      as_bad_where (fixp->fx_file, fixp->fx_line,
-		    _("reloc %d not supported by object file format"),
-		    (int) fixp->fx_r_type);
-      return NULL;
-    }
-
-  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
-    reloc->address = fixp->fx_offset;
-
-  reloc->addend = fixp->fx_addnumber;
-  return reloc;
-}
--- a/gas/config/tc-or32.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* tc-or32.h -- Assemble for the OpenRISC 1000.
-   Copyright (C) 2002, 2003. 2005, 2007 Free Software Foundation, Inc.
-   Contributed by Damjan Lampret <lampret@opencores.org>.
-   Based upon a29k port.
-
-   This file is part of GAS, the GNU Assembler.
-
-   GAS is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   GAS is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with GAS; see the file COPYING.  If not, write to
-   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
-   Boston, MA 02110-1301, USA.  */
-
-#define TC_OR32
-
-#define TARGET_BYTES_BIG_ENDIAN 1
-
-#define LEX_DOLLAR 1
-
-#ifdef OBJ_ELF
-#define TARGET_FORMAT  "elf32-or32"
-#define TARGET_ARCH    bfd_arch_or32
-#endif
-
-#ifdef OBJ_COFF
-#define TARGET_FORMAT  "coff-or32-big"
-#define reloc_type     int
-#endif
-
-#define tc_unrecognized_line(c) or32_unrecognized_line (c)
-
-extern int or32_unrecognized_line (int);
-
-#define tc_coff_symbol_emit_hook(a) ; /* Not used.  */
-
-#define COFF_MAGIC                  SIPFBOMAGIC
-
-/* No shared lib support, so we don't need to ensure externally
-   visible symbols can be overridden.  */
-#define EXTERN_FORCE_RELOC 0
-
-#ifdef OBJ_ELF
-/* Values passed to md_apply_fix don't include the symbol value.  */
-#define MD_APPLY_SYM_VALUE(FIX) 0
-#endif
-
-#define ZERO_BASED_SEGMENTS
--- a/gas/configure
+++ b/gas/configure
@@ -12150,7 +12150,7 @@
         fi
         ;;
 
-      epiphany | fr30 | ip2k | iq2000 | lm32 | m32r | openrisc)
+      epiphany | fr30 | ip2k | iq2000 | lm32 | m32r | or1k)
 	using_cgen=yes
 	;;
 
@@ -12332,6 +12332,8 @@
 cgen_cpu_prefix=""
 if test $using_cgen = yes ; then
   case ${target_cpu} in
+    or1knd)
+       cgen_cpu_prefix=or1k ;;
     *) cgen_cpu_prefix=${target_cpu} ;;
   esac
 
--- a/gas/configure.in
+++ b/gas/configure.in
@@ -324,7 +324,7 @@
         fi
         ;;
 
-      epiphany | fr30 | ip2k | iq2000 | lm32 | m32r | openrisc)
+      epiphany | fr30 | ip2k | iq2000 | lm32 | m32r | or1k)
 	using_cgen=yes
 	;;
 
@@ -502,6 +502,8 @@
 cgen_cpu_prefix=""
 if test $using_cgen = yes ; then
   case ${target_cpu} in
+    or1knd)
+       cgen_cpu_prefix=or1k ;;
     *) cgen_cpu_prefix=${target_cpu} ;;
   esac
   AC_SUBST(cgen_cpu_prefix)
--- a/gas/configure.tgt
+++ b/gas/configure.tgt
@@ -79,7 +79,7 @@
   mips*el)		cpu_type=mips endian=little ;;
   mips*)		cpu_type=mips endian=big ;;
   mt)			cpu_type=mt endian=big ;;
-  or32*)		cpu_type=or32 endian=big ;;
+  or1k* | or1knd*)	cpu_type=or1k endian=big ;;
   pjl*)			cpu_type=pj endian=little ;;
   pj*)			cpu_type=pj endian=big ;;
   powerpc*le*)		cpu_type=ppc endian=little ;;
@@ -352,10 +352,8 @@
   ns32k-pc532-lites*)			fmt=aout em=nbsd532 ;;
   ns32k-*-*n*bsd*)			fmt=aout em=nbsd532 ;;
 
-  openrisc-*-*)				fmt=elf ;;
-
-  or32-*-rtems*)			fmt=elf ;;
-  or32-*-elf)				fmt=elf ;;
+  or1k-*-elf | or1knd-*-elf)		fmt=elf endian=big ;;
+  or1k-*-linux* | or1knd-*-linux*)	fmt=elf em=linux endian=big ;;
 
   pj*)					fmt=elf ;;
 
@@ -469,7 +467,7 @@
 esac
 
 case ${cpu_type} in
-  aarch64 | alpha | arm | i386 | ia64 | microblaze | mips | ns32k | pdp11 | ppc | sparc | z80 | z8k)
+  aarch64 | alpha | arm | i386 | ia64 | microblaze | mips | ns32k | or1k | or1knd | pdp11 | ppc | sparc | z80 | z8k)
     bfd_gas=yes
     ;;
 esac
--- a/gas/doc/as.texinfo
+++ b/gas/doc/as.texinfo
@@ -4303,7 +4303,7 @@
 with no-op instructions when appropriate.
 
 The way the required alignment is specified varies from system to system.
-For the arc, hppa, i386 using ELF, i860, iq2000, m68k, or32,
+For the arc, hppa, i386 using ELF, i860, iq2000, m68k, or1k,
 s390, sparc, tic4x, tic80 and xtensa, the first expression is the
 alignment request in bytes.  For example @samp{.align 8} advances
 the location counter until it is a multiple of 8.  If the location counter
--- a/gas/testsuite/gas/all/gas.exp
+++ b/gas/testsuite/gas/all/gas.exp
@@ -162,7 +162,7 @@
 	# These targets fail redef3 because section contents for the
 	# word referencing the .comm sym is not zero and/or its reloc
 	# has a non-zero addend.  Relaxing the test would hide real
-	# failures such as or32-elf.
+	# failures.
 	setup_xfail "bfin-*-*" "i\[3-7\]86-*-*coff" \
 	    "i\[3-7\]86-*-*pe" "i\[3-7\]86-*-go32*" \
 	    "i\[3-7\]86-*-cygwin*" "i\[3-7\]86-*-mingw*" "x86_64-*-mingw*"
--- a/gas/testsuite/gas/elf/warn-2.s
+++ b/gas/testsuite/gas/elf/warn-2.s
@@ -1,7 +1,7 @@
 ;# { dg-do assemble }
 ;# { dg-options "--gdwarf2 --defsym nop_type=0" }
 ;# { dg-options "--gdwarf2 --defsym nop_type=1" { target ia64-*-* } }
-;# { dg-options "--gdwarf2 --defsym nop_type=2" { target or32-*-* openrisc-*-* } }
+;# { dg-options "--gdwarf2 --defsym nop_type=2" { target or1k*-*-* } }
 ;# { dg-options "--gdwarf2 --defsym nop_type=3" { target i370-*-* } }
 
 	.offset 40
--- /dev/null
+++ b/gas/testsuite/gas/lns/lns-common-1-or1k.s
@@ -0,0 +1,25 @@
+	.file 1 "foo.c"
+	.loc 1 1
+	l.nop
+	l.nop
+	.loc 1 2 3
+	l.nop
+	l.nop
+	.loc 1 3 prologue_end
+	l.nop
+	l.nop
+	.loc 1 4 0 epilogue_begin
+	l.nop
+	l.nop
+	.loc 1 5 isa 1 basic_block
+	l.nop
+	l.nop
+	.loc 1 6 is_stmt 0
+	l.nop
+	l.nop
+	.loc 1 7 is_stmt 1
+	l.nop
+	l.nop
+	.loc 1 7 discriminator 1
+	l.nop
+	l.nop
--- a/gas/testsuite/gas/lns/lns.exp
+++ b/gas/testsuite/gas/lns/lns.exp
@@ -44,6 +44,8 @@
       run_dump_test "lns-big-delta"
     } elseif { [istarget ia64*-*-*] } {
       run_dump_test "lns-common-1" { { source "lns-common-1-ia64.s" } }
+    } elseif { [istarget or1k*-*-*] } {
+      run_dump_test "lns-common-1" { { source "lns-common-1-or1k.s" } }
     } else {
       run_dump_test "lns-common-1"
     }
--- a/gas/testsuite/gas/openrisc/addi.d
+++ /dev/null
@@ -1,10 +0,0 @@
-#as:
-#objdump: -dr
-#name: addi
-
-.*: +file format .*
-
-Disassembly of section .text:
-
-00000000 <l_addi>:
-   0:	94 22 ff ff 	l.addi r1,r2,-1
--- a/gas/testsuite/gas/openrisc/addi.s
+++ /dev/null
@@ -1,4 +0,0 @@
-	.text
-	.global l_addi
-l_addi:
-	l.addi r1, r2, -1
--- a/gas/testsuite/gas/openrisc/allinsn.d
+++ /dev/null
@@ -1,201 +0,0 @@
-#as:
-#objdump: -dr
-#name: allinsn
-
-.*: +file format .*
-
-Disassembly of section .text:
-
-00000000 <l_j>:
-   0:	00 00 00 00 	l.j 0 <l_j>
-			0: R_OPENRISC_INSN_ABS_26	.text
-
-00000004 <l_jal>:
-   4:	04 00 00 00 	l.jal 0 <l_j>
-			4: R_OPENRISC_INSN_ABS_26	.text
-
-00000008 <l_jr>:
-   8:	14 00 00 00 	l.jr r0
-
-0000000c <l_jalr>:
-   c:	14 20 00 00 	l.jalr r0
-
-00000010 <l_bal>:
-  10:	0b ff ff fc 	l.bal 0 <l_j>
-
-00000014 <l_bnf>:
-  14:	0f ff ff fb 	l.bnf 0 <l_j>
-
-00000018 <l_bf>:
-  18:	13 ff ff fa 	l.bf 0 <l_j>
-
-0000001c <l_brk>:
-  1c:	17 00 00 00 	l.brk 0x0
-
-00000020 <l_rfe>:
-  20:	14 40 00 00 	l.rfe r0
-
-00000024 <l_sys>:
-  24:	16 00 00 00 	l.sys 0x0
-
-00000028 <l_nop>:
-  28:	15 00 00 00 	l.nop
-
-0000002c <l_movhi>:
-  2c:	18 00 00 00 	l.movhi r0,0
-
-00000030 <l_mfsr>:
-  30:	1c 00 00 00 	l.mfsr r0,r0
-
-00000034 <l_mtsr>:
-  34:	40 00 00 00 	l.mtsr r0,r0
-
-00000038 <l_lw>:
-  38:	80 00 00 00 	l.lw r0,0\(r0\)
-
-0000003c <l_lbz>:
-  3c:	84 00 00 00 	l.lbz r0,0\(r0\)
-
-00000040 <l_lbs>:
-  40:	88 00 00 00 	l.lbs r0,0\(r0\)
-
-00000044 <l_lhz>:
-  44:	8c 00 00 00 	l.lhz r0,0\(r0\)
-
-00000048 <l_lhs>:
-  48:	90 00 00 00 	l.lhs r0,0\(r0\)
-
-0000004c <l_sw>:
-  4c:	d4 00 00 00 	l.sw 0\(r0\),r0
-
-00000050 <l_sb>:
-  50:	d8 00 00 00 	l.sb 0\(r0\),r0
-
-00000054 <l_sh>:
-  54:	dc 00 00 00 	l.sh 0\(r0\),r0
-
-00000058 <l_sll>:
-  58:	e0 00 00 08 	l.sll r0,r0,r0
-
-0000005c <l_slli>:
-  5c:	b4 00 00 00 	l.slli r0,r0,0x0
-
-00000060 <l_srl>:
-  60:	e0 00 00 28 	l.srl r0,r0,r0
-
-00000064 <l_srli>:
-  64:	b4 00 00 20 	l.srli r0,r0,0x0
-
-00000068 <l_sra>:
-  68:	e0 00 00 48 	l.sra r0,r0,r0
-
-0000006c <l_srai>:
-  6c:	b4 00 00 40 	l.srai r0,r0,0x0
-
-00000070 <l_ror>:
-  70:	e0 00 00 88 	l.ror r0,r0,r0
-
-00000074 <l_rori>:
-  74:	b4 00 00 80 	l.rori r0,r0,0x0
-
-00000078 <l_add>:
-  78:	e0 00 00 00 	l.add r0,r0,r0
-
-0000007c <l_addi>:
-  7c:	94 00 00 00 	l.addi r0,r0,0
-
-00000080 <l_sub>:
-  80:	e0 00 00 02 	l.sub r0,r0,r0
-
-00000084 <l_subi>:
-  84:	9c 00 00 00 	l.subi r0,r0,0
-
-00000088 <l_and>:
-  88:	e0 00 00 03 	l.and r0,r0,r0
-
-0000008c <l_andi>:
-  8c:	a0 00 00 00 	l.andi r0,r0,0
-
-00000090 <l_or>:
-  90:	e0 00 00 04 	l.or r0,r0,r0
-
-00000094 <l_ori>:
-  94:	a4 00 00 00 	l.ori r0,r0,0
-
-00000098 <l_xor>:
-  98:	e0 00 00 05 	l.xor r0,r0,r0
-
-0000009c <l_xori>:
-  9c:	a8 00 00 00 	l.xori r0,r0,0
-
-000000a0 <l_mul>:
-  a0:	e0 00 00 06 	l.mul r0,r0,r0
-
-000000a4 <l_muli>:
-  a4:	ac 00 00 00 	l.muli r0,r0,0
-
-000000a8 <l_div>:
-  a8:	e0 00 00 09 	l.div r0,r0,r0
-
-000000ac <l_divu>:
-  ac:	e0 00 00 0a 	l.divu r0,r0,r0
-
-000000b0 <l_sfgts>:
-  b0:	e4 c0 00 00 	l.sfgts r0,r0
-
-000000b4 <l_sfgtu>:
-  b4:	e4 40 00 00 	l.sfgtu r0,r0
-
-000000b8 <l_sfges>:
-  b8:	e4 e0 00 00 	l.sfges r0,r0
-
-000000bc <l_sfgeu>:
-  bc:	e4 60 00 00 	l.sfgeu r0,r0
-
-000000c0 <l_sflts>:
-  c0:	e5 00 00 00 	l.sflts r0,r0
-
-000000c4 <l_sfltu>:
-  c4:	e4 80 00 00 	l.sfltu r0,r0
-
-000000c8 <l_sfles>:
-  c8:	e5 20 00 00 	l.sfles r0,r0
-
-000000cc <l_sfleu>:
-  cc:	e4 a0 00 00 	l.sfleu r0,r0
-
-000000d0 <l_sfgtsi>:
-  d0:	b8 c0 00 00 	l.sfgtsi r0,0
-
-000000d4 <l_sfgtui>:
-  d4:	b8 40 00 00 	l.sfgtui r0,0x0
-
-000000d8 <l_sfgesi>:
-  d8:	b8 e0 00 00 	l.sfgesi r0,0
-
-000000dc <l_sfgeui>:
-  dc:	b8 60 00 00 	l.sfgeui r0,0x0
-
-000000e0 <l_sfltsi>:
-  e0:	b9 00 00 00 	l.sfltsi r0,0
-
-000000e4 <l_sfltui>:
-  e4:	b8 80 00 00 	l.sfltui r0,0x0
-
-000000e8 <l_sflesi>:
-  e8:	b9 20 00 00 	l.sflesi r0,0
-
-000000ec <l_sfleui>:
-  ec:	b8 a0 00 00 	l.sfleui r0,0x0
-
-000000f0 <l_sfeq>:
-  f0:	e4 00 00 00 	l.sfeq r0,r0
-
-000000f4 <l_sfeqi>:
-  f4:	b8 00 00 00 	l.sfeqi r0,0
-
-000000f8 <l_sfne>:
-  f8:	e4 20 00 00 	l.sfne r0,r0
-
-000000fc <l_sfnei>:
-  fc:	b8 20 00 00 	l.sfnei r0,0
--- a/gas/testsuite/gas/openrisc/allinsn.exp
+++ /dev/null
@@ -1,25 +0,0 @@
-# Copyright 2012
-# Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
-# (at your option) any later version.
-# 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with this program; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  
-
-# OpenRISC assembler testsuite.
-
-if [istarget openrisc*-*-*] {
-    run_dump_test "allinsn"
-    run_dump_test "addi"
-    run_dump_test "lohi"
-    run_dump_test "store"
-}
--- a/gas/testsuite/gas/openrisc/allinsn.s
+++ /dev/null
@@ -1,260 +0,0 @@
- .data
-foodata: .word 42
- .text
-footext:
-	.text
-	.global l_j
-l_j:
-	l.j footext
-	.text
-	.global l_jal
-l_jal:
-	l.jal footext
-	.text
-	.global l_jr
-l_jr:
-	l.jr r0
-	.text
-	.global l_jalr
-l_jalr:
-	l.jalr r0
-	.text
-	.global l_bal
-l_bal:
-	l.bal footext
-	.text
-	.global l_bnf
-l_bnf:
-	l.bnf footext
-	.text
-	.global l_bf
-l_bf:
-	l.bf footext
-	.text
-	.global l_brk
-l_brk:
-	l.brk 0
-	.text
-	.global l_rfe
-l_rfe:
-	l.rfe r0
-	.text
-	.global l_sys
-l_sys:
-	l.sys 0
-	.text
-	.global l_nop
-l_nop:
-	l.nop
-	.text
-	.global l_movhi
-l_movhi:
-	l.movhi r0,0
-	.text
-	.global l_mfsr
-l_mfsr:
-	l.mfsr r0,r0
-	.text
-	.global l_mtsr
-l_mtsr:
-	l.mtsr r0,r0
-	.text
-	.global l_lw
-l_lw:
-	l.lw r0,0(r0)
-	.text
-	.global l_lbz
-l_lbz:
-	l.lbz r0,0(r0)
-	.text
-	.global l_lbs
-l_lbs:
-	l.lbs r0,0(r0)
-	.text
-	.global l_lhz
-l_lhz:
-	l.lhz r0,0(r0)
-	.text
-	.global l_lhs
-l_lhs:
-	l.lhs r0,0(r0)
-	.text
-	.global l_sw
-l_sw:
-	l.sw 0(r0),r0
-	.text
-	.global l_sb
-l_sb:
-	l.sb 0(r0),r0
-	.text
-	.global l_sh
-l_sh:
-	l.sh 0(r0),r0
-	.text
-	.global l_sll
-l_sll:
-	l.sll r0,r0,r0
-	.text
-	.global l_slli
-l_slli:
-	l.slli r0,r0,0
-	.text
-	.global l_srl
-l_srl:
-	l.srl r0,r0,r0
-	.text
-	.global l_srli
-l_srli:
-	l.srli r0,r0,0
-	.text
-	.global l_sra
-l_sra:
-	l.sra r0,r0,r0
-	.text
-	.global l_srai
-l_srai:
-	l.srai r0,r0,0
-	.text
-	.global l_ror
-l_ror:
-	l.ror r0,r0,r0
-	.text
-	.global l_rori
-l_rori:
-	l.rori r0,r0,0
-	.text
-	.global l_add
-l_add:
-	l.add r0,r0,r0
-	.text
-	.global l_addi
-l_addi:
-	l.addi r0,r0,0
-	.text
-	.global l_sub
-l_sub:
-	l.sub r0,r0,r0
-	.text
-	.global l_subi
-l_subi:
-	l.subi r0,r0,0
-	.text
-	.global l_and
-l_and:
-	l.and r0,r0,r0
-	.text
-	.global l_andi
-l_andi:
-	l.andi r0,r0,0
-	.text
-	.global l_or
-l_or:
-	l.or r0,r0,r0
-	.text
-	.global l_ori
-l_ori:
-	l.ori r0,r0,0
-	.text
-	.global l_xor
-l_xor:
-	l.xor r0,r0,r0
-	.text
-	.global l_xori
-l_xori:
-	l.xori r0,r0,0
-	.text
-	.global l_mul
-l_mul:
-	l.mul r0,r0,r0
-	.text
-	.global l_muli
-l_muli:
-	l.muli r0,r0,0
-	.text
-	.global l_div
-l_div:
-	l.div r0,r0,r0
-	.text
-	.global l_divu
-l_divu:
-	l.divu r0,r0,r0
-	.text
-	.global l_sfgts
-l_sfgts:
-	l.sfgts r0,r0
-	.text
-	.global l_sfgtu
-l_sfgtu:
-	l.sfgtu r0,r0
-	.text
-	.global l_sfges
-l_sfges:
-	l.sfges r0,r0
-	.text
-	.global l_sfgeu
-l_sfgeu:
-	l.sfgeu r0,r0
-	.text
-	.global l_sflts
-l_sflts:
-	l.sflts r0,r0
-	.text
-	.global l_sfltu
-l_sfltu:
-	l.sfltu r0,r0
-	.text
-	.global l_sfles
-l_sfles:
-	l.sfles r0,r0
-	.text
-	.global l_sfleu
-l_sfleu:
-	l.sfleu r0,r0
-	.text
-	.global l_sfgtsi
-l_sfgtsi:
-	l.sfgtsi r0,0
-	.text
-	.global l_sfgtui
-l_sfgtui:
-	l.sfgtui r0,0
-	.text
-	.global l_sfgesi
-l_sfgesi:
-	l.sfgesi r0,0
-	.text
-	.global l_sfgeui
-l_sfgeui:
-	l.sfgeui r0,0
-	.text
-	.global l_sfltsi
-l_sfltsi:
-	l.sfltsi r0,0
-	.text
-	.global l_sfltui
-l_sfltui:
-	l.sfltui r0,0
-	.text
-	.global l_sflesi
-l_sflesi:
-	l.sflesi r0,0
-	.text
-	.global l_sfleui
-l_sfleui:
-	l.sfleui r0,0
-	.text
-	.global l_sfeq
-l_sfeq:
-	l.sfeq r0,r0
-	.text
-	.global l_sfeqi
-l_sfeqi:
-	l.sfeqi r0,0
-	.text
-	.global l_sfne
-l_sfne:
-	l.sfne r0,r0
-	.text
-	.global l_sfnei
-l_sfnei:
-	l.sfnei r0,0
--- a/gas/testsuite/gas/openrisc/lohi.d
+++ /dev/null
@@ -1,13 +0,0 @@
-#as:
-#objdump: -dr
-#name: lohi
-
-.*: +file format .*
-
-Disassembly of section .text:
-
-00000000 <l_lo>:
-   0:	94 21 be ef 	l.addi r1,r1,-16657
-
-00000004 <l_hi>:
-   4:	18 20 de ad 	l.movhi r1,-8531
--- a/gas/testsuite/gas/openrisc/lohi.s
+++ /dev/null
@@ -1,7 +0,0 @@
-	.text
-	.global l_lo
-l_lo:
-	l.addi	r1, r1, lo(0xdeadbeef)
-	.global	l_hi
-l_hi:	
-	l.movhi	r1, hi(0xdeadbeef)
--- a/gas/testsuite/gas/openrisc/store.d
+++ /dev/null
@@ -1,13 +0,0 @@
-#as:
-#objdump: -dr
-#name: store
-
-.*: +file format .*
-
-Disassembly of section .text:
-
-00000000 <l_sw>:
-   0:	d7 e1 0f fc 	l.sw -4\(r1\),r1
-
-00000004 <l_lw>:
-   4:	80 21 ff 9c 	l.lw r1,-100\(r1\)
--- a/gas/testsuite/gas/openrisc/store.s
+++ /dev/null
@@ -1,7 +0,0 @@
-	.text
-	.global l_sw
-l_sw:
-	l.sw	-4(r1), r1
-	.global	l_lw
-l_lw:	
-	l.lw	r1, -100(r1)
--- a/include/coff/or32.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/* COFF specification for OpenRISC 1000.
-   Copyright (C) 1993-2000, 2002, 2010 Free Software Foundation, Inc.
-   Contributed by David Wood @ New York University.
-   Modified by Johan Rydberg, <johan.rydberg@netinsight.se>
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#ifndef OR32
-# define OR32
-#endif
-
-/* File Header and related definitions.  */
-struct external_filehdr
-{
-  char f_magic[2];	/* magic number		    */
-  char f_nscns[2];	/* number of sections	    */
-  char f_timdat[4];     /* time & date stamp	    */
-  char f_symptr[4];     /* file pointer to symtab   */
-  char f_nsyms[4];	/* number of symtab entries */
-  char f_opthdr[2];     /* sizeof(optional hdr)	    */
-  char f_flags[2];	/* flags		    */
-};
-
-#define FILHDR  struct external_filehdr
-#define FILHSZ	20
-
-/* Magic numbers for OpenRISC 1000. As it is know we use the
-   numbers for Am29000.
-
-   (AT&T will assign the "real" magic number).  */
-#define SIPFBOMAGIC     0572    /* Am29000 (Byte 0 is MSB).  */
-#define SIPRBOMAGIC     0573    /* Am29000 (Byte 0 is LSB).  */
-
-#define OR32_MAGIC_BIG 		SIPFBOMAGIC	
-#define OR32_MAGIC_LITTLE	SIPRBOMAGIC	
-#define OR32BADMAG(x)     (((x).f_magic!=OR32_MAGIC_BIG) && \
-			                      ((x).f_magic!=OR32_MAGIC_LITTLE))
-
-#define OMAGIC OR32_MAGIC_BIG
-
-/* Optional (a.out) header.  */
-typedef	struct external_aouthdr 
-{
-  char  magic[2];         /* type of file                     */
-  char  vstamp[2];	  /* version stamp                    */
-  char  tsize[4];	  /* text size in bytes, padded to FW bdry */
-  char  dsize[4];	  /* initialized data "  "            */
-  char  bsize[4];	  /* uninitialized data "   "         */
-  char  entry[4];	  /* entry pt.                        */
-  char  text_start[4];	  /* base of text used for this file  */
-  char  data_start[4];	  /* base of data used for this file  */
-} AOUTHDR;
-
-#define AOUTSZ      28
-#define AOUTHDRSZ   28
-
-/* aouthdr magic numbers.  */
-#define NMAGIC    0410	  /* separate i/d executable.  */
-#define SHMAGIC   0406	  /* NYU/Ultra3 shared data executable 
-                             (writable text).  */
-
-#define _ETEXT   	"_etext"
-
-/* Section header and related definitions.  */
-struct external_scnhdr 
-{
-  char	    s_name[8];      /* section name                   */
-  char	    s_paddr[4];     /* physical address, aliased s_nlib */
-  char	    s_vaddr[4];     /* virtual address                */
-  char	    s_size[4];      /* section size                   */
-  char	    s_scnptr[4];    /* file ptr to raw data for section */
-  char	    s_relptr[4];    /* file ptr to relocation         */
-  char	    s_lnnoptr[4];   /* file ptr to line numbers       */
-  char	    s_nreloc[2];    /* number of relocation entries   */
-  char	    s_nlnno[2];     /* number of line number entries  */
-  char	    s_flags[4];     /* flags                          */
-};
-
-#define	SCNHDR	struct external_scnhdr
-#define	SCNHSZ	40
-
-/* Names of "special" sections:  */
-#define _TEXT   ".text"
-#define _DATA   ".data"
-#define _BSS    ".bss"
-#define _LIT    ".lit"
-
-/* Section types - with additional section type for global 
-   registers which will be relocatable for the OpenRISC 1000.
-
-   In instances where it is necessary for a linker to produce an
-   output file which contains text or data not based at virtual
-   address 0, e.g. for a ROM, then the linker should accept
-   address base information as command input and use PAD sections
-   to skip over unused addresses.  */
-#define	STYP_BSSREG 0x1200	/* Global register area (like STYP_INFO) */
-#define STYP_ENVIR  0x2200	/* Environment (like STYP_INFO) */
-#define STYP_ABS    0x4000	/* Absolute (allocated, not reloc, loaded) */
-
-/* Relocation information declaration and related definitions:  */
-struct external_reloc
-{
-  char r_vaddr[4];    /* (virtual) address of reference */
-  char r_symndx[4];   /* index into symbol table */
-  char r_type[2];     /* relocation type */
-};
-
-#define	RELOC		struct external_reloc
-#define	RELSZ		10		/* sizeof (RELOC) */ 
-
-/* Relocation types for the OpenRISC 1000: */
-
-#define	R_ABS     0     /* reference is absolute */
-#define	R_IREL    030	/* instruction relative (jmp/call) */
-#define	R_IABS    031	/* instruction absolute (jmp/call) */
-#define	R_ILOHALF 032	/* instruction low half  (const)  */
-#define	R_IHIHALF 033	/* instruction high half (consth) part 1 */
-#define	R_IHCONST 034	/* instruction high half (consth) part 2 */
-                        /* constant offset of R_IHIHALF relocation */
-#define	R_BYTE    035	/* relocatable byte value */
-#define R_HWORD   036	/* relocatable halfword value */
-#define R_WORD    037	/* relocatable word value */
-
-#define	R_IGLBLRC 040	/* instruction global register RC */
-#define	R_IGLBLRA 041	/* instruction global register RA */
-#define	R_IGLBLRB 042	/* instruction global register RB */
- 
-/*
-  NOTE:
-  All the "I" forms refer to 29000 instruction formats.  The linker is 
-  expected to know how the numeric information is split and/or aligned
-  within the instruction word(s).  R_BYTE works for instructions, too.
-
-  If the parameter to a CONSTH instruction is a relocatable type, two 
-  relocation records are written.  The first has an r_type of R_IHIHALF 
-  (33 octal) and a normal r_vaddr and r_symndx.  The second relocation 
-  record has an r_type of R_IHCONST (34 octal), a normal r_vaddr (which 
-  is redundant), and an r_symndx containing the 32-bit constant offset 
-  to the relocation instead of the actual symbol table index.  This 
-  second record is always written, even if the constant offset is zero.
-  The constant fields of the instruction are set to zero.  */
-
-/* Line number entry declaration and related definitions:  */
-struct external_lineno 
-{
-  union
-  {
-    char l_symndx[4];  /* function name symbol index, iff l_lnno == 0*/
-    char l_paddr[4];   /* (physical) address of line number    */
-  }
-  l_addr;
-
-  char l_lnno[2];      /* line number	  */
-};
-
-#define	LINENO		struct external_lineno
-#define	LINESZ		6		  /* sizeof (LINENO) */
-
-/* Symbol entry declaration and related definitions:  */
-#define	E_SYMNMLEN	8	  /* Number of characters in a symbol name */
-
-struct external_syment
-{
-  union
-  {
-    char e_name[E_SYMNMLEN];
-    struct
-    {
-      char e_zeroes[4];
-      char e_offset[4];
-    }
-    e;
-  }
-  e;
-
-  char e_value[4];
-  char e_scnum[2];
-  char e_type[2];
-  char e_sclass[1];
-  char e_numaux[1];
-};
-
-#define	SYMENT	struct external_syment
-#define	SYMESZ 	18
-
-/* Storage class definitions - new classes for global registers:  */
-#define C_GLBLREG	19		/* global register */
-#define C_EXTREG	20		/* external global register */
-#define	C_DEFREG	21		/* ext. def. of global register */
-
-/* Derived symbol mask/shifts:  */
-#define N_BTMASK	(0xf)
-#define N_BTSHFT	(4)
-#define N_TMASK		(0x30)
-#define N_TSHIFT	(2)
-
-/* Auxiliary symbol table entry declaration and related 
-   definitions.  */
-#define E_FILNMLEN  14  /* # characters in a file name	  */
-#define E_DIMNUM    4   /* # array dimensions in auxiliary entry */
-
-union external_auxent
-{
-  struct
-  {
-    char x_tagndx[4];       /* str, un, or enum tag indx */
-    union
-    {
-      struct
-      {
-	char  x_lnno[2];    /* declaration line number */
-        char  x_size[2];    /* str/union/array size */
-      }
-      x_lnsz;
-
-      char x_fsize[4];      /* size of function */
-    }
-    x_misc;
-
-    union
-    {
-      struct 		          /* if ISFCN, tag, or .bb */
-      {
-	char x_lnnoptr[4];  /* ptr to fcn line # */
-        char x_endndx[4];   /* entry ndx past block end */
-      }
-      x_fcn;
-
-      struct   	          /* if ISARY, up to 4 dimen. */
-      {
-	char x_dimen[E_DIMNUM][2];
-      }
-      x_ary;
-    }
-    x_fcnary;
-
-    char x_tvndx[2];        /* tv index */
-  }
-  x_sym;
-
-  union
-  {
-    char x_fname[E_FILNMLEN];
-
-    struct
-    {
-      char x_zeroes[4];
-      char x_offset[4];
-    }
-    x_n;
-  }
-  x_file;
-
-  struct
-  {
-    char x_scnlen[4];       /* section length */
-    char x_nreloc[2];       /* # relocation entries */
-    char x_nlinno[2];       /* # line numbers */
-  }
-  x_scn;
-
-  struct
-  {
-    char x_tvfill[4];       /* tv fill value */
-    char x_tvlen[2];        /* length of .tv */
-    char x_tvran[2][2];     /* tv range */
-  }
-  x_tv;                   /* info about .tv section 
-			     (in auxent of symbol .tv)) */
-};
-
-#define	AUXENT		union external_auxent
-#define	AUXESZ		18	
--- a/include/dis-asm.h
+++ b/include/dis-asm.h
@@ -227,7 +227,6 @@
 extern int print_insn_big_arm		(bfd_vma, disassemble_info *);
 extern int print_insn_big_mips		(bfd_vma, disassemble_info *);
 extern int print_insn_big_nios2		(bfd_vma, disassemble_info *);
-extern int print_insn_big_or32		(bfd_vma, disassemble_info *);
 extern int print_insn_big_powerpc	(bfd_vma, disassemble_info *);
 extern int print_insn_big_score         (bfd_vma, disassemble_info *);
 extern int print_insn_cr16              (bfd_vma, disassemble_info *);
@@ -255,7 +254,6 @@
 extern int print_insn_little_arm	(bfd_vma, disassemble_info *);
 extern int print_insn_little_mips	(bfd_vma, disassemble_info *);
 extern int print_insn_little_nios2	(bfd_vma, disassemble_info *);
-extern int print_insn_little_or32	(bfd_vma, disassemble_info *);
 extern int print_insn_little_powerpc	(bfd_vma, disassemble_info *);
 extern int print_insn_little_score      (bfd_vma, disassemble_info *); 
 extern int print_insn_lm32		(bfd_vma, disassemble_info *);
@@ -278,7 +276,7 @@
 extern int print_insn_msp430		(bfd_vma, disassemble_info *);
 extern int print_insn_mt                (bfd_vma, disassemble_info *);
 extern int print_insn_ns32k		(bfd_vma, disassemble_info *);
-extern int print_insn_openrisc		(bfd_vma, disassemble_info *);
+extern int print_insn_or1k		(bfd_vma, disassemble_info *);
 extern int print_insn_pdp11		(bfd_vma, disassemble_info *);
 extern int print_insn_pj		(bfd_vma, disassemble_info *);
 extern int print_insn_rs6000		(bfd_vma, disassemble_info *);
--- a/include/elf/common.h
+++ b/include/elf/common.h
@@ -192,7 +192,7 @@
 #define EM_MN10300	 89	/* Matsushita MN10300 */
 #define EM_MN10200	 90	/* Matsushita MN10200 */
 #define EM_PJ		 91	/* picoJava */
-#define EM_OPENRISC	 92	/* OpenRISC 32-bit embedded processor */
+#define EM_OR1K		 92	/* OpenRISC 1000 32-bit embedded processor */
 #define EM_ARC_A5	 93	/* ARC Cores Tangent-A5 */
 #define EM_XTENSA	 94	/* Tensilica Xtensa Architecture */
 #define EM_VIDEOCORE	 95	/* Alphamosaic VideoCore processor */
@@ -339,9 +339,6 @@
 /* FR30 magic number - no EABI available.  */
 #define EM_CYGNUS_FR30		0x3330
 
-/* OpenRISC magic number.  Written in the absense of an ABI.  */
-#define EM_OPENRISC_OLD		0x3426
-
 /* DLX magic number.  Written in the absense of an ABI.  */
 #define EM_DLX			0x5aa5
 
@@ -360,9 +357,6 @@
 /* Ubicom IP2xxx;   Written in the absense of an ABI.  */
 #define EM_IP2K_OLD		0x8217
 
-/* (Deprecated) Temporary number for the OpenRISC processor.  */
-#define EM_OR32			0x8472
-
 /* Cygnus PowerPC ELF backend.  Written in the absence of an ABI.  */
 #define EM_CYGNUS_POWERPC	0x9025
 
--- a/include/elf/openrisc.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* OpenRISC ELF support for BFD.
-   Copyright 2001, 2010 Free Software Foundation, Inc.
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software Foundation,
-   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
-
-#ifndef _ELF_OPENRISC_H
-#define _ELF_OPENRISC_H
-
-#include "elf/reloc-macros.h"
-
-/* Relocations.  */
-START_RELOC_NUMBERS (elf_openrisc_reloc_type)
-  RELOC_NUMBER (R_OPENRISC_NONE, 0)
-  RELOC_NUMBER (R_OPENRISC_INSN_REL_26, 1)
-  RELOC_NUMBER (R_OPENRISC_INSN_ABS_26, 2)
-  RELOC_NUMBER (R_OPENRISC_LO_16_IN_INSN, 3)
-  RELOC_NUMBER (R_OPENRISC_HI_16_IN_INSN, 4)
-  RELOC_NUMBER (R_OPENRISC_8, 5)
-  RELOC_NUMBER (R_OPENRISC_16, 6)
-  RELOC_NUMBER (R_OPENRISC_32, 7)
-  RELOC_NUMBER (R_OPENRISC_GNU_VTINHERIT, 8)
-  RELOC_NUMBER (R_OPENRISC_GNU_VTENTRY, 9)
-END_RELOC_NUMBERS (R_OPENRISC_max)
-
-#endif /* _ELF_OPENRISC_H */
--- /dev/null
+++ b/include/elf/or1k.h
@@ -0,0 +1,66 @@
+/* Or1k ELF support for BFD.
+   Copyright 2001, 2010 Free Software Foundation, Inc.
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _ELF_OR1K_H
+#define _ELF_OR1K_H
+
+#include "elf/reloc-macros.h"
+
+/* Relocations.  */
+START_RELOC_NUMBERS (elf_or1k_reloc_type)
+  RELOC_NUMBER (R_OR1K_NONE,           0)
+  RELOC_NUMBER (R_OR1K_32,             1)
+  RELOC_NUMBER (R_OR1K_16,             2)
+  RELOC_NUMBER (R_OR1K_8,              3)
+  RELOC_NUMBER (R_OR1K_LO_16_IN_INSN,  4)
+  RELOC_NUMBER (R_OR1K_HI_16_IN_INSN,  5)
+  RELOC_NUMBER (R_OR1K_INSN_REL_26,    6)
+  RELOC_NUMBER (R_OR1K_GNU_VTENTRY,    7)
+  RELOC_NUMBER (R_OR1K_GNU_VTINHERIT,  8)
+  RELOC_NUMBER (R_OR1K_32_PCREL,       9)
+  RELOC_NUMBER (R_OR1K_16_PCREL,      10)
+  RELOC_NUMBER (R_OR1K_8_PCREL,       11)
+  RELOC_NUMBER (R_OR1K_GOTPC_HI16,    12)
+  RELOC_NUMBER (R_OR1K_GOTPC_LO16,    13)
+  RELOC_NUMBER (R_OR1K_GOT16,         14)
+  RELOC_NUMBER (R_OR1K_PLT26,         15)
+  RELOC_NUMBER (R_OR1K_GOTOFF_HI16,   16)
+  RELOC_NUMBER (R_OR1K_GOTOFF_LO16,   17)
+  RELOC_NUMBER (R_OR1K_COPY,          18)
+  RELOC_NUMBER (R_OR1K_GLOB_DAT,      19)
+  RELOC_NUMBER (R_OR1K_JMP_SLOT,      20)
+  RELOC_NUMBER (R_OR1K_RELATIVE,      21)
+  RELOC_NUMBER (R_OR1K_TLS_GD_HI16,   22)
+  RELOC_NUMBER (R_OR1K_TLS_GD_LO16,   23)
+  RELOC_NUMBER (R_OR1K_TLS_LDM_HI16,  24)
+  RELOC_NUMBER (R_OR1K_TLS_LDM_LO16,  25)
+  RELOC_NUMBER (R_OR1K_TLS_LDO_HI16,  26)
+  RELOC_NUMBER (R_OR1K_TLS_LDO_LO16,  27)
+  RELOC_NUMBER (R_OR1K_TLS_IE_HI16,   28)
+  RELOC_NUMBER (R_OR1K_TLS_IE_LO16,   29)
+  RELOC_NUMBER (R_OR1K_TLS_LE_HI16,   30)
+  RELOC_NUMBER (R_OR1K_TLS_LE_LO16,   31)
+  RELOC_NUMBER (R_OR1K_TLS_TPOFF,     32)
+  RELOC_NUMBER (R_OR1K_TLS_DTPOFF,    33)
+  RELOC_NUMBER (R_OR1K_TLS_DTPMOD,    34)
+END_RELOC_NUMBERS (R_OR1K_max)
+
+#define EF_OR1K_NODELAY (1UL << 0)
+
+#endif /* _ELF_OR1K_H */
--- a/include/elf/or32.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* OR1K ELF support for BFD. Derived from ppc.h.
-   Copyright (C) 2002, 2010 Free Software Foundation, Inc.
-   Contributed by Ivan Guzvinec  <ivang@opencores.org>
-
-   This file is part of BFD, the Binary File Descriptor library.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#ifndef _ELF_OR1K_H
-#define _ELF_OR1K_H
-
-#include "elf/reloc-macros.h"
-
-/* Relocations.  */
-START_RELOC_NUMBERS (elf_or32_reloc_type)
-  RELOC_NUMBER (R_OR32_NONE, 0)
-  RELOC_NUMBER (R_OR32_32, 1)
-  RELOC_NUMBER (R_OR32_16, 2)
-  RELOC_NUMBER (R_OR32_8, 3)
-  RELOC_NUMBER (R_OR32_CONST, 4)
-  RELOC_NUMBER (R_OR32_CONSTH, 5)
-  RELOC_NUMBER (R_OR32_JUMPTARG, 6)
-  RELOC_NUMBER (R_OR32_GNU_VTENTRY, 7)
-  RELOC_NUMBER (R_OR32_GNU_VTINHERIT, 8)
-END_RELOC_NUMBERS (R_OR32_max)
-
-/* Four bit OR32 machine type field.  */
-#define EF_OR32_MACH             0x0000000f
-
-/* Various CPU types.  */
-#define E_OR32_MACH_BASE         0x00000000
-#define E_OR32_MACH_UNUSED1      0x00000001
-#define E_OR32_MACH_UNUSED2      0x00000002
-#define E_OR32_MACH_UNUSED4      0x00000003
-
-/* Processor specific section headers, sh_type field */
-#define SHT_ORDERED		SHT_HIPROC	/* Link editor is to sort the \
-						   entries in this section \
-						   based on the address \
-						   specified in the associated \
-						   symbol table entry.  */
-
-#endif /* _ELF_OR1K_H */
--- a/include/opcode/or32.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/* Table of opcodes for the OpenRISC 1000 ISA.
-   Copyright 2002, 2003, 2010 Free Software Foundation, Inc.
-   Contributed by Damjan Lampret (lampret@opencores.org).
-   
-   This file is part of or1k_gen_isa, or1ksim, GDB and GAS.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-/* We treat all letters the same in encode/decode routines so
-   we need to assign some characteristics to them like signess etc.  */
-
-#ifndef OR32_H_ISA
-#define OR32_H_ISA
-
-#define NUM_UNSIGNED (0)
-#define NUM_SIGNED (1)
-
-#define MAX_GPRS 32
-#define PAGE_SIZE 4096
-#undef __HALF_WORD_INSN__
-
-#define OPERAND_DELIM (',')
-
-#define OR32_IF_DELAY (1)
-#define OR32_W_FLAG   (2)
-#define OR32_R_FLAG   (4)
-
-struct or32_letter
-{
-  char letter;
-  int  sign;
-  /* int  reloc; relocation per letter ??  */
-};
-
-/* Main instruction specification array.  */
-struct or32_opcode
-{
-  /* Name of the instruction.  */
-  char *name;
-
-  /* A string of characters which describe the operands.
-     Valid characters are:
-     ,() Itself.  Characters appears in the assembly code.
-     rA	 Register operand.
-     rB  Register operand.
-     rD  Register operand.
-     I	 An immediate operand, range -32768 to 32767.
-     J	 An immediate operand, range . (unused)
-     K	 An immediate operand, range 0 to 65535.
-     L	 An immediate operand, range 0 to 63.
-     M	 An immediate operand, range . (unused)
-     N	 An immediate operand, range -33554432 to 33554431.
-     O	 An immediate operand, range . (unused).  */
-  char *args;
-  
-  /* Opcode and operand encoding.  */
-  char *encoding;
-  void (*exec) (void);
-  unsigned int flags;
-};
-
-#define OPTYPE_LAST (0x80000000)
-#define OPTYPE_OP   (0x40000000)
-#define OPTYPE_REG  (0x20000000)
-#define OPTYPE_SIG  (0x10000000)
-#define OPTYPE_DIS  (0x08000000)
-#define OPTYPE_DST  (0x04000000)
-#define OPTYPE_SBIT (0x00001F00)
-#define OPTYPE_SHR  (0x0000001F)
-#define OPTYPE_SBIT_SHR (8)
-
-/* MM: Data how to decode operands.  */
-extern struct insn_op_struct
-{
-  unsigned long type;
-  unsigned long data;
-} **op_start;
-
-#ifdef HAS_EXECUTION
-extern void l_invalid (void);
-extern void l_sfne    (void);
-extern void l_bf      (void);
-extern void l_add     (void);
-extern void l_sw      (void);
-extern void l_sb      (void);
-extern void l_sh      (void);
-extern void l_lwz     (void);
-extern void l_lbs     (void);
-extern void l_lbz     (void);
-extern void l_lhs     (void);
-extern void l_lhz     (void);
-extern void l_movhi   (void);
-extern void l_and     (void);
-extern void l_or      (void);
-extern void l_xor     (void);
-extern void l_sub     (void);
-extern void l_mul     (void);
-extern void l_div     (void);
-extern void l_divu    (void);
-extern void l_sll     (void);
-extern void l_sra     (void);
-extern void l_srl     (void);
-extern void l_j       (void);
-extern void l_jal     (void);
-extern void l_jalr    (void);
-extern void l_jr      (void);
-extern void l_rfe     (void);
-extern void l_nop     (void);
-extern void l_bnf     (void);
-extern void l_sfeq    (void);
-extern void l_sfgts   (void);
-extern void l_sfges   (void);
-extern void l_sflts   (void);
-extern void l_sfles   (void);
-extern void l_sfgtu   (void);
-extern void l_sfgeu   (void);
-extern void l_sfltu   (void);
-extern void l_sfleu   (void);
-extern void l_mtspr   (void);
-extern void l_mfspr   (void);
-extern void l_sys     (void);
-extern void l_trap    (void); /* CZ 21/06/01.  */
-extern void l_macrc   (void);
-extern void l_mac     (void);
-extern void l_msb     (void);
-extern void l_invalid (void);
-extern void l_cust1   (void);
-extern void l_cust2   (void);
-extern void l_cust3   (void);
-extern void l_cust4   (void);
-#endif
-extern void l_none    (void);
-
-extern const struct or32_letter or32_letters[];
-
-extern const struct  or32_opcode or32_opcodes[];
-
-extern const unsigned int or32_num_opcodes;
-
-/* Calculates instruction length in bytes.  Always 4 for OR32.  */
-extern int insn_len (int);
-
-/* Is individual insn's operand signed or unsigned?  */
-extern int letter_signed (char);
-
-/* Number of letters in the individual lettered operand.  */
-extern int letter_range (char);
-
-/* MM: Returns index of given instruction name.  */
-extern int insn_index (char *);
-
-/* MM: Returns instruction name from index.  */
-extern const char *insn_name (int);
-
-/* MM: Constructs new FSM, based on or32_opcodes.  */ 
-extern void build_automata (void);
-
-/* MM: Destructs FSM.  */ 
-extern void destruct_automata (void);
-
-/* MM: Decodes instruction using FSM.  Call build_automata first.  */
-extern int insn_decode (unsigned int);
-
-/* Disassemble one instruction from insn to disassemble.
-   Return the size of the instruction.  */
-int disassemble_insn (unsigned long);
-
-#endif
--- a/ld/Makefile.am
+++ b/ld/Makefile.am
@@ -243,7 +243,8 @@
 	eelf32microblaze.c \
 	eelf32moxie.c \
 	eelf32mt.c \
-	eelf32openrisc.c \
+	eelf32or1k.c \
+	eelf32or1k_linux.c \
 	eelf32ppc.c \
 	eelf32ppc_fbsd.c \
 	eelf32ppclinux.c \
@@ -398,8 +399,6 @@
 	emsp430X.c \
 	enews.c \
 	ens32knbsd.c \
-	eor32.c \
-	eor32elf.c \
 	epc532macha.c \
 	epdp11.c \
 	epjelf.c \
@@ -1183,9 +1182,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mt "$(tdir_mt)"
-eelf32openrisc.c: $(srcdir)/emulparams/elf32openrisc.sh \
-  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} elf32openrisc "$(tdir_openrisc)"
+eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32or1k "$(tdir_elf32or1k)"
+eelf32or1k_linux.c: $(srcdir)/emulparams/elf32or1k_linux.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32or1k_linux "$(tdir_elf32or1k_linux)"
 eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
   $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
   ldemul-list.h \
@@ -1797,12 +1799,6 @@
   $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} aarch64linux32b "$(tdir_aarch64linux32b)"
-eor32.c: $(srcdir)/emulparams/or32.sh \
-  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/or32.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} or32 "$(tdir_or32)"
-eor32elf.c: $(srcdir)/emulparams/or32elf.sh \
-  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} or32elf "$(tdir_or32elf)"
 epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} pc532macha "$(tdir_pc532macha)"
--- a/ld/Makefile.in
+++ b/ld/Makefile.in
@@ -551,7 +551,8 @@
 	eelf32microblaze.c \
 	eelf32moxie.c \
 	eelf32mt.c \
-	eelf32openrisc.c \
+	eelf32or1k.c \
+	eelf32or1k_linux.c \
 	eelf32ppc.c \
 	eelf32ppc_fbsd.c \
 	eelf32ppclinux.c \
@@ -706,8 +707,6 @@
 	emsp430X.c \
 	enews.c \
 	ens32knbsd.c \
-	eor32.c \
-	eor32elf.c \
 	epc532macha.c \
 	epdp11.c \
 	epjelf.c \
@@ -1211,7 +1210,8 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mipswindiss.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32moxie.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32mt.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32openrisc.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32or1k_linux.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppc_fbsd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eelf32ppclinux.Po@am__quote@
@@ -1400,8 +1400,6 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emsp430xW427.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/enews.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ens32knbsd.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eor32.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eor32elf.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epc532macha.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Po@am__quote@
@@ -2667,9 +2665,12 @@
 eelf32mt.c: $(srcdir)/emulparams/elf32mt.sh \
   $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf32mt "$(tdir_mt)"
-eelf32openrisc.c: $(srcdir)/emulparams/elf32openrisc.sh \
-  $(ELF_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} elf32openrisc "$(tdir_openrisc)"
+eelf32or1k.c: $(srcdir)/emulparams/elf32or1k.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32or1k "$(tdir_elf32or1k)"
+eelf32or1k_linux.c: $(srcdir)/emulparams/elf32or1k_linux.sh \
+  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf32or1k_linux "$(tdir_elf32or1k_linux)"
 eelf32ppc.c: $(srcdir)/emulparams/elf32ppc.sh \
   $(srcdir)/emulparams/elf32ppccommon.sh $(srcdir)/emultempl/ppc32elf.em \
   ldemul-list.h \
@@ -3281,12 +3282,6 @@
   $(ELF_DEPS) $(srcdir)/emultempl/aarch64elf.em \
   $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} aarch64linux32b "$(tdir_aarch64linux32b)"
-eor32.c: $(srcdir)/emulparams/or32.sh \
-  $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/or32.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} or32 "$(tdir_or32)"
-eor32elf.c: $(srcdir)/emulparams/or32elf.sh \
-  $(ELF_GEN_DEPS) $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
-	${GENSCRIPTS} or32elf "$(tdir_or32elf)"
 epc532macha.c: $(srcdir)/emulparams/pc532macha.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/aout.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} pc532macha "$(tdir_pc532macha)"
--- a/ld/configure.tgt
+++ b/ld/configure.tgt
@@ -525,10 +525,9 @@
 ns32k-pc532-mach* | ns32k-pc532-ux*)  targ_emul=pc532macha ;;
 ns32k-*-netbsd* | ns32k-pc532-lites*) targ_emul=ns32knbsd
 			;;
-openrisc-*-*)		targ_emul=elf32openrisc ;;
-or32-*-coff)		targ_emul=or32 ;;
-or32-*-elf)		targ_emul=or32elf ;;
-or32-*-rtems*)          targ_emul=or32elf
+or1k-*-elf | or1knd-*-elf)		targ_emul=elf32or1k ;;
+or1k-*-linux* | or1knd-*-linux*)	targ_emul=elf32or1k_linux ;;
+or1k-*-rtems* | or1knd-*-rtems*)	targ_emul=elf32or1k
 			;;
 pdp11-*-*)		targ_emul=pdp11
 			;;
--- a/ld/emulparams/elf32openrisc.sh
+++ /dev/null
@@ -1,11 +0,0 @@
-MACHINE=
-SCRIPT_NAME=elf
-OUTPUT_FORMAT="elf32-openrisc"
-NO_RELA_RELOCS=yes
-TEXT_START_ADDR=0x10000
-ARCH=openrisc
-MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
-ENTRY=_start
-EMBEDDED=yes
-NOP=0x15000000
-
--- /dev/null
+++ b/ld/emulparams/elf32or1k.sh
@@ -0,0 +1,14 @@
+SCRIPT_NAME=elf
+MACHINE=
+TEMPLATE_NAME=elf32
+OUTPUT_FORMAT="elf32-or1k"
+NOP=0x15000000
+TEXT_START_ADDR=0x0000
+TARGET_PAGE_SIZE=0x2000
+MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
+EMBEDDED=yes
+ARCH=or1k
+ELFSIZE=32
+INITIAL_READONLY_SECTIONS=".vectors ${RELOCATING-0} : { KEEP (*(.vectors)) }"
+NO_REL_RELOCS=yes
+COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
--- /dev/null
+++ b/ld/emulparams/elf32or1k_linux.sh
@@ -0,0 +1,5 @@
+. ${srcdir}/emulparams/elf32or1k.sh
+unset EMBEDDED
+GENERATE_SHLIB_SCRIPT=yes
+GENERATE_PIE_SCRIPT=yes
+GENERATE_COMBRELOC_SCRIPT=yes
--- a/ld/emulparams/or32.sh
+++ /dev/null
@@ -1,5 +0,0 @@
-SCRIPT_NAME=or32
-OUTPUT_FORMAT="coff-or32-big"
-TEXT_START_ADDR=0x1000000
-TARGET_PAGE_SIZE=0x1000000
-ARCH=or32
--- a/ld/emulparams/or32elf.sh
+++ /dev/null
@@ -1,9 +0,0 @@
-SCRIPT_NAME=elf
-TEMPLATE_NAME=generic
-EXTRA_EM_FILE=genelf
-OUTPUT_FORMAT="elf32-or32"
-NO_RELA_RELOCS=yes
-TEXT_START_ADDR=0x1000000
-TARGET_PAGE_SIZE=0x1000000
-MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
-ARCH=or32
--- a/ld/scripttempl/or32.sc
+++ /dev/null
@@ -1,37 +0,0 @@
-cat <<EOF
-OUTPUT_FORMAT("${OUTPUT_FORMAT}")
-${LIB_SEARCH_DIRS}
-
-SECTIONS
-{
-  .text : {
-    *(.text)
-    ${RELOCATING+ __etext  =  .};
-    ${CONSTRUCTING+ __CTOR_LIST__ = .;}
-    ${CONSTRUCTING+ LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)}
-    ${CONSTRUCTING+ *(.ctors)}
-    ${CONSTRUCTING+ LONG(0)}
-    ${CONSTRUCTING+ __CTOR_END__ = .;}
-    ${CONSTRUCTING+ __DTOR_LIST__ = .;}
-    ${CONSTRUCTING+ LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2)}
-    ${CONSTRUCTING+ *(.dtors)}
-    ${CONSTRUCTING+ LONG(0)}
-    ${CONSTRUCTING+ __DTOR_END__ = .;}
-    *(.lit)
-    *(.shdata)
-  }
-  .shbss SIZEOF(.text) + ADDR(.text) :	{
-    *(.shbss)
-  } 
-  .data  : {
-    *(.data)
-    ${RELOCATING+ __edata  =  .};
-  }
-  .bss   SIZEOF(.data) + ADDR(.data) :
-  { 					
-   *(.bss)
-   *(COMMON)
-     ${RELOCATING+ __end = ALIGN(0x8)};
-  }
-}
-EOF
--- a/ld/testsuite/ld-discard/extern.d
+++ b/ld/testsuite/ld-discard/extern.d
@@ -2,7 +2,7 @@
 #ld: -T discard.ld
 #error: .*data.* referenced in section `\.text' of tmpdir/dump0.o: defined in discarded section `\.data\.exit' of tmpdir/dump0.o
 #objdump: -p
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #xfail: m68hc12-*-* m6812-*-*
 #pass
 # The expected warning used to start with "`data' referenced..." but
--- a/ld/testsuite/ld-discard/start.d
+++ b/ld/testsuite/ld-discard/start.d
@@ -3,6 +3,6 @@
 #ld: -T discard.ld
 #error: `data' referenced in section `\.text' of tmpdir/dump0.o: defined in discarded section `\.data\.exit' of tmpdir/dump1.o
 #objdump: -p
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #xfail: m68hc12-*-* m6812-*-*
 #pass
--- a/ld/testsuite/ld-discard/static.d
+++ b/ld/testsuite/ld-discard/static.d
@@ -2,6 +2,6 @@
 #ld: -T discard.ld
 #error: `(\.data\.exit|data)' referenced in section `\.text' of tmpdir/dump0.o: defined in discarded section `\.data\.exit' of tmpdir/dump0.o
 #objdump: -p
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #xfail: m68hc12-*-* m6812-*-*
 #pass
--- a/ld/testsuite/ld-elf/group1.d
+++ b/ld/testsuite/ld-elf/group1.d
@@ -2,7 +2,7 @@
 #source: group1b.s
 #ld: -T group.ld
 #readelf: -s
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 # generic linker targets don't comply with all symbol merging rules
 
 Symbol table '.symtab' contains .* entries:
--- a/ld/testsuite/ld-elf/group3b.d
+++ b/ld/testsuite/ld-elf/group3b.d
@@ -2,7 +2,7 @@
 #source: group3a.s
 #ld: -T group.ld
 #readelf: -s
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 # generic linker targets don't comply with all symbol merging rules
 
 Symbol table '.symtab' contains .* entries:
--- a/ld/testsuite/ld-elf/group8a.d
+++ b/ld/testsuite/ld-elf/group8a.d
@@ -1,7 +1,7 @@
 #source: group8.s
 #ld: -r --gc-sections --entry foo
 #readelf: -g --wide
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 #xfail: cr16-*-* crx-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
--- a/ld/testsuite/ld-elf/group8b.d
+++ b/ld/testsuite/ld-elf/group8b.d
@@ -1,7 +1,7 @@
 #source: group8.s
 #ld: -r --gc-sections --entry bar
 #readelf: -g --wide
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 #xfail: cr16-*-* crx-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
--- a/ld/testsuite/ld-elf/group9a.d
+++ b/ld/testsuite/ld-elf/group9a.d
@@ -1,7 +1,7 @@
 #source: group9.s
 #ld: -r --gc-sections --entry foo
 #readelf: -g --wide
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: alpha-*-* hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 #xfail: cr16-*-* crx-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
--- a/ld/testsuite/ld-elf/group9b.d
+++ b/ld/testsuite/ld-elf/group9b.d
@@ -1,7 +1,7 @@
 #source: group9.s
 #ld: -r --gc-sections --entry bar
 #readelf: -g --wide
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: alpha-*-* hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 #xfail: cr16-*-* crx-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
--- a/ld/testsuite/ld-elf/linkonce2.d
+++ b/ld/testsuite/ld-elf/linkonce2.d
@@ -2,7 +2,7 @@
 #source: linkonce1b.s
 #ld: -emit-relocs
 #objdump: -r
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 # generic elf targets don't emit relocs
 
 .*:     file format .*
--- a/ld/testsuite/ld-elf/merge.d
+++ b/ld/testsuite/ld-elf/merge.d
@@ -5,7 +5,7 @@
 #xfail: "dlx-*-*" "fr30-*-*" "frv-*-*" "hppa*64*-*-*" "h8300-*-*" "score-*-*"
 #xfail: "i370-*-*" "i860-*-*" "i960-*-*" "ip2k-*-*" "iq2000-*-*" "lm32-*-*"
 #xfail: "mcore-*-*" "mn102*-*-*" "mips*-*-*" "ms1-*-*" "mep-*-*"
-#xfail: "or32-*-*" "pj-*-*" "sparc*-*-*" "tic6x-*-*" "vax-*-*" "xstormy16-*-*"
+#xfail: "pj-*-*" "sparc*-*-*" "tic6x-*-*" "vax-*-*" "xstormy16-*-*"
 #xfail: "xtensa*-*-*" "metag-*-*"
 
 .*:     file format .*elf.*
--- a/ld/testsuite/ld-elf/merge2.d
+++ b/ld/testsuite/ld-elf/merge2.d
@@ -2,7 +2,7 @@
 #ld: -T merge.ld
 #objdump: -s
 #xfail: "arc-*-*" "d30v-*-*" "dlx-*-*" "hppa64-*-*"
-#xfail: "i960-*-*" "ip2k-*-*" "or32-*-*" "pj-*-*"
+#xfail: "i960-*-*" "ip2k-*-*" "pj-*-*"
 
 .*:     file format .*elf.*
 
--- a/ld/testsuite/ld-elf/orphan-region.d
+++ b/ld/testsuite/ld-elf/orphan-region.d
@@ -2,7 +2,7 @@
 #ld: -T orphan-region.ld -N -z stack-size=0
 #readelf: -S -l --wide
 #xfail: arc-*-* d30v-*-* dlx-*-* fr30-*-* frv-*-elf i860-*-* i960-*-*
-#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* or32-*-* pj*-*-*
+#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* pj*-*-*
 #xfail: spu-*-* hppa*64*-*-* *-*-nacl*
 # if not using elf32.em, you don't get fancy orphan handling
 # spu twiddles LOAD range, hppa64 adds PHDR, nacl splits to two segments
--- a/ld/testsuite/ld-elf/orphan.d
+++ b/ld/testsuite/ld-elf/orphan.d
@@ -2,7 +2,7 @@
 #ld: -T orphan.ld
 #readelf: -S --wide
 #xfail: arc-*-* d30v-*-* dlx-*-* fr30-*-* frv-*-elf i860-*-* i960-*-*
-#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* or32-*-* pj*-*-*
+#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* pj*-*-*
 # if not using elf32.em, you don't get fancy orphan handling
 
 #...
--- a/ld/testsuite/ld-elf/orphan3.d
+++ b/ld/testsuite/ld-elf/orphan3.d
@@ -8,7 +8,7 @@
 #readelf: -S --wide
 #xfail: "arc-*-*" "d30v-*-*" "dlx-*-*" "fr30-*-*" "frv-*-elf"
 #xfail: "i860-*-*" "i960-*-*" "iq2000-*-*" "mn10200-*-*" "msp430-*-*" "mt-*-*"
-#xfail: "or32-*-*" "pj-*-*"
+#xfail: "pj-*-*"
 #xfail: "xstormy16-*-*"
 
 #...
--- a/ld/testsuite/ld-elf/pr12851.d
+++ b/ld/testsuite/ld-elf/pr12851.d
@@ -2,7 +2,7 @@
 #source: start.s
 #ld: --gc-sections
 #readelf: -s --wide
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
 
--- a/ld/testsuite/ld-elf/pr12975.d
+++ b/ld/testsuite/ld-elf/pr12975.d
@@ -1,7 +1,7 @@
 #ld: --gc-sections -shared -version-script pr12975.t
 #readelf: -s --wide
 #target: *-*-linux* *-*-gnu*
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
 
--- a/ld/testsuite/ld-elf/pr13177.d
+++ b/ld/testsuite/ld-elf/pr13177.d
@@ -2,7 +2,7 @@
 #ld: --gc-sections -shared
 #readelf: -s -D --wide
 #target: *-*-linux* *-*-gnu*
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
 
--- a/ld/testsuite/ld-elf/pr13195.d
+++ b/ld/testsuite/ld-elf/pr13195.d
@@ -1,7 +1,7 @@
 #ld: --gc-sections -shared -version-script pr13195.t
 #readelf: -s --wide -D
 #target: *-*-linux* *-*-gnu*
-#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#notarget: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 #notarget: hppa64-*-* i370-*-* i860-*-* ia64-*-* mep-*-* mn10200-*-*
 # generic linker targets don't support --gc-sections, nor do a bunch of others
 
--- a/ld/testsuite/ld-elf/pr349.d
+++ b/ld/testsuite/ld-elf/pr349.d
@@ -3,7 +3,7 @@
 #ld: -r
 #readelf: -S
 #xfail: arc-*-* d30v-*-* dlx-*-* fr30-*-* frv-*-elf i860-*-* i960-*-*
-#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* or32-*-* pj*-*-*
+#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* pj*-*-*
 # if not using elf32.em, you don't get fancy section handling
 
 #...
--- a/ld/testsuite/ld-elf/sec64k.exp
+++ b/ld/testsuite/ld-elf/sec64k.exp
@@ -35,7 +35,7 @@
      || [istarget "dlx-*-*"]
      || [istarget "i960-*-*"]
      || [istarget "msp430*-*-*"]
-     || [istarget "or32-*-*"]
+     || [istarget "or1k*-*-*"]
      || [istarget "pj*-*-*"]
      || [istarget "m32r-*-*"] } {
     return
--- a/ld/testsuite/ld-elf/warn1.d
+++ b/ld/testsuite/ld-elf/warn1.d
@@ -5,7 +5,7 @@
 #warning: ^[^\\n]*\): warning: witty one-liner$
 #readelf: -s
 #notarget: "sparc64-*-solaris2*" "sparcv9-*-solaris2*"
-#xfail: "arc-*-*" "d30v-*-*" "dlx-*-*" "i960-*-*" "or32-*-*" "pj-*-*"
+#xfail: "arc-*-*" "d30v-*-*" "dlx-*-*" "i960-*-*" "pj-*-*"
 
 # Check that warnings are generated for the .gnu.warning.SYMBOL
 # construct and that the symbol still appears as expected.
--- a/ld/testsuite/ld-elf/warn2.d
+++ b/ld/testsuite/ld-elf/warn2.d
@@ -6,7 +6,7 @@
 #readelf: -s
 #notarget: "sparc64-*-solaris2*" "sparcv9-*-solaris2*"
 #xfail: arc-*-* d30v-*-* dlx-*-* fr30-*-* frv-*-elf i860-*-* i960-*-*
-#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* or32-*-* pj*-*-*
+#xfail: iq*-*-* mn10200-*-* moxie-*-* msp*-*-* mt-*-* pj*-*-*
 # if not using elf32.em, you don't get fancy section handling
 
 # Check that warnings are generated for the symbols in .gnu.warning
--- a/ld/testsuite/ld-elf/warn3.d
+++ b/ld/testsuite/ld-elf/warn3.d
@@ -3,7 +3,7 @@
 #warning: .*: warning: badsym warning$
 #readelf: -s
 #notarget: hppa64*-hpux*
-#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* or32-*-* pj*-*-*
+#xfail: arc-*-* d30v-*-* dlx-*-* i960-*-* pj*-*-*
 # generic linker targets don't support .gnu.warning sections.
 
 # Check that warnings are generated for the symbols in .gnu.warning
--- a/ld/testsuite/ld-scripts/weak.exp
+++ b/ld/testsuite/ld-scripts/weak.exp
@@ -34,8 +34,8 @@
     setup_xfail *-*-pe*
 }
 
-# hppa64 and or32 are incredibly broken
-setup_xfail hppa64-*-* or32-*-*
+# hppa64 is incredibly broken
+setup_xfail hppa64-*-*
 
 if {! [ld_assemble $as $srcdir/$subdir/weak1.s tmpdir/weak1.o]
     || ! [ld_assemble $as $srcdir/$subdir/weak2.s tmpdir/weak2.o]} then {
--- a/ld/testsuite/lib/ld-lib.exp
+++ b/ld/testsuite/lib/ld-lib.exp
@@ -1520,7 +1520,6 @@
 	    || [istarget d30v-*-*]
 	    || [istarget dlx-*-*]
 	    || [istarget i960-*-*]
-	    || [istarget or32-*-*]
 	    || [istarget pj*-*-*]
 	    || [istarget alpha-*-*]
 	    || [istarget hppa*64-*-*]
@@ -1592,8 +1591,7 @@
 	 && ![istarget moxie-*-*]
 	 && ![istarget msp430-*-*]
 	 && ![istarget mt-*-*]
-	 && ![istarget openrisc-*-*]
-	 && ![istarget or32-*-*]
+	 && ![istarget or1k*-*-*]
 	 && ![istarget pj-*-*]
 	 && ![istarget rl78-*-*]
 	 && ![istarget rx-*-*]
--- a/opcodes/Makefile.am
+++ b/opcodes/Makefile.am
@@ -79,8 +79,6 @@
 	mep-desc.h mep-opc.h \
 	microblaze-opc.h \
 	mt-desc.h mt-opc.h \
-	openrisc-desc.h openrisc-opc.h \
-	score-opc.h \
 	sh-opc.h \
 	sh64-opc.h \
 	sysdep.h \
@@ -209,13 +207,11 @@
 	nios2-dis.c \
 	nios2-opc.c \
 	ns32k-dis.c \
-	openrisc-asm.c \
-	openrisc-desc.c \
-	openrisc-dis.c \
-	openrisc-ibld.c \
-	openrisc-opc.c \
-	or32-dis.c \
-	or32-opc.c \
+	or1k-asm.c \
+	or1k-desc.c \
+	or1k-dis.c \
+	or1k-ibld.c \
+	or1k-opc.c \
 	pdp11-dis.c \
 	pdp11-opc.c \
 	pj-dis.c \
@@ -353,7 +349,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-openrisc stamp-xc16x stamp-xstormy16 \
+	stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 
@@ -369,7 +365,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt openrisc xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
 
 if CGEN_MAINT
 EPIPHANY_DEPS = stamp-epiphany
@@ -382,7 +378,7 @@
 M32R_DEPS = stamp-m32r
 MEP_DEPS = stamp-mep
 MT_DEPS = stamp-mt
-OPENRISC_DEPS = stamp-openrisc
+OR1K_DEPS = stamp-or1k
 XC16X_DEPS = stamp-xc16x
 XSTORMY16_DEPS = stamp-xstormy16
 else
@@ -396,7 +392,7 @@
 M32R_DEPS =
 MEP_DEPS =
 MT_DEPS =
-OPENRISC_DEPS = 
+OR1K_DEPS = 
 XC16X_DEPS = 
 XSTORMY16_DEPS = 
 endif
@@ -490,11 +486,11 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
-$(srcdir)/openrisc-desc.h $(srcdir)/openrisc-desc.c $(srcdir)/openrisc-opc.h $(srcdir)/openrisc-opc.c $(srcdir)/openrisc-ibld.c $(srcdir)/openrisc-asm.c $(srcdir)/openrisc-dis.c: $(OPENRISC_DEPS)
+$(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
-stamp-openrisc: $(CGENDEPS) $(CPUDIR)/openrisc.cpu $(CPUDIR)/openrisc.opc
-	$(MAKE) run-cgen arch=openrisc prefix=openrisc options= \
-		archfile=$(CPUDIR)/openrisc.cpu opcfile=$(CPUDIR)/openrisc.opc extrafiles=
+stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
+	$(MAKE) run-cgen arch=or1k prefix=or1k options=opinst \
+		archfile=$(CPUDIR)/or1k.cpu opcfile=$(CPUDIR)/or1k.opc extrafiles=opinst
 
 $(srcdir)/xc16x-desc.h $(srcdir)/xc16x-desc.c $(srcdir)/xc16x-opc.h $(srcdir)/xc16x-opc.c $(srcdir)/xc16x-ibld.c $(srcdir)/xc16x-asm.c $(srcdir)/xc16x-dis.c: $(XC16X_DEPS)
 	@true
--- a/opcodes/Makefile.in
+++ b/opcodes/Makefile.in
@@ -350,8 +350,6 @@
 	mep-desc.h mep-opc.h \
 	microblaze-opc.h \
 	mt-desc.h mt-opc.h \
-	openrisc-desc.h openrisc-opc.h \
-	score-opc.h \
 	sh-opc.h \
 	sh64-opc.h \
 	sysdep.h \
@@ -481,13 +479,11 @@
 	nios2-dis.c \
 	nios2-opc.c \
 	ns32k-dis.c \
-	openrisc-asm.c \
-	openrisc-desc.c \
-	openrisc-dis.c \
-	openrisc-ibld.c \
-	openrisc-opc.c \
-	or32-dis.c \
-	or32-opc.c \
+	or1k-asm.c \
+	or1k-desc.c \
+	or1k-dis.c \
+	or1k-ibld.c \
+	or1k-opc.c \
 	pdp11-dis.c \
 	pdp11-opc.c \
 	pj-dis.c \
@@ -594,7 +590,7 @@
 CLEANFILES = \
 	stamp-epiphany stamp-fr30 stamp-frv stamp-ip2k stamp-iq2000 stamp-lm32 \
 	stamp-m32c stamp-m32r stamp-mep stamp-mt \
-	stamp-openrisc stamp-xc16x stamp-xstormy16 \
+	stamp-or1k stamp-xc16x stamp-xstormy16 \
 	libopcodes.a stamp-lib
 
 CGENDIR = @cgendir@
@@ -608,7 +604,7 @@
 	$(CGENDIR)/opc-opinst.scm \
 	cgen-asm.in cgen-dis.in cgen-ibld.in
 
-CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt openrisc xc16x xstormy16
+CGEN_CPUS = epiphany fr30 frv ip2k iq2000 lm32 m32c m32r mep mt or1k xc16x xstormy16
 @CGEN_MAINT_FALSE@EPIPHANY_DEPS = 
 @CGEN_MAINT_TRUE@EPIPHANY_DEPS = stamp-epiphany
 @CGEN_MAINT_FALSE@FR30_DEPS = 
@@ -629,8 +625,8 @@
 @CGEN_MAINT_TRUE@MEP_DEPS = stamp-mep
 @CGEN_MAINT_FALSE@MT_DEPS = 
 @CGEN_MAINT_TRUE@MT_DEPS = stamp-mt
-@CGEN_MAINT_FALSE@OPENRISC_DEPS = 
-@CGEN_MAINT_TRUE@OPENRISC_DEPS = stamp-openrisc
+@CGEN_MAINT_FALSE@OR1K_DEPS = 
+@CGEN_MAINT_TRUE@OR1K_DEPS = stamp-or1k
 @CGEN_MAINT_FALSE@XC16X_DEPS = 
 @CGEN_MAINT_TRUE@XC16X_DEPS = stamp-xc16x
 @CGEN_MAINT_FALSE@XSTORMY16_DEPS = 
@@ -882,13 +878,11 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nios2-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nios2-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ns32k-dis.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openrisc-asm.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openrisc-desc.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openrisc-dis.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openrisc-ibld.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/openrisc-opc.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or32-dis.Plo@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or32-opc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or1k-asm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or1k-desc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or1k-dis.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or1k-ibld.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/or1k-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pdp11-dis.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pdp11-opc.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pj-dis.Plo@am__quote@
@@ -1367,11 +1361,11 @@
 		archfile=$(CPUDIR)/mt.cpu \
 		opcfile=$(CPUDIR)/mt.opc extrafiles=
 
-$(srcdir)/openrisc-desc.h $(srcdir)/openrisc-desc.c $(srcdir)/openrisc-opc.h $(srcdir)/openrisc-opc.c $(srcdir)/openrisc-ibld.c $(srcdir)/openrisc-asm.c $(srcdir)/openrisc-dis.c: $(OPENRISC_DEPS)
+$(srcdir)/or1k-desc.h $(srcdir)/or1k-desc.c $(srcdir)/or1k-opc.h $(srcdir)/or1k-opc.c $(srcdir)/or1k-ibld.c $(srcdir)/or1k-opinst.c $(srcdir)/or1k-asm.c $(srcdir)/or1k-dis.c: $(OR1K_DEPS)
 	@true
-stamp-openrisc: $(CGENDEPS) $(CPUDIR)/openrisc.cpu $(CPUDIR)/openrisc.opc
-	$(MAKE) run-cgen arch=openrisc prefix=openrisc options= \
-		archfile=$(CPUDIR)/openrisc.cpu opcfile=$(CPUDIR)/openrisc.opc extrafiles=
+stamp-or1k: $(CGENDEPS) $(CPUDIR)/or1k.cpu $(CPUDIR)/or1k.opc $(CPUDIR)/or1kcommon.cpu $(CPUDIR)/or1korbis.cpu $(CPUDIR)/or1korfpx.cpu
+	$(MAKE) run-cgen arch=or1k prefix=or1k options=opinst \
+		archfile=$(CPUDIR)/or1k.cpu opcfile=$(CPUDIR)/or1k.opc extrafiles=opinst
 
 $(srcdir)/xc16x-desc.h $(srcdir)/xc16x-desc.c $(srcdir)/xc16x-opc.h $(srcdir)/xc16x-opc.c $(srcdir)/xc16x-ibld.c $(srcdir)/xc16x-asm.c $(srcdir)/xc16x-dis.c: $(XC16X_DEPS)
 	@true
--- a/opcodes/configure
+++ b/opcodes/configure
@@ -12548,8 +12548,7 @@
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
 	bfd_ns32k_arch)		ta="$ta ns32k-dis.lo" ;;
-	bfd_openrisc_arch)	ta="$ta openrisc-asm.lo openrisc-desc.lo openrisc-dis.lo openrisc-ibld.lo openrisc-opc.lo" using_cgen=yes ;;
-	bfd_or32_arch)		ta="$ta or32-dis.lo or32-opc.lo" using_cgen=yes ;;
+	bfd_or1k_arch)		ta="$ta or1k-asm.lo or1k-desc.lo or1k-dis.lo or1k-ibld.lo or1k-opc.lo" using_cgen=yes ;;
 	bfd_pdp11_arch)		ta="$ta pdp11-dis.lo pdp11-opc.lo" ;;
 	bfd_pj_arch)		ta="$ta pj-dis.lo pj-opc.lo" ;;
 	bfd_powerpc_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
--- a/opcodes/configure.in
+++ b/opcodes/configure.in
@@ -295,8 +295,7 @@
 	bfd_msp430_arch)	ta="$ta msp430-dis.lo msp430-decode.lo" ;;
 	bfd_nios2_arch)		ta="$ta nios2-dis.lo nios2-opc.lo" ;;
 	bfd_ns32k_arch)		ta="$ta ns32k-dis.lo" ;;
-	bfd_openrisc_arch)	ta="$ta openrisc-asm.lo openrisc-desc.lo openrisc-dis.lo openrisc-ibld.lo openrisc-opc.lo" using_cgen=yes ;;
-	bfd_or32_arch)		ta="$ta or32-dis.lo or32-opc.lo" using_cgen=yes ;;
+	bfd_or1k_arch)		ta="$ta or1k-asm.lo or1k-desc.lo or1k-dis.lo or1k-ibld.lo or1k-opc.lo" using_cgen=yes ;;
 	bfd_pdp11_arch)		ta="$ta pdp11-dis.lo pdp11-opc.lo" ;;
 	bfd_pj_arch)		ta="$ta pj-dis.lo pj-opc.lo" ;;
 	bfd_powerpc_arch)	ta="$ta ppc-dis.lo ppc-opc.lo" ;;
--- a/opcodes/disassemble.c
+++ b/opcodes/disassemble.c
@@ -69,8 +69,7 @@
 #define ARCH_msp430
 #define ARCH_nios2
 #define ARCH_ns32k
-#define ARCH_openrisc
-#define ARCH_or32
+#define ARCH_or1k
 #define ARCH_pdp11
 #define ARCH_pj
 #define ARCH_powerpc
@@ -347,17 +346,9 @@
 	disassemble = print_insn_little_nios2;
       break;
 #endif
-#ifdef ARCH_openrisc
-    case bfd_arch_openrisc:
-      disassemble = print_insn_openrisc;
-      break;
-#endif
-#ifdef ARCH_or32
-    case bfd_arch_or32:
-      if (bfd_big_endian (abfd))
-	disassemble = print_insn_big_or32;
-      else
-	disassemble = print_insn_little_or32;
+#ifdef ARCH_or1k
+    case bfd_arch_or1k:
+      disassemble = print_insn_or1k;
       break;
 #endif
 #ifdef ARCH_pdp11
--- a/opcodes/openrisc-asm.c
+++ /dev/null
@@ -1,649 +0,0 @@
-/* Assembler interface for targets using CGEN. -*- C -*-
-   CGEN: Cpu tools GENerator
-
-   THIS FILE IS MACHINE GENERATED WITH CGEN.
-   - the resultant file is machine generated, cgen-asm.in isn't
-
-   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2007, 2008, 2010
-   Free Software Foundation, Inc.
-
-   This file is part of libopcodes.
-
-   This library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
-
-
-/* ??? Eventually more and more of this stuff can go to cpu-independent files.
-   Keep that in mind.  */
-
-#include "sysdep.h"
-#include <stdio.h>
-#include "ansidecl.h"
-#include "bfd.h"
-#include "symcat.h"
-#include "openrisc-desc.h"
-#include "openrisc-opc.h"
-#include "opintl.h"
-#include "xregex.h"
-#include "libiberty.h"
-#include "safe-ctype.h"
-
-#undef  min
-#define min(a,b) ((a) < (b) ? (a) : (b))
-#undef  max
-#define max(a,b) ((a) > (b) ? (a) : (b))
-
-static const char * parse_insn_normal
-  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);
-
-/* -- assembler routines inserted here.  */
-
-/* -- asm.c */
-
-static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
-
-#define CGEN_VERBOSE_ASSEMBLER_ERRORS
-
-long
-openrisc_sign_extend_16bit (long value)
-{
-  return ((value & 0xffff) ^ 0x8000) - 0x8000;
-}
-
-/* Handle hi().  */
-
-static const char *
-parse_hi16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "hi(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      if (errmsg == NULL
-          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
-        value >>= 16;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* Handle lo().  */
-
-static const char *
-parse_lo16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
-{
-  const char *errmsg;
-  enum cgen_parse_operand_result result_type;
-  unsigned long ret;
-
-  if (**strp == '#')
-    ++*strp;
-
-  if (strncasecmp (*strp, "lo(", 3) == 0)
-    {
-      bfd_vma value;
-
-      *strp += 3;
-      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
-				   & result_type, & value);
-      if (**strp != ')')
-        return MISSING_CLOSING_PARENTHESIS;
-
-      ++*strp;
-      ret = value;
-    }
-  else
-    {
-      if (**strp == '-')
-	{
-	  long value;
-
-	  errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-      else
-	{
-	  unsigned long value;
-
-	  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, &value);
-	  ret = value;
-	}
-    }
-
-  *valuep = ((ret & 0xffff) ^ 0x8000) - 0x8000;
-  return errmsg;
-}
-
-/* -- */
-
-const char * openrisc_cgen_parse_operand
-  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
-
-/* Main entry point for operand parsing.
-
-   This function is basically just a big switch statement.  Earlier versions
-   used tables to look up the function to use, but
-   - if the table contains both assembler and disassembler functions then
-     the disassembler contains much of the assembler and vice-versa,
-   - there's a lot of inlining possibilities as things grow,
-   - using a switch statement avoids the function call overhead.
-
-   This function could be moved into `parse_insn_normal', but keeping it
-   separate makes clear the interface between `parse_insn_normal' and each of
-   the handlers.  */
-
-const char *
-openrisc_cgen_parse_operand (CGEN_CPU_DESC cd,
-			   int opindex,
-			   const char ** strp,
-			   CGEN_FIELDS * fields)
-{
-  const char * errmsg = NULL;
-  /* Used by scalar operands that still need to be parsed.  */
-  long junk ATTRIBUTE_UNUSED;
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      {
-        bfd_vma value = 0;
-        errmsg = cgen_parse_address (cd, strp, OPENRISC_OPERAND_ABS_26, 0, NULL,  & value);
-        fields->f_abs26 = value;
-      }
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      {
-        bfd_vma value = 0;
-        errmsg = cgen_parse_address (cd, strp, OPENRISC_OPERAND_DISP_26, 0, NULL,  & value);
-        fields->f_disp26 = value;
-      }
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      errmsg = parse_hi16 (cd, strp, OPENRISC_OPERAND_HI16, (long *) (& fields->f_simm16));
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      errmsg = parse_lo16 (cd, strp, OPENRISC_OPERAND_LO16, (long *) (& fields->f_lo16));
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, OPENRISC_OPERAND_OP_F_23, (unsigned long *) (& fields->f_op4));
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, OPENRISC_OPERAND_OP_F_3, (unsigned long *) (& fields->f_op5));
-      break;
-    case OPENRISC_OPERAND_RA :
-      errmsg = cgen_parse_keyword (cd, strp, & openrisc_cgen_opval_h_gr, & fields->f_r2);
-      break;
-    case OPENRISC_OPERAND_RB :
-      errmsg = cgen_parse_keyword (cd, strp, & openrisc_cgen_opval_h_gr, & fields->f_r3);
-      break;
-    case OPENRISC_OPERAND_RD :
-      errmsg = cgen_parse_keyword (cd, strp, & openrisc_cgen_opval_h_gr, & fields->f_r1);
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      errmsg = cgen_parse_signed_integer (cd, strp, OPENRISC_OPERAND_SIMM_16, (long *) (& fields->f_simm16));
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      errmsg = parse_lo16 (cd, strp, OPENRISC_OPERAND_UI16NC, (long *) (& fields->f_i16nc));
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, OPENRISC_OPERAND_UIMM_16, (unsigned long *) (& fields->f_uimm16));
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      errmsg = cgen_parse_unsigned_integer (cd, strp, OPENRISC_OPERAND_UIMM_5, (unsigned long *) (& fields->f_uimm5));
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while parsing.\n"), opindex);
-      abort ();
-  }
-
-  return errmsg;
-}
-
-cgen_parse_fn * const openrisc_cgen_parse_handlers[] = 
-{
-  parse_insn_normal,
-};
-
-void
-openrisc_cgen_init_asm (CGEN_CPU_DESC cd)
-{
-  openrisc_cgen_init_opcode_table (cd);
-  openrisc_cgen_init_ibld_table (cd);
-  cd->parse_handlers = & openrisc_cgen_parse_handlers[0];
-  cd->parse_operand = openrisc_cgen_parse_operand;
-#ifdef CGEN_ASM_INIT_HOOK
-CGEN_ASM_INIT_HOOK
-#endif
-}
-
-
-
-/* Regex construction routine.
-
-   This translates an opcode syntax string into a regex string,
-   by replacing any non-character syntax element (such as an
-   opcode) with the pattern '.*'
-
-   It then compiles the regex and stores it in the opcode, for
-   later use by openrisc_cgen_assemble_insn
-
-   Returns NULL for success, an error message for failure.  */
-
-char * 
-openrisc_cgen_build_insn_regex (CGEN_INSN *insn)
-{  
-  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
-  const char *mnem = CGEN_INSN_MNEMONIC (insn);
-  char rxbuf[CGEN_MAX_RX_ELEMENTS];
-  char *rx = rxbuf;
-  const CGEN_SYNTAX_CHAR_TYPE *syn;
-  int reg_err;
-
-  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));
-
-  /* Mnemonics come first in the syntax string.  */
-  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
-    return _("missing mnemonic in syntax string");
-  ++syn;
-
-  /* Generate a case sensitive regular expression that emulates case
-     insensitive matching in the "C" locale.  We cannot generate a case
-     insensitive regular expression because in Turkish locales, 'i' and 'I'
-     are not equal modulo case conversion.  */
-
-  /* Copy the literal mnemonic out of the insn.  */
-  for (; *mnem; mnem++)
-    {
-      char c = *mnem;
-
-      if (ISALPHA (c))
-	{
-	  *rx++ = '[';
-	  *rx++ = TOLOWER (c);
-	  *rx++ = TOUPPER (c);
-	  *rx++ = ']';
-	}
-      else
-	*rx++ = c;
-    }
-
-  /* Copy any remaining literals from the syntax string into the rx.  */
-  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
-    {
-      if (CGEN_SYNTAX_CHAR_P (* syn)) 
-	{
-	  char c = CGEN_SYNTAX_CHAR (* syn);
-
-	  switch (c) 
-	    {
-	      /* Escape any regex metacharacters in the syntax.  */
-	    case '.': case '[': case '\\': 
-	    case '*': case '^': case '$': 
-
-#ifdef CGEN_ESCAPE_EXTENDED_REGEX
-	    case '?': case '{': case '}': 
-	    case '(': case ')': case '*':
-	    case '|': case '+': case ']':
-#endif
-	      *rx++ = '\\';
-	      *rx++ = c;
-	      break;
-
-	    default:
-	      if (ISALPHA (c))
-		{
-		  *rx++ = '[';
-		  *rx++ = TOLOWER (c);
-		  *rx++ = TOUPPER (c);
-		  *rx++ = ']';
-		}
-	      else
-		*rx++ = c;
-	      break;
-	    }
-	}
-      else
-	{
-	  /* Replace non-syntax fields with globs.  */
-	  *rx++ = '.';
-	  *rx++ = '*';
-	}
-    }
-
-  /* Trailing whitespace ok.  */
-  * rx++ = '['; 
-  * rx++ = ' '; 
-  * rx++ = '\t'; 
-  * rx++ = ']'; 
-  * rx++ = '*'; 
-
-  /* But anchor it after that.  */
-  * rx++ = '$'; 
-  * rx = '\0';
-
-  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
-  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
-
-  if (reg_err == 0) 
-    return NULL;
-  else
-    {
-      static char msg[80];
-
-      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);
-      regfree ((regex_t *) CGEN_INSN_RX (insn));
-      free (CGEN_INSN_RX (insn));
-      (CGEN_INSN_RX (insn)) = NULL;
-      return msg;
-    }
-}
-
-
-/* Default insn parser.
-
-   The syntax string is scanned and operands are parsed and stored in FIELDS.
-   Relocs are queued as we go via other callbacks.
-
-   ??? Note that this is currently an all-or-nothing parser.  If we fail to
-   parse the instruction, we return 0 and the caller will start over from
-   the beginning.  Backtracking will be necessary in parsing subexpressions,
-   but that can be handled there.  Not handling backtracking here may get
-   expensive in the case of the m68k.  Deal with later.
-
-   Returns NULL for success, an error message for failure.  */
-
-static const char *
-parse_insn_normal (CGEN_CPU_DESC cd,
-		   const CGEN_INSN *insn,
-		   const char **strp,
-		   CGEN_FIELDS *fields)
-{
-  /* ??? Runtime added insns not handled yet.  */
-  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  const char *str = *strp;
-  const char *errmsg;
-  const char *p;
-  const CGEN_SYNTAX_CHAR_TYPE * syn;
-#ifdef CGEN_MNEMONIC_OPERANDS
-  /* FIXME: wip */
-  int past_opcode_p;
-#endif
-
-  /* For now we assume the mnemonic is first (there are no leading operands).
-     We can parse it without needing to set up operand parsing.
-     GAS's input scrubber will ensure mnemonics are lowercase, but we may
-     not be called from GAS.  */
-  p = CGEN_INSN_MNEMONIC (insn);
-  while (*p && TOLOWER (*p) == TOLOWER (*str))
-    ++p, ++str;
-
-  if (* p)
-    return _("unrecognized instruction");
-
-#ifndef CGEN_MNEMONIC_OPERANDS
-  if (* str && ! ISSPACE (* str))
-    return _("unrecognized instruction");
-#endif
-
-  CGEN_INIT_PARSE (cd);
-  cgen_init_parse_operand (cd);
-#ifdef CGEN_MNEMONIC_OPERANDS
-  past_opcode_p = 0;
-#endif
-
-  /* We don't check for (*str != '\0') here because we want to parse
-     any trailing fake arguments in the syntax string.  */
-  syn = CGEN_SYNTAX_STRING (syntax);
-
-  /* Mnemonics come first for now, ensure valid string.  */
-  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
-    abort ();
-
-  ++syn;
-
-  while (* syn != 0)
-    {
-      /* Non operand chars must match exactly.  */
-      if (CGEN_SYNTAX_CHAR_P (* syn))
-	{
-	  /* FIXME: While we allow for non-GAS callers above, we assume the
-	     first char after the mnemonic part is a space.  */
-	  /* FIXME: We also take inappropriate advantage of the fact that
-	     GAS's input scrubber will remove extraneous blanks.  */
-	  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))
-	    {
-#ifdef CGEN_MNEMONIC_OPERANDS
-	      if (CGEN_SYNTAX_CHAR(* syn) == ' ')
-		past_opcode_p = 1;
-#endif
-	      ++ syn;
-	      ++ str;
-	    }
-	  else if (*str)
-	    {
-	      /* Syntax char didn't match.  Can't be this insn.  */
-	      static char msg [80];
-
-	      /* xgettext:c-format */
-	      sprintf (msg, _("syntax error (expected char `%c', found `%c')"),
-		       CGEN_SYNTAX_CHAR(*syn), *str);
-	      return msg;
-	    }
-	  else
-	    {
-	      /* Ran out of input.  */
-	      static char msg [80];
-
-	      /* xgettext:c-format */
-	      sprintf (msg, _("syntax error (expected char `%c', found end of instruction)"),
-		       CGEN_SYNTAX_CHAR(*syn));
-	      return msg;
-	    }
-	  continue;
-	}
-
-#ifdef CGEN_MNEMONIC_OPERANDS
-      (void) past_opcode_p;
-#endif
-      /* We have an operand of some sort.  */
-      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn), &str, fields);
-      if (errmsg)
-	return errmsg;
-
-      /* Done with this operand, continue with next one.  */
-      ++ syn;
-    }
-
-  /* If we're at the end of the syntax string, we're done.  */
-  if (* syn == 0)
-    {
-      /* FIXME: For the moment we assume a valid `str' can only contain
-	 blanks now.  IE: We needn't try again with a longer version of
-	 the insn and it is assumed that longer versions of insns appear
-	 before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
-      while (ISSPACE (* str))
-	++ str;
-
-      if (* str != '\0')
-	return _("junk at end of line"); /* FIXME: would like to include `str' */
-
-      return NULL;
-    }
-
-  /* We couldn't parse it.  */
-  return _("unrecognized instruction");
-}
-
-/* Main entry point.
-   This routine is called for each instruction to be assembled.
-   STR points to the insn to be assembled.
-   We assume all necessary tables have been initialized.
-   The assembled instruction, less any fixups, is stored in BUF.
-   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value
-   still needs to be converted to target byte order, otherwise BUF is an array
-   of bytes in target byte order.
-   The result is a pointer to the insn's entry in the opcode table,
-   or NULL if an error occured (an error message will have already been
-   printed).
-
-   Note that when processing (non-alias) macro-insns,
-   this function recurses.
-
-   ??? It's possible to make this cpu-independent.
-   One would have to deal with a few minor things.
-   At this point in time doing so would be more of a curiosity than useful
-   [for example this file isn't _that_ big], but keeping the possibility in
-   mind helps keep the design clean.  */
-
-const CGEN_INSN *
-openrisc_cgen_assemble_insn (CGEN_CPU_DESC cd,
-			   const char *str,
-			   CGEN_FIELDS *fields,
-			   CGEN_INSN_BYTES_PTR buf,
-			   char **errmsg)
-{
-  const char *start;
-  CGEN_INSN_LIST *ilist;
-  const char *parse_errmsg = NULL;
-  const char *insert_errmsg = NULL;
-  int recognized_mnemonic = 0;
-
-  /* Skip leading white space.  */
-  while (ISSPACE (* str))
-    ++ str;
-
-  /* The instructions are stored in hashed lists.
-     Get the first in the list.  */
-  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);
-
-  /* Keep looking until we find a match.  */
-  start = str;
-  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))
-    {
-      const CGEN_INSN *insn = ilist->insn;
-      recognized_mnemonic = 1;
-
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
-      /* Not usually needed as unsupported opcodes
-	 shouldn't be in the hash lists.  */
-      /* Is this insn supported by the selected cpu?  */
-      if (! openrisc_cgen_insn_supported (cd, insn))
-	continue;
-#endif
-      /* If the RELAXED attribute is set, this is an insn that shouldn't be
-	 chosen immediately.  Instead, it is used during assembler/linker
-	 relaxation if possible.  */
-      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)
-	continue;
-
-      str = start;
-
-      /* Skip this insn if str doesn't look right lexically.  */
-      if (CGEN_INSN_RX (insn) != NULL &&
-	  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)
-	continue;
-
-      /* Allow parse/insert handlers to obtain length of insn.  */
-      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
-
-      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);
-      if (parse_errmsg != NULL)
-	continue;
-
-      /* ??? 0 is passed for `pc'.  */
-      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,
-						 (bfd_vma) 0);
-      if (insert_errmsg != NULL)
-        continue;
-
-      /* It is up to the caller to actually output the insn and any
-         queued relocs.  */
-      return insn;
-    }
-
-  {
-    static char errbuf[150];
-    const char *tmp_errmsg;
-#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS
-#define be_verbose 1
-#else
-#define be_verbose 0
-#endif
-
-    if (be_verbose)
-      {
-	/* If requesting verbose error messages, use insert_errmsg.
-	   Failing that, use parse_errmsg.  */
-	tmp_errmsg = (insert_errmsg ? insert_errmsg :
-		      parse_errmsg ? parse_errmsg :
-		      recognized_mnemonic ?
-		      _("unrecognized form of instruction") :
-		      _("unrecognized instruction"));
-
-	if (strlen (start) > 50)
-	  /* xgettext:c-format */
-	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
-	else 
-	  /* xgettext:c-format */
-	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
-      }
-    else
-      {
-	if (strlen (start) > 50)
-	  /* xgettext:c-format */
-	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
-	else 
-	  /* xgettext:c-format */
-	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
-      }
-      
-    *errmsg = errbuf;
-    return NULL;
-  }
-}
--- a/opcodes/openrisc-desc.c
+++ /dev/null
@@ -1,1018 +0,0 @@
-/* CPU data for openrisc.
-
-THIS FILE IS MACHINE GENERATED WITH CGEN.
-
-Copyright 1996-2010 Free Software Foundation, Inc.
-
-This file is part of the GNU Binutils and/or GDB, the GNU debugger.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
-
-*/
-
-#include "sysdep.h"
-#include <stdio.h>
-#include <stdarg.h>
-#include "ansidecl.h"
-#include "bfd.h"
-#include "symcat.h"
-#include "openrisc-desc.h"
-#include "openrisc-opc.h"
-#include "opintl.h"
-#include "libiberty.h"
-#include "xregex.h"
-
-/* Attributes.  */
-
-static const CGEN_ATTR_ENTRY bool_attr[] =
-{
-  { "#f", 0 },
-  { "#t", 1 },
-  { 0, 0 }
-};
-
-static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
-{
-  { "base", MACH_BASE },
-  { "openrisc", MACH_OPENRISC },
-  { "or1300", MACH_OR1300 },
-  { "max", MACH_MAX },
-  { 0, 0 }
-};
-
-static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
-{
-  { "or32", ISA_OR32 },
-  { "max", ISA_MAX },
-  { 0, 0 }
-};
-
-static const CGEN_ATTR_ENTRY HAS_CACHE_attr[] ATTRIBUTE_UNUSED =
-{
-  { "DATA_CACHE", HAS_CACHE_DATA_CACHE },
-  { "INSN_CACHE", HAS_CACHE_INSN_CACHE },
-  { 0, 0 }
-};
-
-const CGEN_ATTR_TABLE openrisc_cgen_ifield_attr_table[] =
-{
-  { "MACH", & MACH_attr[0], & MACH_attr[0] },
-  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
-  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
-  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
-  { "RESERVED", &bool_attr[0], &bool_attr[0] },
-  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
-  { "SIGNED", &bool_attr[0], &bool_attr[0] },
-  { 0, 0, 0 }
-};
-
-const CGEN_ATTR_TABLE openrisc_cgen_hardware_attr_table[] =
-{
-  { "MACH", & MACH_attr[0], & MACH_attr[0] },
-  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
-  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
-  { "PC", &bool_attr[0], &bool_attr[0] },
-  { "PROFILE", &bool_attr[0], &bool_attr[0] },
-  { 0, 0, 0 }
-};
-
-const CGEN_ATTR_TABLE openrisc_cgen_operand_attr_table[] =
-{
-  { "MACH", & MACH_attr[0], & MACH_attr[0] },
-  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
-  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
-  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
-  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
-  { "SIGNED", &bool_attr[0], &bool_attr[0] },
-  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
-  { "RELAX", &bool_attr[0], &bool_attr[0] },
-  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
-  { 0, 0, 0 }
-};
-
-const CGEN_ATTR_TABLE openrisc_cgen_insn_attr_table[] =
-{
-  { "MACH", & MACH_attr[0], & MACH_attr[0] },
-  { "ALIAS", &bool_attr[0], &bool_attr[0] },
-  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
-  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
-  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
-  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
-  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
-  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
-  { "RELAXED", &bool_attr[0], &bool_attr[0] },
-  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
-  { "PBB", &bool_attr[0], &bool_attr[0] },
-  { "NOT-IN-DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
-  { 0, 0, 0 }
-};
-
-/* Instruction set variants.  */
-
-static const CGEN_ISA openrisc_cgen_isa_table[] = {
-  { "or32", 32, 32, 32, 32 },
-  { 0, 0, 0, 0, 0 }
-};
-
-/* Machine variants.  */
-
-static const CGEN_MACH openrisc_cgen_mach_table[] = {
-  { "openrisc", "openrisc", MACH_OPENRISC, 0 },
-  { "or1300", "openrisc:1300", MACH_OR1300, 0 },
-  { 0, 0, 0, 0 }
-};
-
-static CGEN_KEYWORD_ENTRY openrisc_cgen_opval_h_gr_entries[] =
-{
-  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
-  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
-  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
-  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
-  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
-  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
-  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
-  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
-  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
-  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
-  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
-  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
-  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
-  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
-  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
-  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
-  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
-  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
-  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
-  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
-  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
-  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
-  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
-  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
-  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
-  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
-  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
-  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
-  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
-  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
-  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
-  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
-  { "lr", 11, {0, {{{0, 0}}}}, 0, 0 },
-  { "sp", 1, {0, {{{0, 0}}}}, 0, 0 },
-  { "fp", 2, {0, {{{0, 0}}}}, 0, 0 }
-};
-
-CGEN_KEYWORD openrisc_cgen_opval_h_gr =
-{
-  & openrisc_cgen_opval_h_gr_entries[0],
-  35,
-  0, 0, 0, 0, ""
-};
-
-
-/* The hardware table.  */
-
-#define A(a) (1 << CGEN_HW_##a)
-
-const CGEN_HW_ENTRY openrisc_cgen_hw_table[] =
-{
-  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-gr", HW_H_GR, CGEN_ASM_KEYWORD, (PTR) & openrisc_cgen_opval_h_gr, { 0|A(PROFILE), { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-sr", HW_H_SR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-hi16", HW_H_HI16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-lo16", HW_H_LO16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-cbit", HW_H_CBIT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { "h-delay-insn", HW_H_DELAY_INSN, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
-};
-
-#undef A
-
-
-/* The instruction field table.  */
-
-#define A(a) (1 << CGEN_IFLD_##a)
-
-const CGEN_IFLD openrisc_cgen_ifld_table[] =
-{
-  { OPENRISC_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_CLASS, "f-class", 0, 32, 31, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_SUB, "f-sub", 0, 32, 29, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_R1, "f-r1", 0, 32, 25, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_R2, "f-r2", 0, 32, 20, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_R3, "f-r3", 0, 32, 15, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_SIMM16, "f-simm16", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_UIMM16, "f-uimm16", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_UIMM5, "f-uimm5", 0, 32, 4, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_HI16, "f-hi16", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_LO16, "f-lo16", 0, 32, 15, 16, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP1, "f-op1", 0, 32, 31, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP2, "f-op2", 0, 32, 29, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP3, "f-op3", 0, 32, 25, 2, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP4, "f-op4", 0, 32, 23, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP5, "f-op5", 0, 32, 25, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP6, "f-op6", 0, 32, 7, 3, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_OP7, "f-op7", 0, 32, 3, 4, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_I16_1, "f-i16-1", 0, 32, 10, 11, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_I16_2, "f-i16-2", 0, 32, 25, 5, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_DISP26, "f-disp26", 0, 32, 25, 26, { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_ABS26, "f-abs26", 0, 32, 25, 26, { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_I16NC, "f-i16nc", 0, 0, 0, 0,{ 0|A(SIGN_OPT)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_15_8, "f-f-15-8", 0, 32, 15, 8, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_10_3, "f-f-10-3", 0, 32, 10, 3, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_4_1, "f-f-4-1", 0, 32, 4, 1, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_7_3, "f-f-7-3", 0, 32, 7, 3, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_10_7, "f-f-10-7", 0, 32, 10, 7, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { OPENRISC_F_F_10_11, "f-f-10-11", 0, 32, 10, 11, { 0|A(RESERVED), { { { (1<<MACH_BASE), 0 } } } }  },
-  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
-};
-
-#undef A
-
-
-
-/* multi ifield declarations */
-
-const CGEN_MAYBE_MULTI_IFLD OPENRISC_F_I16NC_MULTI_IFIELD [];
-
-
-/* multi ifield definitions */
-
-const CGEN_MAYBE_MULTI_IFLD OPENRISC_F_I16NC_MULTI_IFIELD [] =
-{
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_I16_1] } },
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_I16_2] } },
-    { 0, { (const PTR) 0 } }
-};
-
-/* The operand table.  */
-
-#define A(a) (1 << CGEN_OPERAND_##a)
-#define OPERAND(op) OPENRISC_OPERAND_##op
-
-const CGEN_OPERAND openrisc_cgen_operand_table[] =
-{
-/* pc: program counter */
-  { "pc", OPENRISC_OPERAND_PC, HW_H_PC, 0, 0,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_NIL] } }, 
-    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
-/* sr: special register */
-  { "sr", OPENRISC_OPERAND_SR, HW_H_SR, 0, 0,
-    { 0, { (const PTR) 0 } }, 
-    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
-/* cbit: condition bit */
-  { "cbit", OPENRISC_OPERAND_CBIT, HW_H_CBIT, 0, 0,
-    { 0, { (const PTR) 0 } }, 
-    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
-/* simm-16: 16 bit signed immediate */
-  { "simm-16", OPENRISC_OPERAND_SIMM_16, HW_H_SINT, 15, 16,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_SIMM16] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* uimm-16: 16 bit unsigned immediate */
-  { "uimm-16", OPENRISC_OPERAND_UIMM_16, HW_H_UINT, 15, 16,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_UIMM16] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* disp-26: pc-rel 26 bit */
-  { "disp-26", OPENRISC_OPERAND_DISP_26, HW_H_IADDR, 25, 26,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_DISP26] } }, 
-    { 0|A(PCREL_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
-/* abs-26: abs 26 bit */
-  { "abs-26", OPENRISC_OPERAND_ABS_26, HW_H_IADDR, 25, 26,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_ABS26] } }, 
-    { 0|A(ABS_ADDR), { { { (1<<MACH_BASE), 0 } } } }  },
-/* uimm-5: imm5 */
-  { "uimm-5", OPENRISC_OPERAND_UIMM_5, HW_H_UINT, 4, 5,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_UIMM5] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* rD: destination register */
-  { "rD", OPENRISC_OPERAND_RD, HW_H_GR, 25, 5,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_R1] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* rA: source register A */
-  { "rA", OPENRISC_OPERAND_RA, HW_H_GR, 20, 5,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_R2] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* rB: source register B */
-  { "rB", OPENRISC_OPERAND_RB, HW_H_GR, 15, 5,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_R3] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* op-f-23: f-op23 */
-  { "op-f-23", OPENRISC_OPERAND_OP_F_23, HW_H_UINT, 23, 3,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_OP4] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* op-f-3: f-op3 */
-  { "op-f-3", OPENRISC_OPERAND_OP_F_3, HW_H_UINT, 25, 5,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_OP5] } }, 
-    { 0, { { { (1<<MACH_BASE), 0 } } } }  },
-/* hi16: high 16 bit immediate, sign optional */
-  { "hi16", OPENRISC_OPERAND_HI16, HW_H_HI16, 15, 16,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_SIMM16] } }, 
-    { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
-/* lo16: low 16 bit immediate, sign optional */
-  { "lo16", OPENRISC_OPERAND_LO16, HW_H_LO16, 15, 16,
-    { 0, { (const PTR) &openrisc_cgen_ifld_table[OPENRISC_F_LO16] } }, 
-    { 0|A(SIGN_OPT), { { { (1<<MACH_BASE), 0 } } } }  },
-/* ui16nc: 16 bit immediate, sign optional */
-  { "ui16nc", OPENRISC_OPERAND_UI16NC, HW_H_LO16, 10, 16,
-    { 2, { (const PTR) &OPENRISC_F_I16NC_MULTI_IFIELD[0] } }, 
-    { 0|A(SIGN_OPT)|A(VIRTUAL), { { { (1<<MACH_BASE), 0 } } } }  },
-/* sentinel */
-  { 0, 0, 0, 0, 0,
-    { 0, { (const PTR) 0 } },
-    { 0, { { { (1<<MACH_BASE), 0 } } } } }
-};
-
-#undef A
-
-
-/* The instruction table.  */
-
-#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
-#define A(a) (1 << CGEN_INSN_##a)
-
-static const CGEN_IBASE openrisc_cgen_insn_table[MAX_INSNS] =
-{
-  /* Special null first entry.
-     A `num' value of zero is thus invalid.
-     Also, the special `invalid' insn resides here.  */
-  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
-/* l.j ${abs-26} */
-  {
-    OPENRISC_INSN_L_J, "l-j", "l.j", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.jal ${abs-26} */
-  {
-    OPENRISC_INSN_L_JAL, "l-jal", "l.jal", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.jr $rA */
-  {
-    OPENRISC_INSN_L_JR, "l-jr", "l.jr", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.jalr $rA */
-  {
-    OPENRISC_INSN_L_JALR, "l-jalr", "l.jalr", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.bal ${disp-26} */
-  {
-    OPENRISC_INSN_L_BAL, "l-bal", "l.bal", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.bnf ${disp-26} */
-  {
-    OPENRISC_INSN_L_BNF, "l-bnf", "l.bnf", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.bf ${disp-26} */
-  {
-    OPENRISC_INSN_L_BF, "l-bf", "l.bf", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(COND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.brk ${uimm-16} */
-  {
-    OPENRISC_INSN_L_BRK, "l-brk", "l.brk", 32,
-    { 0|A(NOT_IN_DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.rfe $rA */
-  {
-    OPENRISC_INSN_L_RFE, "l-rfe", "l.rfe", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sys ${uimm-16} */
-  {
-    OPENRISC_INSN_L_SYS, "l-sys", "l.sys", 32,
-    { 0|A(NOT_IN_DELAY_SLOT)|A(UNCOND_CTI)|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.nop */
-  {
-    OPENRISC_INSN_L_NOP, "l-nop", "l.nop", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.movhi $rD,$hi16 */
-  {
-    OPENRISC_INSN_L_MOVHI, "l-movhi", "l.movhi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.mfsr $rD,$rA */
-  {
-    OPENRISC_INSN_L_MFSR, "l-mfsr", "l.mfsr", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.mtsr $rA,$rB */
-  {
-    OPENRISC_INSN_L_MTSR, "l-mtsr", "l.mtsr", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.lw $rD,${simm-16}($rA) */
-  {
-    OPENRISC_INSN_L_LW, "l-lw", "l.lw", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.lbz $rD,${simm-16}($rA) */
-  {
-    OPENRISC_INSN_L_LBZ, "l-lbz", "l.lbz", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.lbs $rD,${simm-16}($rA) */
-  {
-    OPENRISC_INSN_L_LBS, "l-lbs", "l.lbs", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.lhz $rD,${simm-16}($rA) */
-  {
-    OPENRISC_INSN_L_LHZ, "l-lhz", "l.lhz", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.lhs $rD,${simm-16}($rA) */
-  {
-    OPENRISC_INSN_L_LHS, "l-lhs", "l.lhs", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sw ${ui16nc}($rA),$rB */
-  {
-    OPENRISC_INSN_L_SW, "l-sw", "l.sw", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sb ${ui16nc}($rA),$rB */
-  {
-    OPENRISC_INSN_L_SB, "l-sb", "l.sb", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sh ${ui16nc}($rA),$rB */
-  {
-    OPENRISC_INSN_L_SH, "l-sh", "l.sh", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sll $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_SLL, "l-sll", "l.sll", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.slli $rD,$rA,${uimm-5} */
-  {
-    OPENRISC_INSN_L_SLLI, "l-slli", "l.slli", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.srl $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_SRL, "l-srl", "l.srl", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.srli $rD,$rA,${uimm-5} */
-  {
-    OPENRISC_INSN_L_SRLI, "l-srli", "l.srli", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sra $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_SRA, "l-sra", "l.sra", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.srai $rD,$rA,${uimm-5} */
-  {
-    OPENRISC_INSN_L_SRAI, "l-srai", "l.srai", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.ror $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_ROR, "l-ror", "l.ror", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.rori $rD,$rA,${uimm-5} */
-  {
-    OPENRISC_INSN_L_RORI, "l-rori", "l.rori", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.add $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_ADD, "l-add", "l.add", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.addi $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_ADDI, "l-addi", "l.addi", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sub $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_SUB, "l-sub", "l.sub", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.subi $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_SUBI, "l-subi", "l.subi", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.and $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_AND, "l-and", "l.and", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.andi $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_ANDI, "l-andi", "l.andi", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.or $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_OR, "l-or", "l.or", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.ori $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_ORI, "l-ori", "l.ori", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.xor $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_XOR, "l-xor", "l.xor", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.xori $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_XORI, "l-xori", "l.xori", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.mul $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_MUL, "l-mul", "l.mul", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.muli $rD,$rA,$lo16 */
-  {
-    OPENRISC_INSN_L_MULI, "l-muli", "l.muli", 32,
-    { 0, { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.div $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_DIV, "l-div", "l.div", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.divu $rD,$rA,$rB */
-  {
-    OPENRISC_INSN_L_DIVU, "l-divu", "l.divu", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgts $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFGTS, "l-sfgts", "l.sfgts", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgtu $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFGTU, "l-sfgtu", "l.sfgtu", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfges $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFGES, "l-sfges", "l.sfges", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgeu $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFGEU, "l-sfgeu", "l.sfgeu", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sflts $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFLTS, "l-sflts", "l.sflts", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfltu $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFLTU, "l-sfltu", "l.sfltu", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfles $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFLES, "l-sfles", "l.sfles", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfleu $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFLEU, "l-sfleu", "l.sfleu", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgtsi $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFGTSI, "l-sfgtsi", "l.sfgtsi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgtui $rA,${uimm-16} */
-  {
-    OPENRISC_INSN_L_SFGTUI, "l-sfgtui", "l.sfgtui", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgesi $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFGESI, "l-sfgesi", "l.sfgesi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfgeui $rA,${uimm-16} */
-  {
-    OPENRISC_INSN_L_SFGEUI, "l-sfgeui", "l.sfgeui", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfltsi $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFLTSI, "l-sfltsi", "l.sfltsi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfltui $rA,${uimm-16} */
-  {
-    OPENRISC_INSN_L_SFLTUI, "l-sfltui", "l.sfltui", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sflesi $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFLESI, "l-sflesi", "l.sflesi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfleui $rA,${uimm-16} */
-  {
-    OPENRISC_INSN_L_SFLEUI, "l-sfleui", "l.sfleui", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfeq $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFEQ, "l-sfeq", "l.sfeq", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfeqi $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFEQI, "l-sfeqi", "l.sfeqi", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfne $rA,$rB */
-  {
-    OPENRISC_INSN_L_SFNE, "l-sfne", "l.sfne", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-/* l.sfnei $rA,${simm-16} */
-  {
-    OPENRISC_INSN_L_SFNEI, "l-sfnei", "l.sfnei", 32,
-    { 0|A(DELAY_SLOT), { { { (1<<MACH_BASE), 0 } } } }
-  },
-};
-
-#undef OP
-#undef A
-
-/* Initialize anything needed to be done once, before any cpu_open call.  */
-
-static void
-init_tables (void)
-{
-}
-
-static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
-static void build_hw_table      (CGEN_CPU_TABLE *);
-static void build_ifield_table  (CGEN_CPU_TABLE *);
-static void build_operand_table (CGEN_CPU_TABLE *);
-static void build_insn_table    (CGEN_CPU_TABLE *);
-static void openrisc_cgen_rebuild_tables (CGEN_CPU_TABLE *);
-
-/* Subroutine of openrisc_cgen_cpu_open to look up a mach via its bfd name.  */
-
-static const CGEN_MACH *
-lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
-{
-  while (table->name)
-    {
-      if (strcmp (name, table->bfd_name) == 0)
-	return table;
-      ++table;
-    }
-  abort ();
-}
-
-/* Subroutine of openrisc_cgen_cpu_open to build the hardware table.  */
-
-static void
-build_hw_table (CGEN_CPU_TABLE *cd)
-{
-  int i;
-  int machs = cd->machs;
-  const CGEN_HW_ENTRY *init = & openrisc_cgen_hw_table[0];
-  /* MAX_HW is only an upper bound on the number of selected entries.
-     However each entry is indexed by it's enum so there can be holes in
-     the table.  */
-  const CGEN_HW_ENTRY **selected =
-    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));
-
-  cd->hw_table.init_entries = init;
-  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
-  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
-  /* ??? For now we just use machs to determine which ones we want.  */
-  for (i = 0; init[i].name != NULL; ++i)
-    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
-	& machs)
-      selected[init[i].type] = &init[i];
-  cd->hw_table.entries = selected;
-  cd->hw_table.num_entries = MAX_HW;
-}
-
-/* Subroutine of openrisc_cgen_cpu_open to build the hardware table.  */
-
-static void
-build_ifield_table (CGEN_CPU_TABLE *cd)
-{
-  cd->ifld_table = & openrisc_cgen_ifld_table[0];
-}
-
-/* Subroutine of openrisc_cgen_cpu_open to build the hardware table.  */
-
-static void
-build_operand_table (CGEN_CPU_TABLE *cd)
-{
-  int i;
-  int machs = cd->machs;
-  const CGEN_OPERAND *init = & openrisc_cgen_operand_table[0];
-  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
-     However each entry is indexed by it's enum so there can be holes in
-     the table.  */
-  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));
-
-  cd->operand_table.init_entries = init;
-  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
-  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
-  /* ??? For now we just use mach to determine which ones we want.  */
-  for (i = 0; init[i].name != NULL; ++i)
-    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
-	& machs)
-      selected[init[i].type] = &init[i];
-  cd->operand_table.entries = selected;
-  cd->operand_table.num_entries = MAX_OPERANDS;
-}
-
-/* Subroutine of openrisc_cgen_cpu_open to build the hardware table.
-   ??? This could leave out insns not supported by the specified mach/isa,
-   but that would cause errors like "foo only supported by bar" to become
-   "unknown insn", so for now we include all insns and require the app to
-   do the checking later.
-   ??? On the other hand, parsing of such insns may require their hardware or
-   operand elements to be in the table [which they mightn't be].  */
-
-static void
-build_insn_table (CGEN_CPU_TABLE *cd)
-{
-  int i;
-  const CGEN_IBASE *ib = & openrisc_cgen_insn_table[0];
-  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
-
-  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
-  for (i = 0; i < MAX_INSNS; ++i)
-    insns[i].base = &ib[i];
-  cd->insn_table.init_entries = insns;
-  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
-  cd->insn_table.num_init_entries = MAX_INSNS;
-}
-
-/* Subroutine of openrisc_cgen_cpu_open to rebuild the tables.  */
-
-static void
-openrisc_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
-{
-  int i;
-  CGEN_BITSET *isas = cd->isas;
-  unsigned int machs = cd->machs;
-
-  cd->int_insn_p = CGEN_INT_INSN_P;
-
-  /* Data derived from the isa spec.  */
-#define UNSET (CGEN_SIZE_UNKNOWN + 1)
-  cd->default_insn_bitsize = UNSET;
-  cd->base_insn_bitsize = UNSET;
-  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
-  cd->max_insn_bitsize = 0;
-  for (i = 0; i < MAX_ISAS; ++i)
-    if (cgen_bitset_contains (isas, i))
-      {
-	const CGEN_ISA *isa = & openrisc_cgen_isa_table[i];
-
-	/* Default insn sizes of all selected isas must be
-	   equal or we set the result to 0, meaning "unknown".  */
-	if (cd->default_insn_bitsize == UNSET)
-	  cd->default_insn_bitsize = isa->default_insn_bitsize;
-	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
-	  ; /* This is ok.  */
-	else
-	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;
-
-	/* Base insn sizes of all selected isas must be equal
-	   or we set the result to 0, meaning "unknown".  */
-	if (cd->base_insn_bitsize == UNSET)
-	  cd->base_insn_bitsize = isa->base_insn_bitsize;
-	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
-	  ; /* This is ok.  */
-	else
-	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
-
-	/* Set min,max insn sizes.  */
-	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
-	  cd->min_insn_bitsize = isa->min_insn_bitsize;
-	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
-	  cd->max_insn_bitsize = isa->max_insn_bitsize;
-      }
-
-  /* Data derived from the mach spec.  */
-  for (i = 0; i < MAX_MACHS; ++i)
-    if (((1 << i) & machs) != 0)
-      {
-	const CGEN_MACH *mach = & openrisc_cgen_mach_table[i];
-
-	if (mach->insn_chunk_bitsize != 0)
-	{
-	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
-	    {
-	      fprintf (stderr, "openrisc_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
-		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
-	      abort ();
-	    }
-
- 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
-	}
-      }
-
-  /* Determine which hw elements are used by MACH.  */
-  build_hw_table (cd);
-
-  /* Build the ifield table.  */
-  build_ifield_table (cd);
-
-  /* Determine which operands are used by MACH/ISA.  */
-  build_operand_table (cd);
-
-  /* Build the instruction table.  */
-  build_insn_table (cd);
-}
-
-/* Initialize a cpu table and return a descriptor.
-   It's much like opening a file, and must be the first function called.
-   The arguments are a set of (type/value) pairs, terminated with
-   CGEN_CPU_OPEN_END.
-
-   Currently supported values:
-   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
-   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
-   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
-   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
-   CGEN_CPU_OPEN_END:     terminates arguments
-
-   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
-   precluded.  */
-
-CGEN_CPU_DESC
-openrisc_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
-{
-  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
-  static int init_p;
-  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
-  unsigned int machs = 0; /* 0 = "unspecified" */
-  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
-  va_list ap;
-
-  if (! init_p)
-    {
-      init_tables ();
-      init_p = 1;
-    }
-
-  memset (cd, 0, sizeof (*cd));
-
-  va_start (ap, arg_type);
-  while (arg_type != CGEN_CPU_OPEN_END)
-    {
-      switch (arg_type)
-	{
-	case CGEN_CPU_OPEN_ISAS :
-	  isas = va_arg (ap, CGEN_BITSET *);
-	  break;
-	case CGEN_CPU_OPEN_MACHS :
-	  machs = va_arg (ap, unsigned int);
-	  break;
-	case CGEN_CPU_OPEN_BFDMACH :
-	  {
-	    const char *name = va_arg (ap, const char *);
-	    const CGEN_MACH *mach =
-	      lookup_mach_via_bfd_name (openrisc_cgen_mach_table, name);
-
-	    machs |= 1 << mach->num;
-	    break;
-	  }
-	case CGEN_CPU_OPEN_ENDIAN :
-	  endian = va_arg (ap, enum cgen_endian);
-	  break;
-	default :
-	  fprintf (stderr, "openrisc_cgen_cpu_open: unsupported argument `%d'\n",
-		   arg_type);
-	  abort (); /* ??? return NULL? */
-	}
-      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
-    }
-  va_end (ap);
-
-  /* Mach unspecified means "all".  */
-  if (machs == 0)
-    machs = (1 << MAX_MACHS) - 1;
-  /* Base mach is always selected.  */
-  machs |= 1;
-  if (endian == CGEN_ENDIAN_UNKNOWN)
-    {
-      /* ??? If target has only one, could have a default.  */
-      fprintf (stderr, "openrisc_cgen_cpu_open: no endianness specified\n");
-      abort ();
-    }
-
-  cd->isas = cgen_bitset_copy (isas);
-  cd->machs = machs;
-  cd->endian = endian;
-  /* FIXME: for the sparc case we can determine insn-endianness statically.
-     The worry here is where both data and insn endian can be independently
-     chosen, in which case this function will need another argument.
-     Actually, will want to allow for more arguments in the future anyway.  */
-  cd->insn_endian = endian;
-
-  /* Table (re)builder.  */
-  cd->rebuild_tables = openrisc_cgen_rebuild_tables;
-  openrisc_cgen_rebuild_tables (cd);
-
-  /* Default to not allowing signed overflow.  */
-  cd->signed_overflow_ok_p = 0;
-  
-  return (CGEN_CPU_DESC) cd;
-}
-
-/* Cover fn to openrisc_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
-   MACH_NAME is the bfd name of the mach.  */
-
-CGEN_CPU_DESC
-openrisc_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
-{
-  return openrisc_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
-			       CGEN_CPU_OPEN_ENDIAN, endian,
-			       CGEN_CPU_OPEN_END);
-}
-
-/* Close a cpu table.
-   ??? This can live in a machine independent file, but there's currently
-   no place to put this file (there's no libcgen).  libopcodes is the wrong
-   place as some simulator ports use this but they don't use libopcodes.  */
-
-void
-openrisc_cgen_cpu_close (CGEN_CPU_DESC cd)
-{
-  unsigned int i;
-  const CGEN_INSN *insns;
-
-  if (cd->macro_insn_table.init_entries)
-    {
-      insns = cd->macro_insn_table.init_entries;
-      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
-	if (CGEN_INSN_RX ((insns)))
-	  regfree (CGEN_INSN_RX (insns));
-    }
-
-  if (cd->insn_table.init_entries)
-    {
-      insns = cd->insn_table.init_entries;
-      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
-	if (CGEN_INSN_RX (insns))
-	  regfree (CGEN_INSN_RX (insns));
-    }  
-
-  if (cd->macro_insn_table.init_entries)
-    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
-
-  if (cd->insn_table.init_entries)
-    free ((CGEN_INSN *) cd->insn_table.init_entries);
-
-  if (cd->hw_table.entries)
-    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);
-
-  if (cd->operand_table.entries)
-    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);
-
-  free (cd);
-}
-
--- a/opcodes/openrisc-desc.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/* CPU data header for openrisc.
-
-THIS FILE IS MACHINE GENERATED WITH CGEN.
-
-Copyright 1996-2010 Free Software Foundation, Inc.
-
-This file is part of the GNU Binutils and/or GDB, the GNU debugger.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef OPENRISC_CPU_H
-#define OPENRISC_CPU_H
-
-#define CGEN_ARCH openrisc
-
-/* Given symbol S, return openrisc_cgen_<S>.  */
-#define CGEN_SYM(s) openrisc##_cgen_##s
-
-
-/* Selected cpu families.  */
-#define HAVE_CPU_OPENRISCBF
-
-#define CGEN_INSN_LSB0_P 1
-
-/* Minimum size of any insn (in bytes).  */
-#define CGEN_MIN_INSN_SIZE 4
-
-/* Maximum size of any insn (in bytes).  */
-#define CGEN_MAX_INSN_SIZE 4
-
-#define CGEN_INT_INSN_P 1
-
-/* Maximum number of syntax elements in an instruction.  */
-#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 14
-
-/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.
-   e.g. In "b,a foo" the ",a" is an operand.  If mnemonics have operands
-   we can't hash on everything up to the space.  */
-#define CGEN_MNEMONIC_OPERANDS
-
-/* Maximum number of fields in an instruction.  */
-#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 9
-
-/* Enums.  */
-
-/* Enum declaration for exception vectors.  */
-typedef enum e_exception {
-  E_RESET, E_BUSERR, E_DPF, E_IPF
- , E_EXTINT, E_ALIGN, E_ILLEGAL, E_PEINT
- , E_DTLBMISS, E_ITLBMISS, E_RRANGE, E_SYSCALL
- , E_BREAK, E_RESERVED
-} E_EXCEPTION;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_class {
-  OP1_0, OP1_1, OP1_2, OP1_3
-} INSN_CLASS;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_sub {
-  OP2_0, OP2_1, OP2_2, OP2_3
- , OP2_4, OP2_5, OP2_6, OP2_7
- , OP2_8, OP2_9, OP2_10, OP2_11
- , OP2_12, OP2_13, OP2_14, OP2_15
-} INSN_SUB;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_op3 {
-  OP3_0, OP3_1, OP3_2, OP3_3
-} INSN_OP3;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_op4 {
-  OP4_0, OP4_1, OP4_2, OP4_3
- , OP4_4, OP4_5, OP4_6, OP4_7
-} INSN_OP4;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_op5 {
-  OP5_0, OP5_1, OP5_2, OP5_3
- , OP5_4, OP5_5, OP5_6, OP5_7
- , OP5_8, OP5_9, OP5_10, OP5_11
- , OP5_12, OP5_13, OP5_14, OP5_15
- , OP5_16, OP5_17, OP5_18, OP5_19
- , OP5_20, OP5_21, OP5_22, OP5_23
- , OP5_24, OP5_25, OP5_26, OP5_27
- , OP5_28, OP5_29, OP5_30, OP5_31
-} INSN_OP5;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_op6 {
-  OP6_0, OP6_1, OP6_2, OP6_3
- , OP6_4, OP6_5, OP6_6, OP6_7
-} INSN_OP6;
-
-/* Enum declaration for FIXME.  */
-typedef enum insn_op7 {
-  OP7_0, OP7_1, OP7_2, OP7_3
- , OP7_4, OP7_5, OP7_6, OP7_7
- , OP7_8, OP7_9, OP7_10, OP7_11
- , OP7_12, OP7_13, OP7_14, OP7_15
-} INSN_OP7;
-
-/* Attributes.  */
-
-/* Enum declaration for machine type selection.  */
-typedef enum mach_attr {
-  MACH_BASE, MACH_OPENRISC, MACH_OR1300, MACH_MAX
-} MACH_ATTR;
-
-/* Enum declaration for instruction set selection.  */
-typedef enum isa_attr {
-  ISA_OR32, ISA_MAX
-} ISA_ATTR;
-
-/* Enum declaration for if this model has caches.  */
-typedef enum has_cache_attr {
-  HAS_CACHE_DATA_CACHE, HAS_CACHE_INSN_CACHE
-} HAS_CACHE_ATTR;
-
-/* Number of architecture variants.  */
-#define MAX_ISAS  1
-#define MAX_MACHS ((int) MACH_MAX)
-
-/* Ifield support.  */
-
-/* Ifield attribute indices.  */
-
-/* Enum declaration for cgen_ifld attrs.  */
-typedef enum cgen_ifld_attr {
-  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED
- , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31
- , CGEN_IFLD_MACH, CGEN_IFLD_END_NBOOLS
-} CGEN_IFLD_ATTR;
-
-/* Number of non-boolean elements in cgen_ifld_attr.  */
-#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)
-
-/* cgen_ifld attribute accessor macros.  */
-#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)
-#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_VIRTUAL)) != 0)
-#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)
-#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_ABS_ADDR)) != 0)
-#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_RESERVED)) != 0)
-#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGN_OPT)) != 0)
-#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGNED)) != 0)
-
-/* Enum declaration for openrisc ifield types.  */
-typedef enum ifield_type {
-  OPENRISC_F_NIL, OPENRISC_F_ANYOF, OPENRISC_F_CLASS, OPENRISC_F_SUB
- , OPENRISC_F_R1, OPENRISC_F_R2, OPENRISC_F_R3, OPENRISC_F_SIMM16
- , OPENRISC_F_UIMM16, OPENRISC_F_UIMM5, OPENRISC_F_HI16, OPENRISC_F_LO16
- , OPENRISC_F_OP1, OPENRISC_F_OP2, OPENRISC_F_OP3, OPENRISC_F_OP4
- , OPENRISC_F_OP5, OPENRISC_F_OP6, OPENRISC_F_OP7, OPENRISC_F_I16_1
- , OPENRISC_F_I16_2, OPENRISC_F_DISP26, OPENRISC_F_ABS26, OPENRISC_F_I16NC
- , OPENRISC_F_F_15_8, OPENRISC_F_F_10_3, OPENRISC_F_F_4_1, OPENRISC_F_F_7_3
- , OPENRISC_F_F_10_7, OPENRISC_F_F_10_11, OPENRISC_F_MAX
-} IFIELD_TYPE;
-
-#define MAX_IFLD ((int) OPENRISC_F_MAX)
-
-/* Hardware attribute indices.  */
-
-/* Enum declaration for cgen_hw attrs.  */
-typedef enum cgen_hw_attr {
-  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE
- , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_END_NBOOLS
-} CGEN_HW_ATTR;
-
-/* Number of non-boolean elements in cgen_hw_attr.  */
-#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)
-
-/* cgen_hw attribute accessor macros.  */
-#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)
-#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_VIRTUAL)) != 0)
-#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_CACHE_ADDR)) != 0)
-#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PC)) != 0)
-#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PROFILE)) != 0)
-
-/* Enum declaration for openrisc hardware types.  */
-typedef enum cgen_hw_type {
-  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR
- , HW_H_IADDR, HW_H_PC, HW_H_GR, HW_H_SR
- , HW_H_HI16, HW_H_LO16, HW_H_CBIT, HW_H_DELAY_INSN
- , HW_MAX
-} CGEN_HW_TYPE;
-
-#define MAX_HW ((int) HW_MAX)
-
-/* Operand attribute indices.  */
-
-/* Enum declaration for cgen_operand attrs.  */
-typedef enum cgen_operand_attr {
-  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT
- , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY
- , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_END_NBOOLS
-} CGEN_OPERAND_ATTR;
-
-/* Number of non-boolean elements in cgen_operand_attr.  */
-#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)
-
-/* cgen_operand attribute accessor macros.  */
-#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)
-#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_VIRTUAL)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGNED)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_NEGATIVE)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_RELAX)) != 0)
-#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)
-
-/* Enum declaration for openrisc operand types.  */
-typedef enum cgen_operand_type {
-  OPENRISC_OPERAND_PC, OPENRISC_OPERAND_SR, OPENRISC_OPERAND_CBIT, OPENRISC_OPERAND_SIMM_16
- , OPENRISC_OPERAND_UIMM_16, OPENRISC_OPERAND_DISP_26, OPENRISC_OPERAND_ABS_26, OPENRISC_OPERAND_UIMM_5
- , OPENRISC_OPERAND_RD, OPENRISC_OPERAND_RA, OPENRISC_OPERAND_RB, OPENRISC_OPERAND_OP_F_23
- , OPENRISC_OPERAND_OP_F_3, OPENRISC_OPERAND_HI16, OPENRISC_OPERAND_LO16, OPENRISC_OPERAND_UI16NC
- , OPENRISC_OPERAND_MAX
-} CGEN_OPERAND_TYPE;
-
-/* Number of operands types.  */
-#define MAX_OPERANDS 16
-
-/* Maximum number of operands referenced by any insn.  */
-#define MAX_OPERAND_INSTANCES 8
-
-/* Insn attribute indices.  */
-
-/* Enum declaration for cgen_insn attrs.  */
-typedef enum cgen_insn_attr {
-  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI
- , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED
- , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_NOT_IN_DELAY_SLOT, CGEN_INSN_END_BOOLS
- , CGEN_INSN_START_NBOOLS = 31, CGEN_INSN_MACH, CGEN_INSN_END_NBOOLS
-} CGEN_INSN_ATTR;
-
-/* Number of non-boolean elements in cgen_insn_attr.  */
-#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)
-
-/* cgen_insn attribute accessor macros.  */
-#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)
-#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_ALIAS)) != 0)
-#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_VIRTUAL)) != 0)
-#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_UNCOND_CTI)) != 0)
-#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_COND_CTI)) != 0)
-#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_SKIP_CTI)) != 0)
-#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAY_SLOT)) != 0)
-#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXABLE)) != 0)
-#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXED)) != 0)
-#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NO_DIS)) != 0)
-#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_PBB)) != 0)
-#define CGEN_ATTR_CGEN_INSN_NOT_IN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NOT_IN_DELAY_SLOT)) != 0)
-
-/* cgen.h uses things we just defined.  */
-#include "opcode/cgen.h"
-
-extern const struct cgen_ifld openrisc_cgen_ifld_table[];
-
-/* Attributes.  */
-extern const CGEN_ATTR_TABLE openrisc_cgen_hardware_attr_table[];
-extern const CGEN_ATTR_TABLE openrisc_cgen_ifield_attr_table[];
-extern const CGEN_ATTR_TABLE openrisc_cgen_operand_attr_table[];
-extern const CGEN_ATTR_TABLE openrisc_cgen_insn_attr_table[];
-
-/* Hardware decls.  */
-
-extern CGEN_KEYWORD openrisc_cgen_opval_h_gr;
-
-extern const CGEN_HW_ENTRY openrisc_cgen_hw_table[];
-
-
-
-#endif /* OPENRISC_CPU_H */
--- a/opcodes/openrisc-dis.c
+++ /dev/null
@@ -1,556 +0,0 @@
-/* Disassembler interface for targets using CGEN. -*- C -*-
-   CGEN: Cpu tools GENerator
-
-   THIS FILE IS MACHINE GENERATED WITH CGEN.
-   - the resultant file is machine generated, cgen-dis.in isn't
-
-   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007,
-   2008, 2010  Free Software Foundation, Inc.
-
-   This file is part of libopcodes.
-
-   This library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
-
-/* ??? Eventually more and more of this stuff can go to cpu-independent files.
-   Keep that in mind.  */
-
-#include "sysdep.h"
-#include <stdio.h>
-#include "ansidecl.h"
-#include "dis-asm.h"
-#include "bfd.h"
-#include "symcat.h"
-#include "libiberty.h"
-#include "openrisc-desc.h"
-#include "openrisc-opc.h"
-#include "opintl.h"
-
-/* Default text to print if an instruction isn't recognized.  */
-#define UNKNOWN_INSN_MSG _("*unknown*")
-
-static void print_normal
-  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
-static void print_address
-  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
-static void print_keyword
-  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
-static void print_insn_normal
-  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
-static int print_insn
-  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
-static int default_print_insn
-  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
-static int read_insn
-  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
-   unsigned long *);
-
-/* -- disassembler routines inserted here.  */
-
-
-void openrisc_cgen_print_operand
-  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
-
-/* Main entry point for printing operands.
-   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
-   of dis-asm.h on cgen.h.
-
-   This function is basically just a big switch statement.  Earlier versions
-   used tables to look up the function to use, but
-   - if the table contains both assembler and disassembler functions then
-     the disassembler contains much of the assembler and vice-versa,
-   - there's a lot of inlining possibilities as things grow,
-   - using a switch statement avoids the function call overhead.
-
-   This function could be moved into `print_insn_normal', but keeping it
-   separate makes clear the interface between `print_insn_normal' and each of
-   the handlers.  */
-
-void
-openrisc_cgen_print_operand (CGEN_CPU_DESC cd,
-			   int opindex,
-			   void * xinfo,
-			   CGEN_FIELDS *fields,
-			   void const *attrs ATTRIBUTE_UNUSED,
-			   bfd_vma pc,
-			   int length)
-{
-  disassemble_info *info = (disassemble_info *) xinfo;
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      print_address (cd, info, fields->f_abs26, 0|(1<<CGEN_OPERAND_ABS_ADDR), pc, length);
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      print_address (cd, info, fields->f_disp26, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      print_normal (cd, info, fields->f_simm16, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT), pc, length);
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      print_normal (cd, info, fields->f_lo16, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT), pc, length);
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      print_normal (cd, info, fields->f_op4, 0, pc, length);
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      print_normal (cd, info, fields->f_op5, 0, pc, length);
-      break;
-    case OPENRISC_OPERAND_RA :
-      print_keyword (cd, info, & openrisc_cgen_opval_h_gr, fields->f_r2, 0);
-      break;
-    case OPENRISC_OPERAND_RB :
-      print_keyword (cd, info, & openrisc_cgen_opval_h_gr, fields->f_r3, 0);
-      break;
-    case OPENRISC_OPERAND_RD :
-      print_keyword (cd, info, & openrisc_cgen_opval_h_gr, fields->f_r1, 0);
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      print_normal (cd, info, fields->f_simm16, 0|(1<<CGEN_OPERAND_SIGNED), pc, length);
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      print_normal (cd, info, fields->f_i16nc, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      print_normal (cd, info, fields->f_uimm16, 0, pc, length);
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      print_normal (cd, info, fields->f_uimm5, 0, pc, length);
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
-	       opindex);
-    abort ();
-  }
-}
-
-cgen_print_fn * const openrisc_cgen_print_handlers[] = 
-{
-  print_insn_normal,
-};
-
-
-void
-openrisc_cgen_init_dis (CGEN_CPU_DESC cd)
-{
-  openrisc_cgen_init_opcode_table (cd);
-  openrisc_cgen_init_ibld_table (cd);
-  cd->print_handlers = & openrisc_cgen_print_handlers[0];
-  cd->print_operand = openrisc_cgen_print_operand;
-}
-
-
-/* Default print handler.  */
-
-static void
-print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	      void *dis_info,
-	      long value,
-	      unsigned int attrs,
-	      bfd_vma pc ATTRIBUTE_UNUSED,
-	      int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  /* Print the operand as directed by the attributes.  */
-  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
-    ; /* nothing to do */
-  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", value);
-  else
-    (*info->fprintf_func) (info->stream, "0x%lx", value);
-}
-
-/* Default address handler.  */
-
-static void
-print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	       void *dis_info,
-	       bfd_vma value,
-	       unsigned int attrs,
-	       bfd_vma pc ATTRIBUTE_UNUSED,
-	       int length ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-
-  /* Print the operand as directed by the attributes.  */
-  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
-    ; /* Nothing to do.  */
-  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
-    (*info->print_address_func) (value, info);
-  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
-    (*info->print_address_func) (value, info);
-  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
-    (*info->fprintf_func) (info->stream, "%ld", (long) value);
-  else
-    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
-}
-
-/* Keyword print handler.  */
-
-static void
-print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	       void *dis_info,
-	       CGEN_KEYWORD *keyword_table,
-	       long value,
-	       unsigned int attrs ATTRIBUTE_UNUSED)
-{
-  disassemble_info *info = (disassemble_info *) dis_info;
-  const CGEN_KEYWORD_ENTRY *ke;
-
-  ke = cgen_keyword_lookup_value (keyword_table, value);
-  if (ke != NULL)
-    (*info->fprintf_func) (info->stream, "%s", ke->name);
-  else
-    (*info->fprintf_func) (info->stream, "???");
-}
-
-/* Default insn printer.
-
-   DIS_INFO is defined as `void *' so the disassembler needn't know anything
-   about disassemble_info.  */
-
-static void
-print_insn_normal (CGEN_CPU_DESC cd,
-		   void *dis_info,
-		   const CGEN_INSN *insn,
-		   CGEN_FIELDS *fields,
-		   bfd_vma pc,
-		   int length)
-{
-  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  disassemble_info *info = (disassemble_info *) dis_info;
-  const CGEN_SYNTAX_CHAR_TYPE *syn;
-
-  CGEN_INIT_PRINT (cd);
-
-  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
-    {
-      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
-	{
-	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
-	  continue;
-	}
-      if (CGEN_SYNTAX_CHAR_P (*syn))
-	{
-	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
-	  continue;
-	}
-
-      /* We have an operand.  */
-      openrisc_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
-				 fields, CGEN_INSN_ATTRS (insn), pc, length);
-    }
-}
-
-/* Subroutine of print_insn. Reads an insn into the given buffers and updates
-   the extract info.
-   Returns 0 if all is well, non-zero otherwise.  */
-
-static int
-read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	   bfd_vma pc,
-	   disassemble_info *info,
-	   bfd_byte *buf,
-	   int buflen,
-	   CGEN_EXTRACT_INFO *ex_info,
-	   unsigned long *insn_value)
-{
-  int status = (*info->read_memory_func) (pc, buf, buflen, info);
-
-  if (status != 0)
-    {
-      (*info->memory_error_func) (status, pc, info);
-      return -1;
-    }
-
-  ex_info->dis_info = info;
-  ex_info->valid = (1 << buflen) - 1;
-  ex_info->insn_bytes = buf;
-
-  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
-  return 0;
-}
-
-/* Utility to print an insn.
-   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
-   The result is the size of the insn in bytes or zero for an unknown insn
-   or -1 if an error occurs fetching data (memory_error_func will have
-   been called).  */
-
-static int
-print_insn (CGEN_CPU_DESC cd,
-	    bfd_vma pc,
-	    disassemble_info *info,
-	    bfd_byte *buf,
-	    unsigned int buflen)
-{
-  CGEN_INSN_INT insn_value;
-  const CGEN_INSN_LIST *insn_list;
-  CGEN_EXTRACT_INFO ex_info;
-  int basesize;
-
-  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
-  basesize = cd->base_insn_bitsize < buflen * 8 ?
-                                     cd->base_insn_bitsize : buflen * 8;
-  insn_value = cgen_get_insn_value (cd, buf, basesize);
-
-
-  /* Fill in ex_info fields like read_insn would.  Don't actually call
-     read_insn, since the incoming buffer is already read (and possibly
-     modified a la m32r).  */
-  ex_info.valid = (1 << buflen) - 1;
-  ex_info.dis_info = info;
-  ex_info.insn_bytes = buf;
-
-  /* The instructions are stored in hash lists.
-     Pick the first one and keep trying until we find the right one.  */
-
-  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
-  while (insn_list != NULL)
-    {
-      const CGEN_INSN *insn = insn_list->insn;
-      CGEN_FIELDS fields;
-      int length;
-      unsigned long insn_value_cropped;
-
-#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
-      /* Not needed as insn shouldn't be in hash lists if not supported.  */
-      /* Supported by this cpu?  */
-      if (! openrisc_cgen_insn_supported (cd, insn))
-        {
-          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
-	  continue;
-        }
-#endif
-
-      /* Basic bit mask must be correct.  */
-      /* ??? May wish to allow target to defer this check until the extract
-	 handler.  */
-
-      /* Base size may exceed this instruction's size.  Extract the
-         relevant part from the buffer. */
-      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
-	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
-					   info->endian == BFD_ENDIAN_BIG);
-      else
-	insn_value_cropped = insn_value;
-
-      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
-	  == CGEN_INSN_BASE_VALUE (insn))
-	{
-	  /* Printing is handled in two passes.  The first pass parses the
-	     machine insn and extracts the fields.  The second pass prints
-	     them.  */
-
-	  /* Make sure the entire insn is loaded into insn_value, if it
-	     can fit.  */
-	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
-	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
-	    {
-	      unsigned long full_insn_value;
-	      int rc = read_insn (cd, pc, info, buf,
-				  CGEN_INSN_BITSIZE (insn) / 8,
-				  & ex_info, & full_insn_value);
-	      if (rc != 0)
-		return rc;
-	      length = CGEN_EXTRACT_FN (cd, insn)
-		(cd, insn, &ex_info, full_insn_value, &fields, pc);
-	    }
-	  else
-	    length = CGEN_EXTRACT_FN (cd, insn)
-	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
-
-	  /* Length < 0 -> error.  */
-	  if (length < 0)
-	    return length;
-	  if (length > 0)
-	    {
-	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
-	      /* Length is in bits, result is in bytes.  */
-	      return length / 8;
-	    }
-	}
-
-      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
-    }
-
-  return 0;
-}
-
-/* Default value for CGEN_PRINT_INSN.
-   The result is the size of the insn in bytes or zero for an unknown insn
-   or -1 if an error occured fetching bytes.  */
-
-#ifndef CGEN_PRINT_INSN
-#define CGEN_PRINT_INSN default_print_insn
-#endif
-
-static int
-default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
-{
-  bfd_byte buf[CGEN_MAX_INSN_SIZE];
-  int buflen;
-  int status;
-
-  /* Attempt to read the base part of the insn.  */
-  buflen = cd->base_insn_bitsize / 8;
-  status = (*info->read_memory_func) (pc, buf, buflen, info);
-
-  /* Try again with the minimum part, if min < base.  */
-  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
-    {
-      buflen = cd->min_insn_bitsize / 8;
-      status = (*info->read_memory_func) (pc, buf, buflen, info);
-    }
-
-  if (status != 0)
-    {
-      (*info->memory_error_func) (status, pc, info);
-      return -1;
-    }
-
-  return print_insn (cd, pc, info, buf, buflen);
-}
-
-/* Main entry point.
-   Print one instruction from PC on INFO->STREAM.
-   Return the size of the instruction (in bytes).  */
-
-typedef struct cpu_desc_list
-{
-  struct cpu_desc_list *next;
-  CGEN_BITSET *isa;
-  int mach;
-  int endian;
-  CGEN_CPU_DESC cd;
-} cpu_desc_list;
-
-int
-print_insn_openrisc (bfd_vma pc, disassemble_info *info)
-{
-  static cpu_desc_list *cd_list = 0;
-  cpu_desc_list *cl = 0;
-  static CGEN_CPU_DESC cd = 0;
-  static CGEN_BITSET *prev_isa;
-  static int prev_mach;
-  static int prev_endian;
-  int length;
-  CGEN_BITSET *isa;
-  int mach;
-  int endian = (info->endian == BFD_ENDIAN_BIG
-		? CGEN_ENDIAN_BIG
-		: CGEN_ENDIAN_LITTLE);
-  enum bfd_architecture arch;
-
-  /* ??? gdb will set mach but leave the architecture as "unknown" */
-#ifndef CGEN_BFD_ARCH
-#define CGEN_BFD_ARCH bfd_arch_openrisc
-#endif
-  arch = info->arch;
-  if (arch == bfd_arch_unknown)
-    arch = CGEN_BFD_ARCH;
-   
-  /* There's no standard way to compute the machine or isa number
-     so we leave it to the target.  */
-#ifdef CGEN_COMPUTE_MACH
-  mach = CGEN_COMPUTE_MACH (info);
-#else
-  mach = info->mach;
-#endif
-
-#ifdef CGEN_COMPUTE_ISA
-  {
-    static CGEN_BITSET *permanent_isa;
-
-    if (!permanent_isa)
-      permanent_isa = cgen_bitset_create (MAX_ISAS);
-    isa = permanent_isa;
-    cgen_bitset_clear (isa);
-    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
-  }
-#else
-  isa = info->insn_sets;
-#endif
-
-  /* If we've switched cpu's, try to find a handle we've used before */
-  if (cd
-      && (cgen_bitset_compare (isa, prev_isa) != 0
-	  || mach != prev_mach
-	  || endian != prev_endian))
-    {
-      cd = 0;
-      for (cl = cd_list; cl; cl = cl->next)
-	{
-	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
-	      cl->mach == mach &&
-	      cl->endian == endian)
-	    {
-	      cd = cl->cd;
- 	      prev_isa = cd->isas;
-	      break;
-	    }
-	}
-    } 
-
-  /* If we haven't initialized yet, initialize the opcode table.  */
-  if (! cd)
-    {
-      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
-      const char *mach_name;
-
-      if (!arch_type)
-	abort ();
-      mach_name = arch_type->printable_name;
-
-      prev_isa = cgen_bitset_copy (isa);
-      prev_mach = mach;
-      prev_endian = endian;
-      cd = openrisc_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
-				 CGEN_CPU_OPEN_BFDMACH, mach_name,
-				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
-				 CGEN_CPU_OPEN_END);
-      if (!cd)
-	abort ();
-
-      /* Save this away for future reference.  */
-      cl = xmalloc (sizeof (struct cpu_desc_list));
-      cl->cd = cd;
-      cl->isa = prev_isa;
-      cl->mach = mach;
-      cl->endian = endian;
-      cl->next = cd_list;
-      cd_list = cl;
-
-      openrisc_cgen_init_dis (cd);
-    }
-
-  /* We try to have as much common code as possible.
-     But at this point some targets need to take over.  */
-  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
-     but if not possible try to move this hook elsewhere rather than
-     have two hooks.  */
-  length = CGEN_PRINT_INSN (cd, pc, info);
-  if (length > 0)
-    return length;
-  if (length < 0)
-    return -1;
-
-  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
-  return cd->default_insn_bitsize / 8;
-}
--- a/opcodes/openrisc-ibld.c
+++ /dev/null
@@ -1,1009 +0,0 @@
-/* Instruction building/extraction support for openrisc. -*- C -*-
-
-   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.
-   - the resultant file is machine generated, cgen-ibld.in isn't
-
-   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2006, 2007,
-   2008, 2010  Free Software Foundation, Inc.
-
-   This file is part of libopcodes.
-
-   This library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
-
-/* ??? Eventually more and more of this stuff can go to cpu-independent files.
-   Keep that in mind.  */
-
-#include "sysdep.h"
-#include <stdio.h>
-#include "ansidecl.h"
-#include "dis-asm.h"
-#include "bfd.h"
-#include "symcat.h"
-#include "openrisc-desc.h"
-#include "openrisc-opc.h"
-#include "cgen/basic-modes.h"
-#include "opintl.h"
-#include "safe-ctype.h"
-
-#undef  min
-#define min(a,b) ((a) < (b) ? (a) : (b))
-#undef  max
-#define max(a,b) ((a) > (b) ? (a) : (b))
-
-/* Used by the ifield rtx function.  */
-#define FLD(f) (fields->f)
-
-static const char * insert_normal
-  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
-static const char * insert_insn_normal
-  (CGEN_CPU_DESC, const CGEN_INSN *,
-   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
-static int extract_normal
-  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
-   unsigned int, unsigned int, unsigned int, unsigned int,
-   unsigned int, unsigned int, bfd_vma, long *);
-static int extract_insn_normal
-  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
-   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
-#if CGEN_INT_INSN_P
-static void put_insn_int_value
-  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);
-#endif
-#if ! CGEN_INT_INSN_P
-static CGEN_INLINE void insert_1
-  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
-static CGEN_INLINE int fill_cache
-  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
-static CGEN_INLINE long extract_1
-  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
-#endif
-
-/* Operand insertion.  */
-
-#if ! CGEN_INT_INSN_P
-
-/* Subroutine of insert_normal.  */
-
-static CGEN_INLINE void
-insert_1 (CGEN_CPU_DESC cd,
-	  unsigned long value,
-	  int start,
-	  int length,
-	  int word_length,
-	  unsigned char *bufp)
-{
-  unsigned long x,mask;
-  int shift;
-
-  x = cgen_get_insn_value (cd, bufp, word_length);
-
-  /* Written this way to avoid undefined behaviour.  */
-  mask = (((1L << (length - 1)) - 1) << 1) | 1;
-  if (CGEN_INSN_LSB0_P)
-    shift = (start + 1) - length;
-  else
-    shift = (word_length - (start + length));
-  x = (x & ~(mask << shift)) | ((value & mask) << shift);
-
-  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);
-}
-
-#endif /* ! CGEN_INT_INSN_P */
-
-/* Default insertion routine.
-
-   ATTRS is a mask of the boolean attributes.
-   WORD_OFFSET is the offset in bits from the start of the insn of the value.
-   WORD_LENGTH is the length of the word in bits in which the value resides.
-   START is the starting bit number in the word, architecture origin.
-   LENGTH is the length of VALUE in bits.
-   TOTAL_LENGTH is the total length of the insn in bits.
-
-   The result is an error message or NULL if success.  */
-
-/* ??? This duplicates functionality with bfd's howto table and
-   bfd_install_relocation.  */
-/* ??? This doesn't handle bfd_vma's.  Create another function when
-   necessary.  */
-
-static const char *
-insert_normal (CGEN_CPU_DESC cd,
-	       long value,
-	       unsigned int attrs,
-	       unsigned int word_offset,
-	       unsigned int start,
-	       unsigned int length,
-	       unsigned int word_length,
-	       unsigned int total_length,
-	       CGEN_INSN_BYTES_PTR buffer)
-{
-  static char errbuf[100];
-  /* Written this way to avoid undefined behaviour.  */
-  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
-
-  /* If LENGTH is zero, this operand doesn't contribute to the value.  */
-  if (length == 0)
-    return NULL;
-
-  if (word_length > 8 * sizeof (CGEN_INSN_INT))
-    abort ();
-
-  /* For architectures with insns smaller than the base-insn-bitsize,
-     word_length may be too big.  */
-  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
-    {
-      if (word_offset == 0
-	  && word_length > total_length)
-	word_length = total_length;
-    }
-
-  /* Ensure VALUE will fit.  */
-  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
-    {
-      long minval = - (1L << (length - 1));
-      unsigned long maxval = mask;
-      
-      if ((value > 0 && (unsigned long) value > maxval)
-	  || value < minval)
-	{
-	  /* xgettext:c-format */
-	  sprintf (errbuf,
-		   _("operand out of range (%ld not between %ld and %lu)"),
-		   value, minval, maxval);
-	  return errbuf;
-	}
-    }
-  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
-    {
-      unsigned long maxval = mask;
-      unsigned long val = (unsigned long) value;
-
-      /* For hosts with a word size > 32 check to see if value has been sign
-	 extended beyond 32 bits.  If so then ignore these higher sign bits
-	 as the user is attempting to store a 32-bit signed value into an
-	 unsigned 32-bit field which is allowed.  */
-      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
-	val &= 0xFFFFFFFF;
-
-      if (val > maxval)
-	{
-	  /* xgettext:c-format */
-	  sprintf (errbuf,
-		   _("operand out of range (0x%lx not between 0 and 0x%lx)"),
-		   val, maxval);
-	  return errbuf;
-	}
-    }
-  else
-    {
-      if (! cgen_signed_overflow_ok_p (cd))
-	{
-	  long minval = - (1L << (length - 1));
-	  long maxval =   (1L << (length - 1)) - 1;
-	  
-	  if (value < minval || value > maxval)
-	    {
-	      sprintf
-		/* xgettext:c-format */
-		(errbuf, _("operand out of range (%ld not between %ld and %ld)"),
-		 value, minval, maxval);
-	      return errbuf;
-	    }
-	}
-    }
-
-#if CGEN_INT_INSN_P
-
-  {
-    int shift;
-
-    if (CGEN_INSN_LSB0_P)
-      shift = (word_offset + start + 1) - length;
-    else
-      shift = total_length - (word_offset + start + length);
-    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);
-  }
-
-#else /* ! CGEN_INT_INSN_P */
-
-  {
-    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;
-
-    insert_1 (cd, value, start, length, word_length, bufp);
-  }
-
-#endif /* ! CGEN_INT_INSN_P */
-
-  return NULL;
-}
-
-/* Default insn builder (insert handler).
-   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning
-   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is
-   recorded in host byte order, otherwise BUFFER is an array of bytes
-   and the value is recorded in target byte order).
-   The result is an error message or NULL if success.  */
-
-static const char *
-insert_insn_normal (CGEN_CPU_DESC cd,
-		    const CGEN_INSN * insn,
-		    CGEN_FIELDS * fields,
-		    CGEN_INSN_BYTES_PTR buffer,
-		    bfd_vma pc)
-{
-  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  unsigned long value;
-  const CGEN_SYNTAX_CHAR_TYPE * syn;
-
-  CGEN_INIT_INSERT (cd);
-  value = CGEN_INSN_BASE_VALUE (insn);
-
-  /* If we're recording insns as numbers (rather than a string of bytes),
-     target byte order handling is deferred until later.  */
-
-#if CGEN_INT_INSN_P
-
-  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,
-		      CGEN_FIELDS_BITSIZE (fields), value);
-
-#else
-
-  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,
-					(unsigned) CGEN_FIELDS_BITSIZE (fields)),
-		       value);
-
-#endif /* ! CGEN_INT_INSN_P */
-
-  /* ??? It would be better to scan the format's fields.
-     Still need to be able to insert a value based on the operand though;
-     e.g. storing a branch displacement that got resolved later.
-     Needs more thought first.  */
-
-  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)
-    {
-      const char *errmsg;
-
-      if (CGEN_SYNTAX_CHAR_P (* syn))
-	continue;
-
-      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
-				       fields, buffer, pc);
-      if (errmsg)
-	return errmsg;
-    }
-
-  return NULL;
-}
-
-#if CGEN_INT_INSN_P
-/* Cover function to store an insn value into an integral insn.  Must go here
-   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */
-
-static void
-put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-		    CGEN_INSN_BYTES_PTR buf,
-		    int length,
-		    int insn_length,
-		    CGEN_INSN_INT value)
-{
-  /* For architectures with insns smaller than the base-insn-bitsize,
-     length may be too big.  */
-  if (length > insn_length)
-    *buf = value;
-  else
-    {
-      int shift = insn_length - length;
-      /* Written this way to avoid undefined behaviour.  */
-      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;
-
-      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);
-    }
-}
-#endif
-
-/* Operand extraction.  */
-
-#if ! CGEN_INT_INSN_P
-
-/* Subroutine of extract_normal.
-   Ensure sufficient bytes are cached in EX_INFO.
-   OFFSET is the offset in bytes from the start of the insn of the value.
-   BYTES is the length of the needed value.
-   Returns 1 for success, 0 for failure.  */
-
-static CGEN_INLINE int
-fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-	    CGEN_EXTRACT_INFO *ex_info,
-	    int offset,
-	    int bytes,
-	    bfd_vma pc)
-{
-  /* It's doubtful that the middle part has already been fetched so
-     we don't optimize that case.  kiss.  */
-  unsigned int mask;
-  disassemble_info *info = (disassemble_info *) ex_info->dis_info;
-
-  /* First do a quick check.  */
-  mask = (1 << bytes) - 1;
-  if (((ex_info->valid >> offset) & mask) == mask)
-    return 1;
-
-  /* Search for the first byte we need to read.  */
-  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)
-    if (! (mask & ex_info->valid))
-      break;
-
-  if (bytes)
-    {
-      int status;
-
-      pc += offset;
-      status = (*info->read_memory_func)
-	(pc, ex_info->insn_bytes + offset, bytes, info);
-
-      if (status != 0)
-	{
-	  (*info->memory_error_func) (status, pc, info);
-	  return 0;
-	}
-
-      ex_info->valid |= ((1 << bytes) - 1) << offset;
-    }
-
-  return 1;
-}
-
-/* Subroutine of extract_normal.  */
-
-static CGEN_INLINE long
-extract_1 (CGEN_CPU_DESC cd,
-	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
-	   int start,
-	   int length,
-	   int word_length,
-	   unsigned char *bufp,
-	   bfd_vma pc ATTRIBUTE_UNUSED)
-{
-  unsigned long x;
-  int shift;
-
-  x = cgen_get_insn_value (cd, bufp, word_length);
-
-  if (CGEN_INSN_LSB0_P)
-    shift = (start + 1) - length;
-  else
-    shift = (word_length - (start + length));
-  return x >> shift;
-}
-
-#endif /* ! CGEN_INT_INSN_P */
-
-/* Default extraction routine.
-
-   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,
-   or sometimes less for cases like the m32r where the base insn size is 32
-   but some insns are 16 bits.
-   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',
-   but for generality we take a bitmask of all of them.
-   WORD_OFFSET is the offset in bits from the start of the insn of the value.
-   WORD_LENGTH is the length of the word in bits in which the value resides.
-   START is the starting bit number in the word, architecture origin.
-   LENGTH is the length of VALUE in bits.
-   TOTAL_LENGTH is the total length of the insn in bits.
-
-   Returns 1 for success, 0 for failure.  */
-
-/* ??? The return code isn't properly used.  wip.  */
-
-/* ??? This doesn't handle bfd_vma's.  Create another function when
-   necessary.  */
-
-static int
-extract_normal (CGEN_CPU_DESC cd,
-#if ! CGEN_INT_INSN_P
-		CGEN_EXTRACT_INFO *ex_info,
-#else
-		CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
-#endif
-		CGEN_INSN_INT insn_value,
-		unsigned int attrs,
-		unsigned int word_offset,
-		unsigned int start,
-		unsigned int length,
-		unsigned int word_length,
-		unsigned int total_length,
-#if ! CGEN_INT_INSN_P
-		bfd_vma pc,
-#else
-		bfd_vma pc ATTRIBUTE_UNUSED,
-#endif
-		long *valuep)
-{
-  long value, mask;
-
-  /* If LENGTH is zero, this operand doesn't contribute to the value
-     so give it a standard value of zero.  */
-  if (length == 0)
-    {
-      *valuep = 0;
-      return 1;
-    }
-
-  if (word_length > 8 * sizeof (CGEN_INSN_INT))
-    abort ();
-
-  /* For architectures with insns smaller than the insn-base-bitsize,
-     word_length may be too big.  */
-  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
-    {
-      if (word_offset + word_length > total_length)
-	word_length = total_length - word_offset;
-    }
-
-  /* Does the value reside in INSN_VALUE, and at the right alignment?  */
-
-  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))
-    {
-      if (CGEN_INSN_LSB0_P)
-	value = insn_value >> ((word_offset + start + 1) - length);
-      else
-	value = insn_value >> (total_length - ( word_offset + start + length));
-    }
-
-#if ! CGEN_INT_INSN_P
-
-  else
-    {
-      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;
-
-      if (word_length > 8 * sizeof (CGEN_INSN_INT))
-	abort ();
-
-      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)
-	return 0;
-
-      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);
-    }
-
-#endif /* ! CGEN_INT_INSN_P */
-
-  /* Written this way to avoid undefined behaviour.  */
-  mask = (((1L << (length - 1)) - 1) << 1) | 1;
-
-  value &= mask;
-  /* sign extend? */
-  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)
-      && (value & (1L << (length - 1))))
-    value |= ~mask;
-
-  *valuep = value;
-
-  return 1;
-}
-
-/* Default insn extractor.
-
-   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.
-   The extracted fields are stored in FIELDS.
-   EX_INFO is used to handle reading variable length insns.
-   Return the length of the insn in bits, or 0 if no match,
-   or -1 if an error occurs fetching data (memory_error_func will have
-   been called).  */
-
-static int
-extract_insn_normal (CGEN_CPU_DESC cd,
-		     const CGEN_INSN *insn,
-		     CGEN_EXTRACT_INFO *ex_info,
-		     CGEN_INSN_INT insn_value,
-		     CGEN_FIELDS *fields,
-		     bfd_vma pc)
-{
-  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
-  const CGEN_SYNTAX_CHAR_TYPE *syn;
-
-  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
-
-  CGEN_INIT_EXTRACT (cd);
-
-  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
-    {
-      int length;
-
-      if (CGEN_SYNTAX_CHAR_P (*syn))
-	continue;
-
-      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
-					ex_info, insn_value, fields, pc);
-      if (length <= 0)
-	return length;
-    }
-
-  /* We recognized and successfully extracted this insn.  */
-  return CGEN_INSN_BITSIZE (insn);
-}
-
-/* Machine generated code added here.  */
-
-const char * openrisc_cgen_insert_operand
-  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
-
-/* Main entry point for operand insertion.
-
-   This function is basically just a big switch statement.  Earlier versions
-   used tables to look up the function to use, but
-   - if the table contains both assembler and disassembler functions then
-     the disassembler contains much of the assembler and vice-versa,
-   - there's a lot of inlining possibilities as things grow,
-   - using a switch statement avoids the function call overhead.
-
-   This function could be moved into `parse_insn_normal', but keeping it
-   separate makes clear the interface between `parse_insn_normal' and each of
-   the handlers.  It's also needed by GAS to insert operands that couldn't be
-   resolved during parsing.  */
-
-const char *
-openrisc_cgen_insert_operand (CGEN_CPU_DESC cd,
-			     int opindex,
-			     CGEN_FIELDS * fields,
-			     CGEN_INSN_BYTES_PTR buffer,
-			     bfd_vma pc ATTRIBUTE_UNUSED)
-{
-  const char * errmsg = NULL;
-  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      {
-        long value = fields->f_abs26;
-        value = ((SI) (pc) >> (2));
-        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_ABS_ADDR), 0, 25, 26, 32, total_length, buffer);
-      }
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      {
-        long value = fields->f_disp26;
-        value = ((SI) (((value) - (pc))) >> (2));
-        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, buffer);
-      }
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      errmsg = insert_normal (cd, fields->f_simm16, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      errmsg = insert_normal (cd, fields->f_lo16, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      errmsg = insert_normal (cd, fields->f_op4, 0, 0, 23, 3, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      errmsg = insert_normal (cd, fields->f_op5, 0, 0, 25, 5, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_RA :
-      errmsg = insert_normal (cd, fields->f_r2, 0, 0, 20, 5, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_RB :
-      errmsg = insert_normal (cd, fields->f_r3, 0, 0, 15, 5, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_RD :
-      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      errmsg = insert_normal (cd, fields->f_simm16, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      {
-{
-  FLD (f_i16_2) = ((((HI) (FLD (f_i16nc)) >> (11))) & (31));
-  FLD (f_i16_1) = ((FLD (f_i16nc)) & (2047));
-}
-        errmsg = insert_normal (cd, fields->f_i16_1, 0, 0, 10, 11, 32, total_length, buffer);
-        if (errmsg)
-          break;
-        errmsg = insert_normal (cd, fields->f_i16_2, 0, 0, 25, 5, 32, total_length, buffer);
-        if (errmsg)
-          break;
-      }
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      errmsg = insert_normal (cd, fields->f_uimm16, 0, 0, 15, 16, 32, total_length, buffer);
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      errmsg = insert_normal (cd, fields->f_uimm5, 0, 0, 4, 5, 32, total_length, buffer);
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while building insn.\n"),
-	       opindex);
-      abort ();
-  }
-
-  return errmsg;
-}
-
-int openrisc_cgen_extract_operand
-  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
-
-/* Main entry point for operand extraction.
-   The result is <= 0 for error, >0 for success.
-   ??? Actual values aren't well defined right now.
-
-   This function is basically just a big switch statement.  Earlier versions
-   used tables to look up the function to use, but
-   - if the table contains both assembler and disassembler functions then
-     the disassembler contains much of the assembler and vice-versa,
-   - there's a lot of inlining possibilities as things grow,
-   - using a switch statement avoids the function call overhead.
-
-   This function could be moved into `print_insn_normal', but keeping it
-   separate makes clear the interface between `print_insn_normal' and each of
-   the handlers.  */
-
-int
-openrisc_cgen_extract_operand (CGEN_CPU_DESC cd,
-			     int opindex,
-			     CGEN_EXTRACT_INFO *ex_info,
-			     CGEN_INSN_INT insn_value,
-			     CGEN_FIELDS * fields,
-			     bfd_vma pc)
-{
-  /* Assume success (for those operands that are nops).  */
-  int length = 1;
-  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      {
-        long value;
-        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_ABS_ADDR), 0, 25, 26, 32, total_length, pc, & value);
-        value = ((value) << (2));
-        fields->f_abs26 = value;
-      }
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      {
-        long value;
-        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, pc, & value);
-        value = ((((value) << (2))) + (pc));
-        fields->f_disp26 = value;
-      }
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_simm16);
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_lo16);
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 23, 3, 32, total_length, pc, & fields->f_op4);
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_op5);
-      break;
-    case OPENRISC_OPERAND_RA :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 20, 5, 32, total_length, pc, & fields->f_r2);
-      break;
-    case OPENRISC_OPERAND_RB :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 5, 32, total_length, pc, & fields->f_r3);
-      break;
-    case OPENRISC_OPERAND_RD :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED), 0, 15, 16, 32, total_length, pc, & fields->f_simm16);
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      {
-        length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 11, 32, total_length, pc, & fields->f_i16_1);
-        if (length <= 0) break;
-        length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_i16_2);
-        if (length <= 0) break;
-{
-  FLD (f_i16nc) = openrisc_sign_extend_16bit (((((FLD (f_i16_2)) << (11))) | (FLD (f_i16_1))));
-}
-      }
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 16, 32, total_length, pc, & fields->f_uimm16);
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      length = extract_normal (cd, ex_info, insn_value, 0, 0, 4, 5, 32, total_length, pc, & fields->f_uimm5);
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while decoding insn.\n"),
-	       opindex);
-      abort ();
-    }
-
-  return length;
-}
-
-cgen_insert_fn * const openrisc_cgen_insert_handlers[] = 
-{
-  insert_insn_normal,
-};
-
-cgen_extract_fn * const openrisc_cgen_extract_handlers[] = 
-{
-  extract_insn_normal,
-};
-
-int openrisc_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
-bfd_vma openrisc_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
-
-/* Getting values from cgen_fields is handled by a collection of functions.
-   They are distinguished by the type of the VALUE argument they return.
-   TODO: floating point, inlining support, remove cases where result type
-   not appropriate.  */
-
-int
-openrisc_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			     int opindex,
-			     const CGEN_FIELDS * fields)
-{
-  int value;
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      value = fields->f_abs26;
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      value = fields->f_disp26;
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      value = fields->f_simm16;
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      value = fields->f_lo16;
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      value = fields->f_op4;
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      value = fields->f_op5;
-      break;
-    case OPENRISC_OPERAND_RA :
-      value = fields->f_r2;
-      break;
-    case OPENRISC_OPERAND_RB :
-      value = fields->f_r3;
-      break;
-    case OPENRISC_OPERAND_RD :
-      value = fields->f_r1;
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      value = fields->f_simm16;
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      value = fields->f_i16nc;
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      value = fields->f_uimm16;
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      value = fields->f_uimm5;
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while getting int operand.\n"),
-		       opindex);
-      abort ();
-  }
-
-  return value;
-}
-
-bfd_vma
-openrisc_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			     int opindex,
-			     const CGEN_FIELDS * fields)
-{
-  bfd_vma value;
-
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      value = fields->f_abs26;
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      value = fields->f_disp26;
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      value = fields->f_simm16;
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      value = fields->f_lo16;
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      value = fields->f_op4;
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      value = fields->f_op5;
-      break;
-    case OPENRISC_OPERAND_RA :
-      value = fields->f_r2;
-      break;
-    case OPENRISC_OPERAND_RB :
-      value = fields->f_r3;
-      break;
-    case OPENRISC_OPERAND_RD :
-      value = fields->f_r1;
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      value = fields->f_simm16;
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      value = fields->f_i16nc;
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      value = fields->f_uimm16;
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      value = fields->f_uimm5;
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while getting vma operand.\n"),
-		       opindex);
-      abort ();
-  }
-
-  return value;
-}
-
-void openrisc_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);
-void openrisc_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);
-
-/* Stuffing values in cgen_fields is handled by a collection of functions.
-   They are distinguished by the type of the VALUE argument they accept.
-   TODO: floating point, inlining support, remove cases where argument type
-   not appropriate.  */
-
-void
-openrisc_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			     int opindex,
-			     CGEN_FIELDS * fields,
-			     int value)
-{
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      fields->f_abs26 = value;
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      fields->f_disp26 = value;
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      fields->f_simm16 = value;
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      fields->f_lo16 = value;
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      fields->f_op4 = value;
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      fields->f_op5 = value;
-      break;
-    case OPENRISC_OPERAND_RA :
-      fields->f_r2 = value;
-      break;
-    case OPENRISC_OPERAND_RB :
-      fields->f_r3 = value;
-      break;
-    case OPENRISC_OPERAND_RD :
-      fields->f_r1 = value;
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      fields->f_simm16 = value;
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      fields->f_i16nc = value;
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      fields->f_uimm16 = value;
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      fields->f_uimm5 = value;
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while setting int operand.\n"),
-		       opindex);
-      abort ();
-  }
-}
-
-void
-openrisc_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
-			     int opindex,
-			     CGEN_FIELDS * fields,
-			     bfd_vma value)
-{
-  switch (opindex)
-    {
-    case OPENRISC_OPERAND_ABS_26 :
-      fields->f_abs26 = value;
-      break;
-    case OPENRISC_OPERAND_DISP_26 :
-      fields->f_disp26 = value;
-      break;
-    case OPENRISC_OPERAND_HI16 :
-      fields->f_simm16 = value;
-      break;
-    case OPENRISC_OPERAND_LO16 :
-      fields->f_lo16 = value;
-      break;
-    case OPENRISC_OPERAND_OP_F_23 :
-      fields->f_op4 = value;
-      break;
-    case OPENRISC_OPERAND_OP_F_3 :
-      fields->f_op5 = value;
-      break;
-    case OPENRISC_OPERAND_RA :
-      fields->f_r2 = value;
-      break;
-    case OPENRISC_OPERAND_RB :
-      fields->f_r3 = value;
-      break;
-    case OPENRISC_OPERAND_RD :
-      fields->f_r1 = value;
-      break;
-    case OPENRISC_OPERAND_SIMM_16 :
-      fields->f_simm16 = value;
-      break;
-    case OPENRISC_OPERAND_UI16NC :
-      fields->f_i16nc = value;
-      break;
-    case OPENRISC_OPERAND_UIMM_16 :
-      fields->f_uimm16 = value;
-      break;
-    case OPENRISC_OPERAND_UIMM_5 :
-      fields->f_uimm5 = value;
-      break;
-
-    default :
-      /* xgettext:c-format */
-      fprintf (stderr, _("Unrecognized field %d while setting vma operand.\n"),
-		       opindex);
-      abort ();
-  }
-}
-
-/* Function to call before using the instruction builder tables.  */
-
-void
-openrisc_cgen_init_ibld_table (CGEN_CPU_DESC cd)
-{
-  cd->insert_handlers = & openrisc_cgen_insert_handlers[0];
-  cd->extract_handlers = & openrisc_cgen_extract_handlers[0];
-
-  cd->insert_operand = openrisc_cgen_insert_operand;
-  cd->extract_operand = openrisc_cgen_extract_operand;
-
-  cd->get_int_operand = openrisc_cgen_get_int_operand;
-  cd->set_int_operand = openrisc_cgen_set_int_operand;
-  cd->get_vma_operand = openrisc_cgen_get_vma_operand;
-  cd->set_vma_operand = openrisc_cgen_set_vma_operand;
-}
--- a/opcodes/openrisc-opc.c
+++ /dev/null
@@ -1,682 +0,0 @@
-/* Instruction opcode table for openrisc.
-
-THIS FILE IS MACHINE GENERATED WITH CGEN.
-
-Copyright 1996-2010 Free Software Foundation, Inc.
-
-This file is part of the GNU Binutils and/or GDB, the GNU debugger.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
-
-*/
-
-#include "sysdep.h"
-#include "ansidecl.h"
-#include "bfd.h"
-#include "symcat.h"
-#include "openrisc-desc.h"
-#include "openrisc-opc.h"
-#include "libiberty.h"
-
-/* -- opc.c */
-/* -- */
-/* The hash functions are recorded here to help keep assembler code out of
-   the disassembler and vice versa.  */
-
-static int asm_hash_insn_p        (const CGEN_INSN *);
-static unsigned int asm_hash_insn (const char *);
-static int dis_hash_insn_p        (const CGEN_INSN *);
-static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);
-
-/* Instruction formats.  */
-
-#define F(f) & openrisc_cgen_ifld_table[OPENRISC_##f]
-static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
-  0, 0, 0x0, { { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_j ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_ABS26) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_jr ATTRIBUTE_UNUSED = {
-  32, 32, 0xffe00000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_OP3) }, { F (F_OP4) }, { F (F_R2) }, { F (F_UIMM16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_bal ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_DISP26) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_movhi ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_mfsr ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_UIMM16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_mtsr ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc0007ff, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_I16_1) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_lw ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_sw ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R3) }, { F (F_I16NC) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_sll ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc0007ff, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_F_10_3) }, { F (F_OP6) }, { F (F_F_4_1) }, { F (F_OP7) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_slli ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc00ffe0, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_F_15_8) }, { F (F_OP6) }, { F (F_UIMM5) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_add ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc0007ff, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_F_10_7) }, { F (F_OP7) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_addi ATTRIBUTE_UNUSED = {
-  32, 32, 0xfc000000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_R1) }, { F (F_R2) }, { F (F_LO16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_sfgts ATTRIBUTE_UNUSED = {
-  32, 32, 0xffe007ff, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_OP5) }, { F (F_R2) }, { F (F_R3) }, { F (F_F_10_11) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_sfgtsi ATTRIBUTE_UNUSED = {
-  32, 32, 0xffe00000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_OP5) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
-};
-
-static const CGEN_IFMT ifmt_l_sfgtui ATTRIBUTE_UNUSED = {
-  32, 32, 0xffe00000, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_OP5) }, { F (F_R2) }, { F (F_UIMM16) }, { 0 } }
-};
-
-#undef F
-
-#define A(a) (1 << CGEN_INSN_##a)
-#define OPERAND(op) OPENRISC_OPERAND_##op
-#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
-#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
-
-/* The instruction table.  */
-
-static const CGEN_OPCODE openrisc_cgen_insn_opcode_table[MAX_INSNS] =
-{
-  /* Special null first entry.
-     A `num' value of zero is thus invalid.
-     Also, the special `invalid' insn resides here.  */
-  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
-/* l.j ${abs-26} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (ABS_26), 0 } },
-    & ifmt_l_j, { 0x0 }
-  },
-/* l.jal ${abs-26} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (ABS_26), 0 } },
-    & ifmt_l_j, { 0x4000000 }
-  },
-/* l.jr $rA */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), 0 } },
-    & ifmt_l_jr, { 0x14000000 }
-  },
-/* l.jalr $rA */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), 0 } },
-    & ifmt_l_jr, { 0x14200000 }
-  },
-/* l.bal ${disp-26} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (DISP_26), 0 } },
-    & ifmt_l_bal, { 0x8000000 }
-  },
-/* l.bnf ${disp-26} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (DISP_26), 0 } },
-    & ifmt_l_bal, { 0xc000000 }
-  },
-/* l.bf ${disp-26} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (DISP_26), 0 } },
-    & ifmt_l_bal, { 0x10000000 }
-  },
-/* l.brk ${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (UIMM_16), 0 } },
-    & ifmt_l_jr, { 0x17000000 }
-  },
-/* l.rfe $rA */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), 0 } },
-    & ifmt_l_jr, { 0x14400000 }
-  },
-/* l.sys ${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (UIMM_16), 0 } },
-    & ifmt_l_jr, { 0x16000000 }
-  },
-/* l.nop */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, 0 } },
-    & ifmt_l_jr, { 0x15000000 }
-  },
-/* l.movhi $rD,$hi16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (HI16), 0 } },
-    & ifmt_l_movhi, { 0x18000000 }
-  },
-/* l.mfsr $rD,$rA */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
-    & ifmt_l_mfsr, { 0x1c000000 }
-  },
-/* l.mtsr $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_mtsr, { 0x40000000 }
-  },
-/* l.lw $rD,${simm-16}($rA) */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (SIMM_16), '(', OP (RA), ')', 0 } },
-    & ifmt_l_lw, { 0x80000000 }
-  },
-/* l.lbz $rD,${simm-16}($rA) */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (SIMM_16), '(', OP (RA), ')', 0 } },
-    & ifmt_l_lw, { 0x84000000 }
-  },
-/* l.lbs $rD,${simm-16}($rA) */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (SIMM_16), '(', OP (RA), ')', 0 } },
-    & ifmt_l_lw, { 0x88000000 }
-  },
-/* l.lhz $rD,${simm-16}($rA) */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (SIMM_16), '(', OP (RA), ')', 0 } },
-    & ifmt_l_lw, { 0x8c000000 }
-  },
-/* l.lhs $rD,${simm-16}($rA) */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (SIMM_16), '(', OP (RA), ')', 0 } },
-    & ifmt_l_lw, { 0x90000000 }
-  },
-/* l.sw ${ui16nc}($rA),$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (UI16NC), '(', OP (RA), ')', ',', OP (RB), 0 } },
-    & ifmt_l_sw, { 0xd4000000 }
-  },
-/* l.sb ${ui16nc}($rA),$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (UI16NC), '(', OP (RA), ')', ',', OP (RB), 0 } },
-    & ifmt_l_sw, { 0xd8000000 }
-  },
-/* l.sh ${ui16nc}($rA),$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (UI16NC), '(', OP (RA), ')', ',', OP (RB), 0 } },
-    & ifmt_l_sw, { 0xdc000000 }
-  },
-/* l.sll $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sll, { 0xe0000008 }
-  },
-/* l.slli $rD,$rA,${uimm-5} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM_5), 0 } },
-    & ifmt_l_slli, { 0xb4000000 }
-  },
-/* l.srl $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sll, { 0xe0000028 }
-  },
-/* l.srli $rD,$rA,${uimm-5} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM_5), 0 } },
-    & ifmt_l_slli, { 0xb4000020 }
-  },
-/* l.sra $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sll, { 0xe0000048 }
-  },
-/* l.srai $rD,$rA,${uimm-5} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM_5), 0 } },
-    & ifmt_l_slli, { 0xb4000040 }
-  },
-/* l.ror $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sll, { 0xe0000088 }
-  },
-/* l.rori $rD,$rA,${uimm-5} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM_5), 0 } },
-    & ifmt_l_slli, { 0xb4000080 }
-  },
-/* l.add $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000000 }
-  },
-/* l.addi $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0x94000000 }
-  },
-/* l.sub $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000002 }
-  },
-/* l.subi $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0x9c000000 }
-  },
-/* l.and $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000003 }
-  },
-/* l.andi $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0xa0000000 }
-  },
-/* l.or $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000004 }
-  },
-/* l.ori $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0xa4000000 }
-  },
-/* l.xor $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000005 }
-  },
-/* l.xori $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0xa8000000 }
-  },
-/* l.mul $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000006 }
-  },
-/* l.muli $rD,$rA,$lo16 */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (LO16), 0 } },
-    & ifmt_l_addi, { 0xac000000 }
-  },
-/* l.div $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe0000009 }
-  },
-/* l.divu $rD,$rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_add, { 0xe000000a }
-  },
-/* l.sfgts $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4c00000 }
-  },
-/* l.sfgtu $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4400000 }
-  },
-/* l.sfges $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4e00000 }
-  },
-/* l.sfgeu $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4600000 }
-  },
-/* l.sflts $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe5000000 }
-  },
-/* l.sfltu $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4800000 }
-  },
-/* l.sfles $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe5200000 }
-  },
-/* l.sfleu $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4a00000 }
-  },
-/* l.sfgtsi $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb8c00000 }
-  },
-/* l.sfgtui $rA,${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (UIMM_16), 0 } },
-    & ifmt_l_sfgtui, { 0xb8400000 }
-  },
-/* l.sfgesi $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb8e00000 }
-  },
-/* l.sfgeui $rA,${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (UIMM_16), 0 } },
-    & ifmt_l_sfgtui, { 0xb8600000 }
-  },
-/* l.sfltsi $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb9000000 }
-  },
-/* l.sfltui $rA,${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (UIMM_16), 0 } },
-    & ifmt_l_sfgtui, { 0xb8800000 }
-  },
-/* l.sflesi $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb9200000 }
-  },
-/* l.sfleui $rA,${uimm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (UIMM_16), 0 } },
-    & ifmt_l_sfgtui, { 0xb8a00000 }
-  },
-/* l.sfeq $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4000000 }
-  },
-/* l.sfeqi $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb8000000 }
-  },
-/* l.sfne $rA,$rB */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
-    & ifmt_l_sfgts, { 0xe4200000 }
-  },
-/* l.sfnei $rA,${simm-16} */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, ' ', OP (RA), ',', OP (SIMM_16), 0 } },
-    & ifmt_l_sfgtsi, { 0xb8200000 }
-  },
-};
-
-#undef A
-#undef OPERAND
-#undef MNEM
-#undef OP
-
-/* Formats for ALIAS macro-insns.  */
-
-#define F(f) & openrisc_cgen_ifld_table[OPENRISC_##f]
-static const CGEN_IFMT ifmt_l_ret ATTRIBUTE_UNUSED = {
-  32, 32, 0xffffffff, { { F (F_CLASS) }, { F (F_SUB) }, { F (F_OP3) }, { F (F_OP4) }, { F (F_R2) }, { F (F_UIMM16) }, { 0 } }
-};
-
-#undef F
-
-/* Each non-simple macro entry points to an array of expansion possibilities.  */
-
-#define A(a) (1 << CGEN_INSN_##a)
-#define OPERAND(op) OPENRISC_OPERAND_##op
-#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
-#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
-
-/* The macro instruction table.  */
-
-static const CGEN_IBASE openrisc_cgen_macro_insn_table[] =
-{
-/* l.ret */
-  {
-    -1, "l-ret", "l.ret", 32,
-    { 0|A(ALIAS), { { { (1<<MACH_BASE), 0 } } } }
-  },
-};
-
-/* The macro instruction opcode table.  */
-
-static const CGEN_OPCODE openrisc_cgen_macro_insn_opcode_table[] =
-{
-/* l.ret */
-  {
-    { 0, 0, 0, 0 },
-    { { MNEM, 0 } },
-    & ifmt_l_ret, { 0x140b0000 }
-  },
-};
-
-#undef A
-#undef OPERAND
-#undef MNEM
-#undef OP
-
-#ifndef CGEN_ASM_HASH_P
-#define CGEN_ASM_HASH_P(insn) 1
-#endif
-
-#ifndef CGEN_DIS_HASH_P
-#define CGEN_DIS_HASH_P(insn) 1
-#endif
-
-/* Return non-zero if INSN is to be added to the hash table.
-   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */
-
-static int
-asm_hash_insn_p (insn)
-     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
-{
-  return CGEN_ASM_HASH_P (insn);
-}
-
-static int
-dis_hash_insn_p (insn)
-     const CGEN_INSN *insn;
-{
-  /* If building the hash table and the NO-DIS attribute is present,
-     ignore.  */
-  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
-    return 0;
-  return CGEN_DIS_HASH_P (insn);
-}
-
-#ifndef CGEN_ASM_HASH
-#define CGEN_ASM_HASH_SIZE 127
-#ifdef CGEN_MNEMONIC_OPERANDS
-#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
-#else
-#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
-#endif
-#endif
-
-/* It doesn't make much sense to provide a default here,
-   but while this is under development we do.
-   BUFFER is a pointer to the bytes of the insn, target order.
-   VALUE is the first base_insn_bitsize bits as an int in host order.  */
-
-#ifndef CGEN_DIS_HASH
-#define CGEN_DIS_HASH_SIZE 256
-#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))
-#endif
-
-/* The result is the hash value of the insn.
-   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */
-
-static unsigned int
-asm_hash_insn (mnem)
-     const char * mnem;
-{
-  return CGEN_ASM_HASH (mnem);
-}
-
-/* BUF is a pointer to the bytes of the insn, target order.
-   VALUE is the first base_insn_bitsize bits as an int in host order.  */
-
-static unsigned int
-dis_hash_insn (buf, value)
-     const char * buf ATTRIBUTE_UNUSED;
-     CGEN_INSN_INT value ATTRIBUTE_UNUSED;
-{
-  return CGEN_DIS_HASH (buf, value);
-}
-
-/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */
-
-static void
-set_fields_bitsize (CGEN_FIELDS *fields, int size)
-{
-  CGEN_FIELDS_BITSIZE (fields) = size;
-}
-
-/* Function to call before using the operand instance table.
-   This plugs the opcode entries and macro instructions into the cpu table.  */
-
-void
-openrisc_cgen_init_opcode_table (CGEN_CPU_DESC cd)
-{
-  int i;
-  int num_macros = (sizeof (openrisc_cgen_macro_insn_table) /
-		    sizeof (openrisc_cgen_macro_insn_table[0]));
-  const CGEN_IBASE *ib = & openrisc_cgen_macro_insn_table[0];
-  const CGEN_OPCODE *oc = & openrisc_cgen_macro_insn_opcode_table[0];
-  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
-
-  /* This test has been added to avoid a warning generated
-     if memset is called with a third argument of value zero.  */
-  if (num_macros >= 1)
-    memset (insns, 0, num_macros * sizeof (CGEN_INSN));
-  for (i = 0; i < num_macros; ++i)
-    {
-      insns[i].base = &ib[i];
-      insns[i].opcode = &oc[i];
-      openrisc_cgen_build_insn_regex (& insns[i]);
-    }
-  cd->macro_insn_table.init_entries = insns;
-  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
-  cd->macro_insn_table.num_init_entries = num_macros;
-
-  oc = & openrisc_cgen_insn_opcode_table[0];
-  insns = (CGEN_INSN *) cd->insn_table.init_entries;
-  for (i = 0; i < MAX_INSNS; ++i)
-    {
-      insns[i].opcode = &oc[i];
-      openrisc_cgen_build_insn_regex (& insns[i]);
-    }
-
-  cd->sizeof_fields = sizeof (CGEN_FIELDS);
-  cd->set_fields_bitsize = set_fields_bitsize;
-
-  cd->asm_hash_p = asm_hash_insn_p;
-  cd->asm_hash = asm_hash_insn;
-  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;
-
-  cd->dis_hash_p = dis_hash_insn_p;
-  cd->dis_hash = dis_hash_insn;
-  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
-}
--- a/opcodes/openrisc-opc.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Instruction opcode header for openrisc.
-
-THIS FILE IS MACHINE GENERATED WITH CGEN.
-
-Copyright 1996-2010 Free Software Foundation, Inc.
-
-This file is part of the GNU Binutils and/or GDB, the GNU debugger.
-
-   This file is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License along
-   with this program; if not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
-
-*/
-
-#ifndef OPENRISC_OPC_H
-#define OPENRISC_OPC_H
-
-/* -- opc.h */
-#undef  CGEN_DIS_HASH_SIZE
-#define CGEN_DIS_HASH_SIZE 64
-#undef  CGEN_DIS_HASH
-#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)
-
-extern long openrisc_sign_extend_16bit (long);
-/* -- */
-/* Enum declaration for openrisc instruction types.  */
-typedef enum cgen_insn_type {
-  OPENRISC_INSN_INVALID, OPENRISC_INSN_L_J, OPENRISC_INSN_L_JAL, OPENRISC_INSN_L_JR
- , OPENRISC_INSN_L_JALR, OPENRISC_INSN_L_BAL, OPENRISC_INSN_L_BNF, OPENRISC_INSN_L_BF
- , OPENRISC_INSN_L_BRK, OPENRISC_INSN_L_RFE, OPENRISC_INSN_L_SYS, OPENRISC_INSN_L_NOP
- , OPENRISC_INSN_L_MOVHI, OPENRISC_INSN_L_MFSR, OPENRISC_INSN_L_MTSR, OPENRISC_INSN_L_LW
- , OPENRISC_INSN_L_LBZ, OPENRISC_INSN_L_LBS, OPENRISC_INSN_L_LHZ, OPENRISC_INSN_L_LHS
- , OPENRISC_INSN_L_SW, OPENRISC_INSN_L_SB, OPENRISC_INSN_L_SH, OPENRISC_INSN_L_SLL
- , OPENRISC_INSN_L_SLLI, OPENRISC_INSN_L_SRL, OPENRISC_INSN_L_SRLI, OPENRISC_INSN_L_SRA
- , OPENRISC_INSN_L_SRAI, OPENRISC_INSN_L_ROR, OPENRISC_INSN_L_RORI, OPENRISC_INSN_L_ADD
- , OPENRISC_INSN_L_ADDI, OPENRISC_INSN_L_SUB, OPENRISC_INSN_L_SUBI, OPENRISC_INSN_L_AND
- , OPENRISC_INSN_L_ANDI, OPENRISC_INSN_L_OR, OPENRISC_INSN_L_ORI, OPENRISC_INSN_L_XOR
- , OPENRISC_INSN_L_XORI, OPENRISC_INSN_L_MUL, OPENRISC_INSN_L_MULI, OPENRISC_INSN_L_DIV
- , OPENRISC_INSN_L_DIVU, OPENRISC_INSN_L_SFGTS, OPENRISC_INSN_L_SFGTU, OPENRISC_INSN_L_SFGES
- , OPENRISC_INSN_L_SFGEU, OPENRISC_INSN_L_SFLTS, OPENRISC_INSN_L_SFLTU, OPENRISC_INSN_L_SFLES
- , OPENRISC_INSN_L_SFLEU, OPENRISC_INSN_L_SFGTSI, OPENRISC_INSN_L_SFGTUI, OPENRISC_INSN_L_SFGESI
- , OPENRISC_INSN_L_SFGEUI, OPENRISC_INSN_L_SFLTSI, OPENRISC_INSN_L_SFLTUI, OPENRISC_INSN_L_SFLESI
- , OPENRISC_INSN_L_SFLEUI, OPENRISC_INSN_L_SFEQ, OPENRISC_INSN_L_SFEQI, OPENRISC_INSN_L_SFNE
- , OPENRISC_INSN_L_SFNEI
-} CGEN_INSN_TYPE;
-
-/* Index of `invalid' insn place holder.  */
-#define CGEN_INSN_INVALID OPENRISC_INSN_INVALID
-
-/* Total number of insns in table.  */
-#define MAX_INSNS ((int) OPENRISC_INSN_L_SFNEI + 1)
-
-/* This struct records data prior to insertion or after extraction.  */
-struct cgen_fields
-{
-  int length;
-  long f_nil;
-  long f_anyof;
-  long f_class;
-  long f_sub;
-  long f_r1;
-  long f_r2;
-  long f_r3;
-  long f_simm16;
-  long f_uimm16;
-  long f_uimm5;
-  long f_hi16;
-  long f_lo16;
-  long f_op1;
-  long f_op2;
-  long f_op3;
-  long f_op4;
-  long f_op5;
-  long f_op6;
-  long f_op7;
-  long f_i16_1;
-  long f_i16_2;
-  long f_disp26;
-  long f_abs26;
-  long f_i16nc;
-  long f_f_15_8;
-  long f_f_10_3;
-  long f_f_4_1;
-  long f_f_7_3;
-  long f_f_10_7;
-  long f_f_10_11;
-};
-
-#define CGEN_INIT_PARSE(od) \
-{\
-}
-#define CGEN_INIT_INSERT(od) \
-{\
-}
-#define CGEN_INIT_EXTRACT(od) \
-{\
-}
-#define CGEN_INIT_PRINT(od) \
-{\
-}
-
-
-#endif /* OPENRISC_OPC_H */
--- /dev/null
+++ b/opcodes/or1k-asm.c
@@ -0,0 +1,912 @@
+/* Assembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-asm.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2007, 2008, 2010
+   Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+#include "opintl.h"
+#include "xregex.h"
+#include "libiberty.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+static const char * parse_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, const char **, CGEN_FIELDS *);
+
+/* -- assembler routines inserted here.  */
+
+/* -- asm.c */
+
+static const char * MISSING_CLOSING_PARENTHESIS = N_("missing `)'");
+
+#define CGEN_VERBOSE_ASSEMBLER_ERRORS
+
+static const char *
+parse_disp26 (CGEN_CPU_DESC cd,
+              const char ** strp,
+              int opindex,
+              int opinfo,
+              enum cgen_parse_operand_result * resultp,
+              bfd_vma * valuep)
+{
+  const char *errmsg = NULL;
+  enum cgen_parse_operand_result result_type;
+
+  if (strncasecmp (*strp, "plt(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_OR1K_PLT26,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 2) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  return cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep);
+}
+
+static const char *
+parse_simm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, long * valuep)
+{
+  const char *errmsg;
+  enum cgen_parse_operand_result result_type;
+  long ret;
+
+  if (**strp == '#')
+    ++*strp;
+
+  if (strncasecmp (*strp, "hi(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
+        			   & result_type, & value);
+      if (**strp != ')')
+        errmsg = MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      
+      ret = value;
+      
+      if (errmsg == NULL &&
+          result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER) {
+        ret >>= 16;
+        ret &= 0xffff;
+        ret = (ret ^ 0x8000) - 0x8000;
+      }
+    }
+  else if (strncasecmp (*strp, "lo(", 3) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 3;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
+        			   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      
+      ret = value;
+
+      if (result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER) {
+        ret &= 0xffff;
+        ret = (ret ^ 0x8000) - 0x8000;
+      }
+      
+    }
+  else if (strncasecmp (*strp, "got(", 4) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 4;
+      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_OR1K_GOT16,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotpchi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTPC_HI16,
+                                   & result_type, & value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotpclo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTPC_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotoffhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTOFF_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gotofflo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_GOTOFF_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsgdhi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_GD_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsgdlo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_GD_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsldmhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDM_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tlsldmlo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDM_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "dtpoffhi(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDO_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "dtpofflo(", 9) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 9;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LDO_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gottpoffhi(", 11) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 11;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_IE_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "gottpofflo(", 11) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 11;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_IE_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tpoffhi(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LE_HI16,
+                                   & result_type, & value);
+
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value = (value >> 16) & 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else if (strncasecmp (*strp, "tpofflo(", 8) == 0)
+    {
+      bfd_vma value;
+
+      *strp += 8;
+      errmsg = cgen_parse_address (cd, strp, opindex,
+                                   BFD_RELOC_OR1K_TLS_LE_LO16,
+                                   &result_type, &value);
+      if (**strp != ')')
+        return MISSING_CLOSING_PARENTHESIS;
+      ++*strp;
+      if (errmsg == NULL
+          && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
+        value &= 0xffff;
+      *valuep = value;
+      return errmsg;
+    }
+  else
+    {
+      long value;
+      errmsg = cgen_parse_signed_integer (cd, strp, opindex, &value);
+      ret = value;
+    }
+  
+  if (errmsg == NULL) {
+
+    *valuep = ret;
+
+  }
+
+  return errmsg;
+}
+
+static const char *
+parse_uimm16 (CGEN_CPU_DESC cd, const char ** strp, int opindex, unsigned long * valuep)
+{
+  const char *errmsg = parse_simm16(cd, strp, opindex, (long *) valuep);
+  if (errmsg == NULL)
+    *valuep &= 0xffff;
+  return errmsg;
+}
+
+/* -- */
+
+const char * or1k_cgen_parse_operand
+  (CGEN_CPU_DESC, int, const char **, CGEN_FIELDS *);
+
+/* Main entry point for operand parsing.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  */
+
+const char *
+or1k_cgen_parse_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   const char ** strp,
+			   CGEN_FIELDS * fields)
+{
+  const char * errmsg = NULL;
+  /* Used by scalar operands that still need to be parsed.  */
+  long junk ATTRIBUTE_UNUSED;
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      {
+        bfd_vma value = 0;
+        errmsg = parse_disp26 (cd, strp, OR1K_OPERAND_DISP26, 0, NULL,  & value);
+        fields->f_disp26 = value;
+      }
+      break;
+    case OR1K_OPERAND_RA :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_gpr, & fields->f_r2);
+      break;
+    case OR1K_OPERAND_RADF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fdr, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RASF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fsr, & fields->f_r2);
+      break;
+    case OR1K_OPERAND_RB :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_gpr, & fields->f_r3);
+      break;
+    case OR1K_OPERAND_RBDF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fdr, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RBSF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fsr, & fields->f_r3);
+      break;
+    case OR1K_OPERAND_RD :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_gpr, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RDDF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fdr, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RDSF :
+      errmsg = cgen_parse_keyword (cd, strp, & or1k_cgen_opval_h_fsr, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16, (long *) (& fields->f_simm16));
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      errmsg = parse_simm16 (cd, strp, OR1K_OPERAND_SIMM16_SPLIT, (long *) (& fields->f_simm16_split));
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16, (unsigned long *) (& fields->f_uimm16));
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      errmsg = parse_uimm16 (cd, strp, OR1K_OPERAND_UIMM16_SPLIT, (unsigned long *) (& fields->f_uimm16_split));
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      errmsg = cgen_parse_unsigned_integer (cd, strp, OR1K_OPERAND_UIMM6, (unsigned long *) (& fields->f_uimm6));
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while parsing.\n"), opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+cgen_parse_fn * const or1k_cgen_parse_handlers[] = 
+{
+  parse_insn_normal,
+};
+
+void
+or1k_cgen_init_asm (CGEN_CPU_DESC cd)
+{
+  or1k_cgen_init_opcode_table (cd);
+  or1k_cgen_init_ibld_table (cd);
+  cd->parse_handlers = & or1k_cgen_parse_handlers[0];
+  cd->parse_operand = or1k_cgen_parse_operand;
+#ifdef CGEN_ASM_INIT_HOOK
+CGEN_ASM_INIT_HOOK
+#endif
+}
+
+
+
+/* Regex construction routine.
+
+   This translates an opcode syntax string into a regex string,
+   by replacing any non-character syntax element (such as an
+   opcode) with the pattern '.*'
+
+   It then compiles the regex and stores it in the opcode, for
+   later use by or1k_cgen_assemble_insn
+
+   Returns NULL for success, an error message for failure.  */
+
+char * 
+or1k_cgen_build_insn_regex (CGEN_INSN *insn)
+{  
+  CGEN_OPCODE *opc = (CGEN_OPCODE *) CGEN_INSN_OPCODE (insn);
+  const char *mnem = CGEN_INSN_MNEMONIC (insn);
+  char rxbuf[CGEN_MAX_RX_ELEMENTS];
+  char *rx = rxbuf;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+  int reg_err;
+
+  syn = CGEN_SYNTAX_STRING (CGEN_OPCODE_SYNTAX (opc));
+
+  /* Mnemonics come first in the syntax string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    return _("missing mnemonic in syntax string");
+  ++syn;
+
+  /* Generate a case sensitive regular expression that emulates case
+     insensitive matching in the "C" locale.  We cannot generate a case
+     insensitive regular expression because in Turkish locales, 'i' and 'I'
+     are not equal modulo case conversion.  */
+
+  /* Copy the literal mnemonic out of the insn.  */
+  for (; *mnem; mnem++)
+    {
+      char c = *mnem;
+
+      if (ISALPHA (c))
+	{
+	  *rx++ = '[';
+	  *rx++ = TOLOWER (c);
+	  *rx++ = TOUPPER (c);
+	  *rx++ = ']';
+	}
+      else
+	*rx++ = c;
+    }
+
+  /* Copy any remaining literals from the syntax string into the rx.  */
+  for(; * syn != 0 && rx <= rxbuf + (CGEN_MAX_RX_ELEMENTS - 7 - 4); ++syn)
+    {
+      if (CGEN_SYNTAX_CHAR_P (* syn)) 
+	{
+	  char c = CGEN_SYNTAX_CHAR (* syn);
+
+	  switch (c) 
+	    {
+	      /* Escape any regex metacharacters in the syntax.  */
+	    case '.': case '[': case '\\': 
+	    case '*': case '^': case '$': 
+
+#ifdef CGEN_ESCAPE_EXTENDED_REGEX
+	    case '?': case '{': case '}': 
+	    case '(': case ')': case '*':
+	    case '|': case '+': case ']':
+#endif
+	      *rx++ = '\\';
+	      *rx++ = c;
+	      break;
+
+	    default:
+	      if (ISALPHA (c))
+		{
+		  *rx++ = '[';
+		  *rx++ = TOLOWER (c);
+		  *rx++ = TOUPPER (c);
+		  *rx++ = ']';
+		}
+	      else
+		*rx++ = c;
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Replace non-syntax fields with globs.  */
+	  *rx++ = '.';
+	  *rx++ = '*';
+	}
+    }
+
+  /* Trailing whitespace ok.  */
+  * rx++ = '['; 
+  * rx++ = ' '; 
+  * rx++ = '\t'; 
+  * rx++ = ']'; 
+  * rx++ = '*'; 
+
+  /* But anchor it after that.  */
+  * rx++ = '$'; 
+  * rx = '\0';
+
+  CGEN_INSN_RX (insn) = xmalloc (sizeof (regex_t));
+  reg_err = regcomp ((regex_t *) CGEN_INSN_RX (insn), rxbuf, REG_NOSUB);
+
+  if (reg_err == 0) 
+    return NULL;
+  else
+    {
+      static char msg[80];
+
+      regerror (reg_err, (regex_t *) CGEN_INSN_RX (insn), msg, 80);
+      regfree ((regex_t *) CGEN_INSN_RX (insn));
+      free (CGEN_INSN_RX (insn));
+      (CGEN_INSN_RX (insn)) = NULL;
+      return msg;
+    }
+}
+
+
+/* Default insn parser.
+
+   The syntax string is scanned and operands are parsed and stored in FIELDS.
+   Relocs are queued as we go via other callbacks.
+
+   ??? Note that this is currently an all-or-nothing parser.  If we fail to
+   parse the instruction, we return 0 and the caller will start over from
+   the beginning.  Backtracking will be necessary in parsing subexpressions,
+   but that can be handled there.  Not handling backtracking here may get
+   expensive in the case of the m68k.  Deal with later.
+
+   Returns NULL for success, an error message for failure.  */
+
+static const char *
+parse_insn_normal (CGEN_CPU_DESC cd,
+		   const CGEN_INSN *insn,
+		   const char **strp,
+		   CGEN_FIELDS *fields)
+{
+  /* ??? Runtime added insns not handled yet.  */
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const char *str = *strp;
+  const char *errmsg;
+  const char *p;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+#ifdef CGEN_MNEMONIC_OPERANDS
+  /* FIXME: wip */
+  int past_opcode_p;
+#endif
+
+  /* For now we assume the mnemonic is first (there are no leading operands).
+     We can parse it without needing to set up operand parsing.
+     GAS's input scrubber will ensure mnemonics are lowercase, but we may
+     not be called from GAS.  */
+  p = CGEN_INSN_MNEMONIC (insn);
+  while (*p && TOLOWER (*p) == TOLOWER (*str))
+    ++p, ++str;
+
+  if (* p)
+    return _("unrecognized instruction");
+
+#ifndef CGEN_MNEMONIC_OPERANDS
+  if (* str && ! ISSPACE (* str))
+    return _("unrecognized instruction");
+#endif
+
+  CGEN_INIT_PARSE (cd);
+  cgen_init_parse_operand (cd);
+#ifdef CGEN_MNEMONIC_OPERANDS
+  past_opcode_p = 0;
+#endif
+
+  /* We don't check for (*str != '\0') here because we want to parse
+     any trailing fake arguments in the syntax string.  */
+  syn = CGEN_SYNTAX_STRING (syntax);
+
+  /* Mnemonics come first for now, ensure valid string.  */
+  if (! CGEN_SYNTAX_MNEMONIC_P (* syn))
+    abort ();
+
+  ++syn;
+
+  while (* syn != 0)
+    {
+      /* Non operand chars must match exactly.  */
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	{
+	  /* FIXME: While we allow for non-GAS callers above, we assume the
+	     first char after the mnemonic part is a space.  */
+	  /* FIXME: We also take inappropriate advantage of the fact that
+	     GAS's input scrubber will remove extraneous blanks.  */
+	  if (TOLOWER (*str) == TOLOWER (CGEN_SYNTAX_CHAR (* syn)))
+	    {
+#ifdef CGEN_MNEMONIC_OPERANDS
+	      if (CGEN_SYNTAX_CHAR(* syn) == ' ')
+		past_opcode_p = 1;
+#endif
+	      ++ syn;
+	      ++ str;
+	    }
+	  else if (*str)
+	    {
+	      /* Syntax char didn't match.  Can't be this insn.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found `%c')"),
+		       CGEN_SYNTAX_CHAR(*syn), *str);
+	      return msg;
+	    }
+	  else
+	    {
+	      /* Ran out of input.  */
+	      static char msg [80];
+
+	      /* xgettext:c-format */
+	      sprintf (msg, _("syntax error (expected char `%c', found end of instruction)"),
+		       CGEN_SYNTAX_CHAR(*syn));
+	      return msg;
+	    }
+	  continue;
+	}
+
+#ifdef CGEN_MNEMONIC_OPERANDS
+      (void) past_opcode_p;
+#endif
+      /* We have an operand of some sort.  */
+      errmsg = cd->parse_operand (cd, CGEN_SYNTAX_FIELD (*syn), &str, fields);
+      if (errmsg)
+	return errmsg;
+
+      /* Done with this operand, continue with next one.  */
+      ++ syn;
+    }
+
+  /* If we're at the end of the syntax string, we're done.  */
+  if (* syn == 0)
+    {
+      /* FIXME: For the moment we assume a valid `str' can only contain
+	 blanks now.  IE: We needn't try again with a longer version of
+	 the insn and it is assumed that longer versions of insns appear
+	 before shorter ones (eg: lsr r2,r3,1 vs lsr r2,r3).  */
+      while (ISSPACE (* str))
+	++ str;
+
+      if (* str != '\0')
+	return _("junk at end of line"); /* FIXME: would like to include `str' */
+
+      return NULL;
+    }
+
+  /* We couldn't parse it.  */
+  return _("unrecognized instruction");
+}
+
+/* Main entry point.
+   This routine is called for each instruction to be assembled.
+   STR points to the insn to be assembled.
+   We assume all necessary tables have been initialized.
+   The assembled instruction, less any fixups, is stored in BUF.
+   Remember that if CGEN_INT_INSN_P then BUF is an int and thus the value
+   still needs to be converted to target byte order, otherwise BUF is an array
+   of bytes in target byte order.
+   The result is a pointer to the insn's entry in the opcode table,
+   or NULL if an error occured (an error message will have already been
+   printed).
+
+   Note that when processing (non-alias) macro-insns,
+   this function recurses.
+
+   ??? It's possible to make this cpu-independent.
+   One would have to deal with a few minor things.
+   At this point in time doing so would be more of a curiosity than useful
+   [for example this file isn't _that_ big], but keeping the possibility in
+   mind helps keep the design clean.  */
+
+const CGEN_INSN *
+or1k_cgen_assemble_insn (CGEN_CPU_DESC cd,
+			   const char *str,
+			   CGEN_FIELDS *fields,
+			   CGEN_INSN_BYTES_PTR buf,
+			   char **errmsg)
+{
+  const char *start;
+  CGEN_INSN_LIST *ilist;
+  const char *parse_errmsg = NULL;
+  const char *insert_errmsg = NULL;
+  int recognized_mnemonic = 0;
+
+  /* Skip leading white space.  */
+  while (ISSPACE (* str))
+    ++ str;
+
+  /* The instructions are stored in hashed lists.
+     Get the first in the list.  */
+  ilist = CGEN_ASM_LOOKUP_INSN (cd, str);
+
+  /* Keep looking until we find a match.  */
+  start = str;
+  for ( ; ilist != NULL ; ilist = CGEN_ASM_NEXT_INSN (ilist))
+    {
+      const CGEN_INSN *insn = ilist->insn;
+      recognized_mnemonic = 1;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+      /* Not usually needed as unsupported opcodes
+	 shouldn't be in the hash lists.  */
+      /* Is this insn supported by the selected cpu?  */
+      if (! or1k_cgen_insn_supported (cd, insn))
+	continue;
+#endif
+      /* If the RELAXED attribute is set, this is an insn that shouldn't be
+	 chosen immediately.  Instead, it is used during assembler/linker
+	 relaxation if possible.  */
+      if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED) != 0)
+	continue;
+
+      str = start;
+
+      /* Skip this insn if str doesn't look right lexically.  */
+      if (CGEN_INSN_RX (insn) != NULL &&
+	  regexec ((regex_t *) CGEN_INSN_RX (insn), str, 0, NULL, 0) == REG_NOMATCH)
+	continue;
+
+      /* Allow parse/insert handlers to obtain length of insn.  */
+      CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+      parse_errmsg = CGEN_PARSE_FN (cd, insn) (cd, insn, & str, fields);
+      if (parse_errmsg != NULL)
+	continue;
+
+      /* ??? 0 is passed for `pc'.  */
+      insert_errmsg = CGEN_INSERT_FN (cd, insn) (cd, insn, fields, buf,
+						 (bfd_vma) 0);
+      if (insert_errmsg != NULL)
+        continue;
+
+      /* It is up to the caller to actually output the insn and any
+         queued relocs.  */
+      return insn;
+    }
+
+  {
+    static char errbuf[150];
+    const char *tmp_errmsg;
+#ifdef CGEN_VERBOSE_ASSEMBLER_ERRORS
+#define be_verbose 1
+#else
+#define be_verbose 0
+#endif
+
+    if (be_verbose)
+      {
+	/* If requesting verbose error messages, use insert_errmsg.
+	   Failing that, use parse_errmsg.  */
+	tmp_errmsg = (insert_errmsg ? insert_errmsg :
+		      parse_errmsg ? parse_errmsg :
+		      recognized_mnemonic ?
+		      _("unrecognized form of instruction") :
+		      _("unrecognized instruction"));
+
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s...'", tmp_errmsg, start);
+	else 
+	  /* xgettext:c-format */
+	  sprintf (errbuf, "%s `%.50s'", tmp_errmsg, start);
+      }
+    else
+      {
+	if (strlen (start) > 50)
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s...'"), start);
+	else 
+	  /* xgettext:c-format */
+	  sprintf (errbuf, _("bad instruction `%.50s'"), start);
+      }
+      
+    *errmsg = errbuf;
+    return NULL;
+  }
+}
--- /dev/null
+++ b/opcodes/or1k-desc.c
@@ -0,0 +1,2074 @@
+/* CPU data for or1k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2010 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include <stdio.h>
+#include <stdarg.h>
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+#include "opintl.h"
+#include "libiberty.h"
+#include "xregex.h"
+
+/* Attributes.  */
+
+static const CGEN_ATTR_ENTRY bool_attr[] =
+{
+  { "#f", 0 },
+  { "#t", 1 },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY MACH_attr[] ATTRIBUTE_UNUSED =
+{
+  { "base", MACH_BASE },
+  { "or32", MACH_OR32 },
+  { "or32nd", MACH_OR32ND },
+  { "or64", MACH_OR64 },
+  { "or64nd", MACH_OR64ND },
+  { "max", MACH_MAX },
+  { 0, 0 }
+};
+
+static const CGEN_ATTR_ENTRY ISA_attr[] ATTRIBUTE_UNUSED =
+{
+  { "openrisc", ISA_OPENRISC },
+  { "max", ISA_MAX },
+  { 0, 0 }
+};
+
+const CGEN_ATTR_TABLE or1k_cgen_ifield_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "RESERVED", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE or1k_cgen_hardware_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "CACHE-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "PC", &bool_attr[0], &bool_attr[0] },
+  { "PROFILE", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE or1k_cgen_operand_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "PCREL-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "ABS-ADDR", &bool_attr[0], &bool_attr[0] },
+  { "SIGN-OPT", &bool_attr[0], &bool_attr[0] },
+  { "SIGNED", &bool_attr[0], &bool_attr[0] },
+  { "NEGATIVE", &bool_attr[0], &bool_attr[0] },
+  { "RELAX", &bool_attr[0], &bool_attr[0] },
+  { "SEM-ONLY", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+const CGEN_ATTR_TABLE or1k_cgen_insn_attr_table[] =
+{
+  { "MACH", & MACH_attr[0], & MACH_attr[0] },
+  { "ALIAS", &bool_attr[0], &bool_attr[0] },
+  { "VIRTUAL", &bool_attr[0], &bool_attr[0] },
+  { "UNCOND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "COND-CTI", &bool_attr[0], &bool_attr[0] },
+  { "SKIP-CTI", &bool_attr[0], &bool_attr[0] },
+  { "DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
+  { "RELAXABLE", &bool_attr[0], &bool_attr[0] },
+  { "RELAXED", &bool_attr[0], &bool_attr[0] },
+  { "NO-DIS", &bool_attr[0], &bool_attr[0] },
+  { "PBB", &bool_attr[0], &bool_attr[0] },
+  { "DELAYED-CTI", &bool_attr[0], &bool_attr[0] },
+  { "NOT-IN-DELAY-SLOT", &bool_attr[0], &bool_attr[0] },
+  { "FORCED-CTI", &bool_attr[0], &bool_attr[0] },
+  { 0, 0, 0 }
+};
+
+/* Instruction set variants.  */
+
+static const CGEN_ISA or1k_cgen_isa_table[] = {
+  { "openrisc", 32, 32, 32, 32 },
+  { 0, 0, 0, 0, 0 }
+};
+
+/* Machine variants.  */
+
+static const CGEN_MACH or1k_cgen_mach_table[] = {
+  { "or32", "or1k", MACH_OR32, 0 },
+  { "or32nd", "or1knd", MACH_OR32ND, 0 },
+  { "or64", "or1k64", MACH_OR64, 0 },
+  { "or64nd", "or1k64nd", MACH_OR64ND, 0 },
+  { 0, 0, 0, 0 }
+};
+
+static CGEN_KEYWORD_ENTRY or1k_cgen_opval_h_fsr_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "lr", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 2, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD or1k_cgen_opval_h_fsr =
+{
+  & or1k_cgen_opval_h_fsr_entries[0],
+  35,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY or1k_cgen_opval_h_fdr_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "lr", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 2, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD or1k_cgen_opval_h_fdr =
+{
+  & or1k_cgen_opval_h_fdr_entries[0],
+  35,
+  0, 0, 0, 0, ""
+};
+
+static CGEN_KEYWORD_ENTRY or1k_cgen_opval_h_gpr_entries[] =
+{
+  { "r0", 0, {0, {{{0, 0}}}}, 0, 0 },
+  { "r1", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "r2", 2, {0, {{{0, 0}}}}, 0, 0 },
+  { "r3", 3, {0, {{{0, 0}}}}, 0, 0 },
+  { "r4", 4, {0, {{{0, 0}}}}, 0, 0 },
+  { "r5", 5, {0, {{{0, 0}}}}, 0, 0 },
+  { "r6", 6, {0, {{{0, 0}}}}, 0, 0 },
+  { "r7", 7, {0, {{{0, 0}}}}, 0, 0 },
+  { "r8", 8, {0, {{{0, 0}}}}, 0, 0 },
+  { "r9", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "r10", 10, {0, {{{0, 0}}}}, 0, 0 },
+  { "r11", 11, {0, {{{0, 0}}}}, 0, 0 },
+  { "r12", 12, {0, {{{0, 0}}}}, 0, 0 },
+  { "r13", 13, {0, {{{0, 0}}}}, 0, 0 },
+  { "r14", 14, {0, {{{0, 0}}}}, 0, 0 },
+  { "r15", 15, {0, {{{0, 0}}}}, 0, 0 },
+  { "r16", 16, {0, {{{0, 0}}}}, 0, 0 },
+  { "r17", 17, {0, {{{0, 0}}}}, 0, 0 },
+  { "r18", 18, {0, {{{0, 0}}}}, 0, 0 },
+  { "r19", 19, {0, {{{0, 0}}}}, 0, 0 },
+  { "r20", 20, {0, {{{0, 0}}}}, 0, 0 },
+  { "r21", 21, {0, {{{0, 0}}}}, 0, 0 },
+  { "r22", 22, {0, {{{0, 0}}}}, 0, 0 },
+  { "r23", 23, {0, {{{0, 0}}}}, 0, 0 },
+  { "r24", 24, {0, {{{0, 0}}}}, 0, 0 },
+  { "r25", 25, {0, {{{0, 0}}}}, 0, 0 },
+  { "r26", 26, {0, {{{0, 0}}}}, 0, 0 },
+  { "r27", 27, {0, {{{0, 0}}}}, 0, 0 },
+  { "r28", 28, {0, {{{0, 0}}}}, 0, 0 },
+  { "r29", 29, {0, {{{0, 0}}}}, 0, 0 },
+  { "r30", 30, {0, {{{0, 0}}}}, 0, 0 },
+  { "r31", 31, {0, {{{0, 0}}}}, 0, 0 },
+  { "lr", 9, {0, {{{0, 0}}}}, 0, 0 },
+  { "sp", 1, {0, {{{0, 0}}}}, 0, 0 },
+  { "fp", 2, {0, {{{0, 0}}}}, 0, 0 }
+};
+
+CGEN_KEYWORD or1k_cgen_opval_h_gpr =
+{
+  & or1k_cgen_opval_h_gpr_entries[0],
+  35,
+  0, 0, 0, 0, ""
+};
+
+
+/* The hardware table.  */
+
+#define A(a) (1 << CGEN_HW_##a)
+
+const CGEN_HW_ENTRY or1k_cgen_hw_table[] =
+{
+  { "h-memory", HW_H_MEMORY, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-sint", HW_H_SINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uint", HW_H_UINT, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-addr", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-iaddr", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-pc", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PC), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-fsr", HW_H_FSR, CGEN_ASM_KEYWORD, (PTR) & or1k_cgen_opval_h_fsr, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-fdr", HW_H_FDR, CGEN_ASM_KEYWORD, (PTR) & or1k_cgen_opval_h_fdr, { 0|A(VIRTUAL), { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-spr", HW_H_SPR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-gpr", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & or1k_cgen_opval_h_gpr, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-vr", HW_H_SYS_VR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr", HW_H_SYS_UPR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr", HW_H_SYS_CPUCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-dmmucfgr", HW_H_SYS_DMMUCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-immucfgr", HW_H_SYS_IMMUCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-dccfgr", HW_H_SYS_DCCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-iccfgr", HW_H_SYS_ICCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-dcfgr", HW_H_SYS_DCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-pccfgr", HW_H_SYS_PCCFGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-npc", HW_H_SYS_NPC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr", HW_H_SYS_SR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-ppc", HW_H_SYS_PPC, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr", HW_H_SYS_FPCSR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr0", HW_H_SYS_EPCR0, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr1", HW_H_SYS_EPCR1, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr2", HW_H_SYS_EPCR2, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr3", HW_H_SYS_EPCR3, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr4", HW_H_SYS_EPCR4, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr5", HW_H_SYS_EPCR5, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr6", HW_H_SYS_EPCR6, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr7", HW_H_SYS_EPCR7, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr8", HW_H_SYS_EPCR8, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr9", HW_H_SYS_EPCR9, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr10", HW_H_SYS_EPCR10, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr11", HW_H_SYS_EPCR11, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr12", HW_H_SYS_EPCR12, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr13", HW_H_SYS_EPCR13, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr14", HW_H_SYS_EPCR14, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-epcr15", HW_H_SYS_EPCR15, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear0", HW_H_SYS_EEAR0, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear1", HW_H_SYS_EEAR1, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear2", HW_H_SYS_EEAR2, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear3", HW_H_SYS_EEAR3, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear4", HW_H_SYS_EEAR4, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear5", HW_H_SYS_EEAR5, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear6", HW_H_SYS_EEAR6, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear7", HW_H_SYS_EEAR7, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear8", HW_H_SYS_EEAR8, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear9", HW_H_SYS_EEAR9, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear10", HW_H_SYS_EEAR10, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear11", HW_H_SYS_EEAR11, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear12", HW_H_SYS_EEAR12, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear13", HW_H_SYS_EEAR13, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear14", HW_H_SYS_EEAR14, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-eear15", HW_H_SYS_EEAR15, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr0", HW_H_SYS_ESR0, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr1", HW_H_SYS_ESR1, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr2", HW_H_SYS_ESR2, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr3", HW_H_SYS_ESR3, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr4", HW_H_SYS_ESR4, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr5", HW_H_SYS_ESR5, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr6", HW_H_SYS_ESR6, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr7", HW_H_SYS_ESR7, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr8", HW_H_SYS_ESR8, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr9", HW_H_SYS_ESR9, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr10", HW_H_SYS_ESR10, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr11", HW_H_SYS_ESR11, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr12", HW_H_SYS_ESR12, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr13", HW_H_SYS_ESR13, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr14", HW_H_SYS_ESR14, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-esr15", HW_H_SYS_ESR15, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr0", HW_H_SYS_GPR0, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr1", HW_H_SYS_GPR1, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr2", HW_H_SYS_GPR2, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr3", HW_H_SYS_GPR3, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr4", HW_H_SYS_GPR4, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr5", HW_H_SYS_GPR5, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr6", HW_H_SYS_GPR6, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr7", HW_H_SYS_GPR7, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr8", HW_H_SYS_GPR8, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr9", HW_H_SYS_GPR9, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr10", HW_H_SYS_GPR10, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr11", HW_H_SYS_GPR11, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr12", HW_H_SYS_GPR12, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr13", HW_H_SYS_GPR13, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr14", HW_H_SYS_GPR14, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr15", HW_H_SYS_GPR15, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr16", HW_H_SYS_GPR16, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr17", HW_H_SYS_GPR17, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr18", HW_H_SYS_GPR18, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr19", HW_H_SYS_GPR19, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr20", HW_H_SYS_GPR20, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr21", HW_H_SYS_GPR21, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr22", HW_H_SYS_GPR22, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr23", HW_H_SYS_GPR23, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr24", HW_H_SYS_GPR24, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr25", HW_H_SYS_GPR25, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr26", HW_H_SYS_GPR26, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr27", HW_H_SYS_GPR27, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr28", HW_H_SYS_GPR28, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr29", HW_H_SYS_GPR29, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr30", HW_H_SYS_GPR30, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr31", HW_H_SYS_GPR31, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr32", HW_H_SYS_GPR32, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr33", HW_H_SYS_GPR33, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr34", HW_H_SYS_GPR34, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr35", HW_H_SYS_GPR35, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr36", HW_H_SYS_GPR36, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr37", HW_H_SYS_GPR37, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr38", HW_H_SYS_GPR38, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr39", HW_H_SYS_GPR39, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr40", HW_H_SYS_GPR40, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr41", HW_H_SYS_GPR41, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr42", HW_H_SYS_GPR42, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr43", HW_H_SYS_GPR43, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr44", HW_H_SYS_GPR44, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr45", HW_H_SYS_GPR45, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr46", HW_H_SYS_GPR46, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr47", HW_H_SYS_GPR47, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr48", HW_H_SYS_GPR48, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr49", HW_H_SYS_GPR49, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr50", HW_H_SYS_GPR50, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr51", HW_H_SYS_GPR51, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr52", HW_H_SYS_GPR52, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr53", HW_H_SYS_GPR53, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr54", HW_H_SYS_GPR54, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr55", HW_H_SYS_GPR55, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr56", HW_H_SYS_GPR56, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr57", HW_H_SYS_GPR57, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr58", HW_H_SYS_GPR58, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr59", HW_H_SYS_GPR59, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr60", HW_H_SYS_GPR60, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr61", HW_H_SYS_GPR61, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr62", HW_H_SYS_GPR62, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr63", HW_H_SYS_GPR63, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr64", HW_H_SYS_GPR64, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr65", HW_H_SYS_GPR65, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr66", HW_H_SYS_GPR66, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr67", HW_H_SYS_GPR67, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr68", HW_H_SYS_GPR68, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr69", HW_H_SYS_GPR69, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr70", HW_H_SYS_GPR70, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr71", HW_H_SYS_GPR71, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr72", HW_H_SYS_GPR72, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr73", HW_H_SYS_GPR73, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr74", HW_H_SYS_GPR74, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr75", HW_H_SYS_GPR75, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr76", HW_H_SYS_GPR76, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr77", HW_H_SYS_GPR77, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr78", HW_H_SYS_GPR78, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr79", HW_H_SYS_GPR79, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr80", HW_H_SYS_GPR80, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr81", HW_H_SYS_GPR81, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr82", HW_H_SYS_GPR82, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr83", HW_H_SYS_GPR83, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr84", HW_H_SYS_GPR84, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr85", HW_H_SYS_GPR85, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr86", HW_H_SYS_GPR86, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr87", HW_H_SYS_GPR87, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr88", HW_H_SYS_GPR88, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr89", HW_H_SYS_GPR89, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr90", HW_H_SYS_GPR90, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr91", HW_H_SYS_GPR91, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr92", HW_H_SYS_GPR92, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr93", HW_H_SYS_GPR93, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr94", HW_H_SYS_GPR94, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr95", HW_H_SYS_GPR95, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr96", HW_H_SYS_GPR96, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr97", HW_H_SYS_GPR97, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr98", HW_H_SYS_GPR98, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr99", HW_H_SYS_GPR99, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr100", HW_H_SYS_GPR100, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr101", HW_H_SYS_GPR101, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr102", HW_H_SYS_GPR102, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr103", HW_H_SYS_GPR103, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr104", HW_H_SYS_GPR104, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr105", HW_H_SYS_GPR105, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr106", HW_H_SYS_GPR106, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr107", HW_H_SYS_GPR107, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr108", HW_H_SYS_GPR108, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr109", HW_H_SYS_GPR109, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr110", HW_H_SYS_GPR110, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr111", HW_H_SYS_GPR111, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr112", HW_H_SYS_GPR112, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr113", HW_H_SYS_GPR113, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr114", HW_H_SYS_GPR114, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr115", HW_H_SYS_GPR115, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr116", HW_H_SYS_GPR116, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr117", HW_H_SYS_GPR117, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr118", HW_H_SYS_GPR118, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr119", HW_H_SYS_GPR119, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr120", HW_H_SYS_GPR120, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr121", HW_H_SYS_GPR121, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr122", HW_H_SYS_GPR122, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr123", HW_H_SYS_GPR123, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr124", HW_H_SYS_GPR124, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr125", HW_H_SYS_GPR125, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr126", HW_H_SYS_GPR126, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr127", HW_H_SYS_GPR127, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr128", HW_H_SYS_GPR128, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr129", HW_H_SYS_GPR129, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr130", HW_H_SYS_GPR130, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr131", HW_H_SYS_GPR131, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr132", HW_H_SYS_GPR132, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr133", HW_H_SYS_GPR133, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr134", HW_H_SYS_GPR134, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr135", HW_H_SYS_GPR135, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr136", HW_H_SYS_GPR136, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr137", HW_H_SYS_GPR137, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr138", HW_H_SYS_GPR138, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr139", HW_H_SYS_GPR139, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr140", HW_H_SYS_GPR140, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr141", HW_H_SYS_GPR141, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr142", HW_H_SYS_GPR142, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr143", HW_H_SYS_GPR143, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr144", HW_H_SYS_GPR144, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr145", HW_H_SYS_GPR145, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr146", HW_H_SYS_GPR146, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr147", HW_H_SYS_GPR147, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr148", HW_H_SYS_GPR148, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr149", HW_H_SYS_GPR149, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr150", HW_H_SYS_GPR150, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr151", HW_H_SYS_GPR151, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr152", HW_H_SYS_GPR152, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr153", HW_H_SYS_GPR153, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr154", HW_H_SYS_GPR154, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr155", HW_H_SYS_GPR155, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr156", HW_H_SYS_GPR156, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr157", HW_H_SYS_GPR157, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr158", HW_H_SYS_GPR158, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr159", HW_H_SYS_GPR159, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr160", HW_H_SYS_GPR160, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr161", HW_H_SYS_GPR161, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr162", HW_H_SYS_GPR162, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr163", HW_H_SYS_GPR163, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr164", HW_H_SYS_GPR164, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr165", HW_H_SYS_GPR165, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr166", HW_H_SYS_GPR166, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr167", HW_H_SYS_GPR167, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr168", HW_H_SYS_GPR168, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr169", HW_H_SYS_GPR169, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr170", HW_H_SYS_GPR170, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr171", HW_H_SYS_GPR171, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr172", HW_H_SYS_GPR172, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr173", HW_H_SYS_GPR173, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr174", HW_H_SYS_GPR174, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr175", HW_H_SYS_GPR175, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr176", HW_H_SYS_GPR176, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr177", HW_H_SYS_GPR177, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr178", HW_H_SYS_GPR178, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr179", HW_H_SYS_GPR179, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr180", HW_H_SYS_GPR180, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr181", HW_H_SYS_GPR181, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr182", HW_H_SYS_GPR182, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr183", HW_H_SYS_GPR183, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr184", HW_H_SYS_GPR184, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr185", HW_H_SYS_GPR185, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr186", HW_H_SYS_GPR186, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr187", HW_H_SYS_GPR187, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr188", HW_H_SYS_GPR188, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr189", HW_H_SYS_GPR189, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr190", HW_H_SYS_GPR190, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr191", HW_H_SYS_GPR191, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr192", HW_H_SYS_GPR192, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr193", HW_H_SYS_GPR193, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr194", HW_H_SYS_GPR194, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr195", HW_H_SYS_GPR195, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr196", HW_H_SYS_GPR196, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr197", HW_H_SYS_GPR197, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr198", HW_H_SYS_GPR198, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr199", HW_H_SYS_GPR199, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr200", HW_H_SYS_GPR200, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr201", HW_H_SYS_GPR201, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr202", HW_H_SYS_GPR202, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr203", HW_H_SYS_GPR203, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr204", HW_H_SYS_GPR204, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr205", HW_H_SYS_GPR205, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr206", HW_H_SYS_GPR206, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr207", HW_H_SYS_GPR207, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr208", HW_H_SYS_GPR208, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr209", HW_H_SYS_GPR209, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr210", HW_H_SYS_GPR210, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr211", HW_H_SYS_GPR211, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr212", HW_H_SYS_GPR212, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr213", HW_H_SYS_GPR213, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr214", HW_H_SYS_GPR214, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr215", HW_H_SYS_GPR215, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr216", HW_H_SYS_GPR216, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr217", HW_H_SYS_GPR217, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr218", HW_H_SYS_GPR218, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr219", HW_H_SYS_GPR219, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr220", HW_H_SYS_GPR220, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr221", HW_H_SYS_GPR221, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr222", HW_H_SYS_GPR222, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr223", HW_H_SYS_GPR223, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr224", HW_H_SYS_GPR224, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr225", HW_H_SYS_GPR225, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr226", HW_H_SYS_GPR226, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr227", HW_H_SYS_GPR227, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr228", HW_H_SYS_GPR228, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr229", HW_H_SYS_GPR229, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr230", HW_H_SYS_GPR230, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr231", HW_H_SYS_GPR231, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr232", HW_H_SYS_GPR232, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr233", HW_H_SYS_GPR233, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr234", HW_H_SYS_GPR234, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr235", HW_H_SYS_GPR235, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr236", HW_H_SYS_GPR236, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr237", HW_H_SYS_GPR237, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr238", HW_H_SYS_GPR238, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr239", HW_H_SYS_GPR239, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr240", HW_H_SYS_GPR240, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr241", HW_H_SYS_GPR241, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr242", HW_H_SYS_GPR242, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr243", HW_H_SYS_GPR243, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr244", HW_H_SYS_GPR244, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr245", HW_H_SYS_GPR245, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr246", HW_H_SYS_GPR246, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr247", HW_H_SYS_GPR247, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr248", HW_H_SYS_GPR248, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr249", HW_H_SYS_GPR249, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr250", HW_H_SYS_GPR250, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr251", HW_H_SYS_GPR251, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr252", HW_H_SYS_GPR252, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr253", HW_H_SYS_GPR253, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr254", HW_H_SYS_GPR254, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr255", HW_H_SYS_GPR255, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr256", HW_H_SYS_GPR256, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr257", HW_H_SYS_GPR257, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr258", HW_H_SYS_GPR258, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr259", HW_H_SYS_GPR259, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr260", HW_H_SYS_GPR260, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr261", HW_H_SYS_GPR261, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr262", HW_H_SYS_GPR262, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr263", HW_H_SYS_GPR263, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr264", HW_H_SYS_GPR264, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr265", HW_H_SYS_GPR265, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr266", HW_H_SYS_GPR266, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr267", HW_H_SYS_GPR267, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr268", HW_H_SYS_GPR268, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr269", HW_H_SYS_GPR269, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr270", HW_H_SYS_GPR270, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr271", HW_H_SYS_GPR271, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr272", HW_H_SYS_GPR272, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr273", HW_H_SYS_GPR273, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr274", HW_H_SYS_GPR274, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr275", HW_H_SYS_GPR275, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr276", HW_H_SYS_GPR276, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr277", HW_H_SYS_GPR277, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr278", HW_H_SYS_GPR278, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr279", HW_H_SYS_GPR279, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr280", HW_H_SYS_GPR280, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr281", HW_H_SYS_GPR281, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr282", HW_H_SYS_GPR282, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr283", HW_H_SYS_GPR283, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr284", HW_H_SYS_GPR284, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr285", HW_H_SYS_GPR285, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr286", HW_H_SYS_GPR286, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr287", HW_H_SYS_GPR287, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr288", HW_H_SYS_GPR288, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr289", HW_H_SYS_GPR289, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr290", HW_H_SYS_GPR290, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr291", HW_H_SYS_GPR291, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr292", HW_H_SYS_GPR292, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr293", HW_H_SYS_GPR293, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr294", HW_H_SYS_GPR294, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr295", HW_H_SYS_GPR295, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr296", HW_H_SYS_GPR296, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr297", HW_H_SYS_GPR297, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr298", HW_H_SYS_GPR298, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr299", HW_H_SYS_GPR299, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr300", HW_H_SYS_GPR300, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr301", HW_H_SYS_GPR301, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr302", HW_H_SYS_GPR302, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr303", HW_H_SYS_GPR303, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr304", HW_H_SYS_GPR304, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr305", HW_H_SYS_GPR305, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr306", HW_H_SYS_GPR306, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr307", HW_H_SYS_GPR307, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr308", HW_H_SYS_GPR308, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr309", HW_H_SYS_GPR309, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr310", HW_H_SYS_GPR310, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr311", HW_H_SYS_GPR311, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr312", HW_H_SYS_GPR312, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr313", HW_H_SYS_GPR313, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr314", HW_H_SYS_GPR314, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr315", HW_H_SYS_GPR315, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr316", HW_H_SYS_GPR316, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr317", HW_H_SYS_GPR317, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr318", HW_H_SYS_GPR318, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr319", HW_H_SYS_GPR319, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr320", HW_H_SYS_GPR320, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr321", HW_H_SYS_GPR321, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr322", HW_H_SYS_GPR322, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr323", HW_H_SYS_GPR323, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr324", HW_H_SYS_GPR324, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr325", HW_H_SYS_GPR325, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr326", HW_H_SYS_GPR326, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr327", HW_H_SYS_GPR327, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr328", HW_H_SYS_GPR328, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr329", HW_H_SYS_GPR329, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr330", HW_H_SYS_GPR330, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr331", HW_H_SYS_GPR331, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr332", HW_H_SYS_GPR332, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr333", HW_H_SYS_GPR333, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr334", HW_H_SYS_GPR334, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr335", HW_H_SYS_GPR335, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr336", HW_H_SYS_GPR336, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr337", HW_H_SYS_GPR337, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr338", HW_H_SYS_GPR338, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr339", HW_H_SYS_GPR339, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr340", HW_H_SYS_GPR340, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr341", HW_H_SYS_GPR341, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr342", HW_H_SYS_GPR342, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr343", HW_H_SYS_GPR343, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr344", HW_H_SYS_GPR344, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr345", HW_H_SYS_GPR345, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr346", HW_H_SYS_GPR346, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr347", HW_H_SYS_GPR347, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr348", HW_H_SYS_GPR348, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr349", HW_H_SYS_GPR349, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr350", HW_H_SYS_GPR350, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr351", HW_H_SYS_GPR351, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr352", HW_H_SYS_GPR352, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr353", HW_H_SYS_GPR353, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr354", HW_H_SYS_GPR354, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr355", HW_H_SYS_GPR355, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr356", HW_H_SYS_GPR356, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr357", HW_H_SYS_GPR357, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr358", HW_H_SYS_GPR358, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr359", HW_H_SYS_GPR359, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr360", HW_H_SYS_GPR360, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr361", HW_H_SYS_GPR361, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr362", HW_H_SYS_GPR362, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr363", HW_H_SYS_GPR363, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr364", HW_H_SYS_GPR364, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr365", HW_H_SYS_GPR365, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr366", HW_H_SYS_GPR366, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr367", HW_H_SYS_GPR367, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr368", HW_H_SYS_GPR368, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr369", HW_H_SYS_GPR369, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr370", HW_H_SYS_GPR370, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr371", HW_H_SYS_GPR371, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr372", HW_H_SYS_GPR372, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr373", HW_H_SYS_GPR373, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr374", HW_H_SYS_GPR374, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr375", HW_H_SYS_GPR375, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr376", HW_H_SYS_GPR376, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr377", HW_H_SYS_GPR377, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr378", HW_H_SYS_GPR378, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr379", HW_H_SYS_GPR379, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr380", HW_H_SYS_GPR380, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr381", HW_H_SYS_GPR381, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr382", HW_H_SYS_GPR382, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr383", HW_H_SYS_GPR383, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr384", HW_H_SYS_GPR384, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr385", HW_H_SYS_GPR385, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr386", HW_H_SYS_GPR386, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr387", HW_H_SYS_GPR387, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr388", HW_H_SYS_GPR388, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr389", HW_H_SYS_GPR389, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr390", HW_H_SYS_GPR390, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr391", HW_H_SYS_GPR391, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr392", HW_H_SYS_GPR392, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr393", HW_H_SYS_GPR393, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr394", HW_H_SYS_GPR394, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr395", HW_H_SYS_GPR395, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr396", HW_H_SYS_GPR396, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr397", HW_H_SYS_GPR397, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr398", HW_H_SYS_GPR398, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr399", HW_H_SYS_GPR399, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr400", HW_H_SYS_GPR400, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr401", HW_H_SYS_GPR401, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr402", HW_H_SYS_GPR402, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr403", HW_H_SYS_GPR403, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr404", HW_H_SYS_GPR404, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr405", HW_H_SYS_GPR405, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr406", HW_H_SYS_GPR406, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr407", HW_H_SYS_GPR407, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr408", HW_H_SYS_GPR408, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr409", HW_H_SYS_GPR409, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr410", HW_H_SYS_GPR410, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr411", HW_H_SYS_GPR411, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr412", HW_H_SYS_GPR412, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr413", HW_H_SYS_GPR413, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr414", HW_H_SYS_GPR414, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr415", HW_H_SYS_GPR415, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr416", HW_H_SYS_GPR416, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr417", HW_H_SYS_GPR417, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr418", HW_H_SYS_GPR418, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr419", HW_H_SYS_GPR419, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr420", HW_H_SYS_GPR420, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr421", HW_H_SYS_GPR421, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr422", HW_H_SYS_GPR422, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr423", HW_H_SYS_GPR423, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr424", HW_H_SYS_GPR424, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr425", HW_H_SYS_GPR425, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr426", HW_H_SYS_GPR426, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr427", HW_H_SYS_GPR427, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr428", HW_H_SYS_GPR428, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr429", HW_H_SYS_GPR429, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr430", HW_H_SYS_GPR430, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr431", HW_H_SYS_GPR431, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr432", HW_H_SYS_GPR432, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr433", HW_H_SYS_GPR433, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr434", HW_H_SYS_GPR434, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr435", HW_H_SYS_GPR435, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr436", HW_H_SYS_GPR436, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr437", HW_H_SYS_GPR437, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr438", HW_H_SYS_GPR438, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr439", HW_H_SYS_GPR439, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr440", HW_H_SYS_GPR440, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr441", HW_H_SYS_GPR441, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr442", HW_H_SYS_GPR442, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr443", HW_H_SYS_GPR443, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr444", HW_H_SYS_GPR444, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr445", HW_H_SYS_GPR445, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr446", HW_H_SYS_GPR446, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr447", HW_H_SYS_GPR447, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr448", HW_H_SYS_GPR448, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr449", HW_H_SYS_GPR449, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr450", HW_H_SYS_GPR450, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr451", HW_H_SYS_GPR451, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr452", HW_H_SYS_GPR452, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr453", HW_H_SYS_GPR453, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr454", HW_H_SYS_GPR454, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr455", HW_H_SYS_GPR455, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr456", HW_H_SYS_GPR456, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr457", HW_H_SYS_GPR457, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr458", HW_H_SYS_GPR458, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr459", HW_H_SYS_GPR459, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr460", HW_H_SYS_GPR460, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr461", HW_H_SYS_GPR461, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr462", HW_H_SYS_GPR462, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr463", HW_H_SYS_GPR463, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr464", HW_H_SYS_GPR464, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr465", HW_H_SYS_GPR465, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr466", HW_H_SYS_GPR466, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr467", HW_H_SYS_GPR467, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr468", HW_H_SYS_GPR468, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr469", HW_H_SYS_GPR469, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr470", HW_H_SYS_GPR470, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr471", HW_H_SYS_GPR471, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr472", HW_H_SYS_GPR472, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr473", HW_H_SYS_GPR473, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr474", HW_H_SYS_GPR474, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr475", HW_H_SYS_GPR475, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr476", HW_H_SYS_GPR476, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr477", HW_H_SYS_GPR477, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr478", HW_H_SYS_GPR478, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr479", HW_H_SYS_GPR479, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr480", HW_H_SYS_GPR480, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr481", HW_H_SYS_GPR481, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr482", HW_H_SYS_GPR482, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr483", HW_H_SYS_GPR483, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr484", HW_H_SYS_GPR484, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr485", HW_H_SYS_GPR485, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr486", HW_H_SYS_GPR486, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr487", HW_H_SYS_GPR487, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr488", HW_H_SYS_GPR488, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr489", HW_H_SYS_GPR489, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr490", HW_H_SYS_GPR490, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr491", HW_H_SYS_GPR491, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr492", HW_H_SYS_GPR492, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr493", HW_H_SYS_GPR493, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr494", HW_H_SYS_GPR494, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr495", HW_H_SYS_GPR495, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr496", HW_H_SYS_GPR496, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr497", HW_H_SYS_GPR497, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr498", HW_H_SYS_GPR498, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr499", HW_H_SYS_GPR499, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr500", HW_H_SYS_GPR500, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr501", HW_H_SYS_GPR501, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr502", HW_H_SYS_GPR502, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr503", HW_H_SYS_GPR503, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr504", HW_H_SYS_GPR504, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr505", HW_H_SYS_GPR505, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr506", HW_H_SYS_GPR506, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr507", HW_H_SYS_GPR507, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr508", HW_H_SYS_GPR508, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr509", HW_H_SYS_GPR509, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr510", HW_H_SYS_GPR510, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-gpr511", HW_H_SYS_GPR511, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-mac-maclo", HW_H_MAC_MACLO, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-mac-machi", HW_H_MAC_MACHI, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-tick-ttmr", HW_H_TICK_TTMR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-vr-rev", HW_H_SYS_VR_REV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-vr-cfg", HW_H_SYS_VR_CFG, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-vr-ver", HW_H_SYS_VR_VER, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-up", HW_H_SYS_UPR_UP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-dcp", HW_H_SYS_UPR_DCP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-icp", HW_H_SYS_UPR_ICP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-dmp", HW_H_SYS_UPR_DMP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-mp", HW_H_SYS_UPR_MP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-imp", HW_H_SYS_UPR_IMP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-dup", HW_H_SYS_UPR_DUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-pcup", HW_H_SYS_UPR_PCUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-picp", HW_H_SYS_UPR_PICP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-pmp", HW_H_SYS_UPR_PMP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-ttp", HW_H_SYS_UPR_TTP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-upr-cup", HW_H_SYS_UPR_CUP, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-nsgr", HW_H_SYS_CPUCFGR_NSGR, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-cgf", HW_H_SYS_CPUCFGR_CGF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-ob32s", HW_H_SYS_CPUCFGR_OB32S, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-ob64s", HW_H_SYS_CPUCFGR_OB64S, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-of32s", HW_H_SYS_CPUCFGR_OF32S, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-of64s", HW_H_SYS_CPUCFGR_OF64S, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-ov64s", HW_H_SYS_CPUCFGR_OV64S, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-cpucfgr-nd", HW_H_SYS_CPUCFGR_ND, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-sm", HW_H_SYS_SR_SM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-tee", HW_H_SYS_SR_TEE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-iee", HW_H_SYS_SR_IEE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-dce", HW_H_SYS_SR_DCE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-ice", HW_H_SYS_SR_ICE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-dme", HW_H_SYS_SR_DME, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-ime", HW_H_SYS_SR_IME, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-lee", HW_H_SYS_SR_LEE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-ce", HW_H_SYS_SR_CE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-f", HW_H_SYS_SR_F, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-cy", HW_H_SYS_SR_CY, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-ov", HW_H_SYS_SR_OV, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-ove", HW_H_SYS_SR_OVE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-dsx", HW_H_SYS_SR_DSX, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-eph", HW_H_SYS_SR_EPH, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-fo", HW_H_SYS_SR_FO, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-sumra", HW_H_SYS_SR_SUMRA, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-sr-cid", HW_H_SYS_SR_CID, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-fpee", HW_H_SYS_FPCSR_FPEE, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-rm", HW_H_SYS_FPCSR_RM, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-ovf", HW_H_SYS_FPCSR_OVF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-unf", HW_H_SYS_FPCSR_UNF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-snf", HW_H_SYS_FPCSR_SNF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-qnf", HW_H_SYS_FPCSR_QNF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-zf", HW_H_SYS_FPCSR_ZF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-ixf", HW_H_SYS_FPCSR_IXF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-ivf", HW_H_SYS_FPCSR_IVF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-inf", HW_H_SYS_FPCSR_INF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-sys-fpcsr-dzf", HW_H_SYS_FPCSR_DZF, CGEN_ASM_NONE, 0, { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-simm16", HW_H_SIMM16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } } },
+  { "h-uimm16", HW_H_UIMM16, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { "h-uimm6", HW_H_UIMM6, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+  { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction field table.  */
+
+#define A(a) (1 << CGEN_IFLD_##a)
+
+const CGEN_IFLD or1k_cgen_ifld_table[] =
+{
+  { OR1K_F_NIL, "f-nil", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { OR1K_F_ANYOF, "f-anyof", 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } }  },
+  { OR1K_F_OPCODE, "f-opcode", 0, 32, 31, 6, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_R1, "f-r1", 0, 32, 25, 5, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_R2, "f-r2", 0, 32, 20, 5, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_R3, "f-r3", 0, 32, 15, 5, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_25_2, "f-op-25-2", 0, 32, 25, 2, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_25_5, "f-op-25-5", 0, 32, 25, 5, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_16_1, "f-op-16-1", 0, 32, 16, 1, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_7_4, "f-op-7-4", 0, 32, 7, 4, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_3_4, "f-op-3-4", 0, 32, 3, 4, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_9_2, "f-op-9-2", 0, 32, 9, 2, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_9_4, "f-op-9-4", 0, 32, 9, 4, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_7_8, "f-op-7-8", 0, 32, 7, 8, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_OP_7_2, "f-op-7-2", 0, 32, 7, 2, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_25_26, "f-resv-25-26", 0, 32, 25, 26, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_25_10, "f-resv-25-10", 0, 32, 25, 10, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_25_5, "f-resv-25-5", 0, 32, 25, 5, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_23_8, "f-resv-23-8", 0, 32, 23, 8, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_20_5, "f-resv-20-5", 0, 32, 20, 5, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_20_4, "f-resv-20-4", 0, 32, 20, 4, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_15_8, "f-resv-15-8", 0, 32, 15, 8, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_15_6, "f-resv-15-6", 0, 32, 15, 6, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_10_11, "f-resv-10-11", 0, 32, 10, 11, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_10_7, "f-resv-10-7", 0, 32, 10, 7, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_10_3, "f-resv-10-3", 0, 32, 10, 3, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_10_1, "f-resv-10-1", 0, 32, 10, 1, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_7_4, "f-resv-7-4", 0, 32, 7, 4, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_RESV_5_2, "f-resv-5-2", 0, 32, 5, 2, { 0|A(RESERVED), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_IMM16_25_5, "f-imm16-25-5", 0, 32, 25, 5, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_IMM16_10_11, "f-imm16-10-11", 0, 32, 10, 11, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_DISP26, "f-disp26", 0, 32, 25, 26, { 0|A(PCREL_ADDR), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_UIMM16, "f-uimm16", 0, 32, 15, 16, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_SIMM16, "f-simm16", 0, 32, 15, 16, { 0|A(SIGN_OPT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_UIMM6, "f-uimm6", 0, 32, 5, 6, { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_UIMM16_SPLIT, "f-uimm16-split", 0, 0, 0, 0,{ 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { OR1K_F_SIMM16_SPLIT, "f-simm16-split", 0, 0, 0, 0,{ 0|A(SIGN_OPT)|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+  { 0, 0, 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+
+/* multi ifield declarations */
+
+const CGEN_MAYBE_MULTI_IFLD OR1K_F_UIMM16_SPLIT_MULTI_IFIELD [];
+const CGEN_MAYBE_MULTI_IFLD OR1K_F_SIMM16_SPLIT_MULTI_IFIELD [];
+
+
+/* multi ifield definitions */
+
+const CGEN_MAYBE_MULTI_IFLD OR1K_F_UIMM16_SPLIT_MULTI_IFIELD [] =
+{
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_IMM16_25_5] } },
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_IMM16_10_11] } },
+    { 0, { (const PTR) 0 } }
+};
+const CGEN_MAYBE_MULTI_IFLD OR1K_F_SIMM16_SPLIT_MULTI_IFIELD [] =
+{
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_IMM16_25_5] } },
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_IMM16_10_11] } },
+    { 0, { (const PTR) 0 } }
+};
+
+/* The operand table.  */
+
+#define A(a) (1 << CGEN_OPERAND_##a)
+#define OPERAND(op) OR1K_OPERAND_##op
+
+const CGEN_OPERAND or1k_cgen_operand_table[] =
+{
+/* pc: program counter */
+  { "pc", OR1K_OPERAND_PC, HW_H_PC, 0, 0,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_NIL] } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_BASE), 0 } } } }  },
+/* sys-sr: supervision register */
+  { "sys-sr", OR1K_OPERAND_SYS_SR, HW_H_SYS_SR, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-esr0: exception supervision register 0 */
+  { "sys-esr0", OR1K_OPERAND_SYS_ESR0, HW_H_SYS_ESR0, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-epcr0: exception PC register 0 */
+  { "sys-epcr0", OR1K_OPERAND_SYS_EPCR0, HW_H_SYS_EPCR0, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-sr-lee: SR little endian enable bit */
+  { "sys-sr-lee", OR1K_OPERAND_SYS_SR_LEE, HW_H_SYS_SR_LEE, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-sr-f: SR flag bit */
+  { "sys-sr-f", OR1K_OPERAND_SYS_SR_F, HW_H_SYS_SR_F, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-sr-cy: SR carry bit */
+  { "sys-sr-cy", OR1K_OPERAND_SYS_SR_CY, HW_H_SYS_SR_CY, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-sr-ov: SR overflow bit */
+  { "sys-sr-ov", OR1K_OPERAND_SYS_SR_OV, HW_H_SYS_SR_OV, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-sr-ove: SR overflow exception enable bit */
+  { "sys-sr-ove", OR1K_OPERAND_SYS_SR_OVE, HW_H_SYS_SR_OVE, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-cpucfgr-ob64s: CPUCFGR ORBIS64 supported bit */
+  { "sys-cpucfgr-ob64s", OR1K_OPERAND_SYS_CPUCFGR_OB64S, HW_H_SYS_CPUCFGR_OB64S, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-cpucfgr-nd: CPUCFGR no delay bit */
+  { "sys-cpucfgr-nd", OR1K_OPERAND_SYS_CPUCFGR_ND, HW_H_SYS_CPUCFGR_ND, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sys-fpcsr-rm: floating point round mode */
+  { "sys-fpcsr-rm", OR1K_OPERAND_SYS_FPCSR_RM, HW_H_SYS_FPCSR_RM, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* mac-machi: MAC HI result register */
+  { "mac-machi", OR1K_OPERAND_MAC_MACHI, HW_H_MAC_MACHI, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* mac-maclo: MAC LO result register */
+  { "mac-maclo", OR1K_OPERAND_MAC_MACLO, HW_H_MAC_MACLO, 0, 0,
+    { 0, { (const PTR) 0 } }, 
+    { 0|A(SEM_ONLY), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* uimm6: uimm6 */
+  { "uimm6", OR1K_OPERAND_UIMM6, HW_H_UIMM6, 5, 6,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM6] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rD: destination register */
+  { "rD", OR1K_OPERAND_RD, HW_H_GPR, 25, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rA: source register A */
+  { "rA", OR1K_OPERAND_RA, HW_H_GPR, 20, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rB: source register B */
+  { "rB", OR1K_OPERAND_RB, HW_H_GPR, 15, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* disp26: pc-rel 26 bit */
+  { "disp26", OR1K_OPERAND_DISP26, HW_H_IADDR, 25, 26,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_DISP26] } }, 
+    { 0|A(PCREL_ADDR), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* simm16: 16-bit signed immediate */
+  { "simm16", OR1K_OPERAND_SIMM16, HW_H_SIMM16, 15, 16,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_SIMM16] } }, 
+    { 0|A(SIGN_OPT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* uimm16: 16-bit unsigned immediate */
+  { "uimm16", OR1K_OPERAND_UIMM16, HW_H_UIMM16, 15, 16,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_UIMM16] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* simm16-split: split 16-bit signed immediate */
+  { "simm16-split", OR1K_OPERAND_SIMM16_SPLIT, HW_H_SIMM16, 10, 16,
+    { 2, { (const PTR) &OR1K_F_SIMM16_SPLIT_MULTI_IFIELD[0] } }, 
+    { 0|A(SIGN_OPT)|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* uimm16-split: split 16-bit unsigned immediate */
+  { "uimm16-split", OR1K_OPERAND_UIMM16_SPLIT, HW_H_UIMM16, 10, 16,
+    { 2, { (const PTR) &OR1K_F_UIMM16_SPLIT_MULTI_IFIELD[0] } }, 
+    { 0|A(VIRTUAL), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rDSF: destination register (single floating point mode) */
+  { "rDSF", OR1K_OPERAND_RDSF, HW_H_FSR, 25, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rASF: source register A (single floating point mode) */
+  { "rASF", OR1K_OPERAND_RASF, HW_H_FSR, 20, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R2] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rBSF: source register B (single floating point mode) */
+  { "rBSF", OR1K_OPERAND_RBSF, HW_H_FSR, 15, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R3] } }, 
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rDDF: destination register (double floating point mode) */
+  { "rDDF", OR1K_OPERAND_RDDF, HW_H_FDR, 25, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rADF: source register A (double floating point mode) */
+  { "rADF", OR1K_OPERAND_RADF, HW_H_FDR, 25, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* rBDF: source register B (double floating point mode) */
+  { "rBDF", OR1K_OPERAND_RBDF, HW_H_FDR, 25, 5,
+    { 0, { (const PTR) &or1k_cgen_ifld_table[OR1K_F_R1] } }, 
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }  },
+/* sentinel */
+  { 0, 0, 0, 0, 0,
+    { 0, { (const PTR) 0 } },
+    { 0, { { { (1<<MACH_BASE), 0 } } } } }
+};
+
+#undef A
+
+
+/* The instruction table.  */
+
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+#define A(a) (1 << CGEN_INSN_##a)
+
+static const CGEN_IBASE or1k_cgen_insn_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { 0, 0, 0, 0, { 0, { { { (1<<MACH_BASE), 0 } } } } },
+/* l.j ${disp26} */
+  {
+    OR1K_INSN_L_J, "l-j", "l.j", 32,
+    { 0|A(UNCOND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.jal ${disp26} */
+  {
+    OR1K_INSN_L_JAL, "l-jal", "l.jal", 32,
+    { 0|A(UNCOND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.jr $rB */
+  {
+    OR1K_INSN_L_JR, "l-jr", "l.jr", 32,
+    { 0|A(UNCOND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.jalr $rB */
+  {
+    OR1K_INSN_L_JALR, "l-jalr", "l.jalr", 32,
+    { 0|A(UNCOND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.bnf ${disp26} */
+  {
+    OR1K_INSN_L_BNF, "l-bnf", "l.bnf", 32,
+    { 0|A(COND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.bf ${disp26} */
+  {
+    OR1K_INSN_L_BF, "l-bf", "l.bf", 32,
+    { 0|A(COND_CTI)|A(NOT_IN_DELAY_SLOT)|A(DELAYED_CTI)|A(SKIP_CTI)|A(DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.trap ${uimm16} */
+  {
+    OR1K_INSN_L_TRAP, "l-trap", "l.trap", 32,
+    { 0|A(NOT_IN_DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sys ${uimm16} */
+  {
+    OR1K_INSN_L_SYS, "l-sys", "l.sys", 32,
+    { 0|A(NOT_IN_DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.rfe */
+  {
+    OR1K_INSN_L_RFE, "l-rfe", "l.rfe", 32,
+    { 0|A(FORCED_CTI)|A(NOT_IN_DELAY_SLOT), { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.nop ${uimm16} */
+  {
+    OR1K_INSN_L_NOP_IMM, "l-nop-imm", "l.nop", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.nop */
+  {
+    OR1K_INSN_L_NOP, "l-nop", "l.nop", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.movhi $rD,$uimm16 */
+  {
+    OR1K_INSN_L_MOVHI, "l-movhi", "l.movhi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.macrc $rD */
+  {
+    OR1K_INSN_L_MACRC, "l-macrc", "l.macrc", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.mfspr $rD,$rA,${uimm16} */
+  {
+    OR1K_INSN_L_MFSPR, "l-mfspr", "l.mfspr", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.mtspr $rA,$rB,${uimm16-split} */
+  {
+    OR1K_INSN_L_MTSPR, "l-mtspr", "l.mtspr", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lwz $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LWZ, "l-lwz", "l.lwz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lws $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LWS, "l-lws", "l.lws", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lbz $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LBZ, "l-lbz", "l.lbz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lbs $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LBS, "l-lbs", "l.lbs", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lhz $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LHZ, "l-lhz", "l.lhz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.lhs $rD,${simm16}($rA) */
+  {
+    OR1K_INSN_L_LHS, "l-lhs", "l.lhs", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sw ${simm16-split}($rA),$rB */
+  {
+    OR1K_INSN_L_SW, "l-sw", "l.sw", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sb ${simm16-split}($rA),$rB */
+  {
+    OR1K_INSN_L_SB, "l-sb", "l.sb", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sh ${simm16-split}($rA),$rB */
+  {
+    OR1K_INSN_L_SH, "l-sh", "l.sh", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sll $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_SLL, "l-sll", "l.sll", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.slli $rD,$rA,${uimm6} */
+  {
+    OR1K_INSN_L_SLLI, "l-slli", "l.slli", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.srl $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_SRL, "l-srl", "l.srl", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.srli $rD,$rA,${uimm6} */
+  {
+    OR1K_INSN_L_SRLI, "l-srli", "l.srli", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sra $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_SRA, "l-sra", "l.sra", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.srai $rD,$rA,${uimm6} */
+  {
+    OR1K_INSN_L_SRAI, "l-srai", "l.srai", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.ror $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_ROR, "l-ror", "l.ror", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.rori $rD,$rA,${uimm6} */
+  {
+    OR1K_INSN_L_RORI, "l-rori", "l.rori", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.and $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_AND, "l-and", "l.and", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.or $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_OR, "l-or", "l.or", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.xor $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_XOR, "l-xor", "l.xor", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.add $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_ADD, "l-add", "l.add", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sub $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_SUB, "l-sub", "l.sub", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.addc $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_ADDC, "l-addc", "l.addc", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.mul $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_MUL, "l-mul", "l.mul", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.mulu $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_MULU, "l-mulu", "l.mulu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.div $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_DIV, "l-div", "l.div", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.divu $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_DIVU, "l-divu", "l.divu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.ff1 $rD,$rA */
+  {
+    OR1K_INSN_L_FF1, "l-ff1", "l.ff1", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.fl1 $rD,$rA */
+  {
+    OR1K_INSN_L_FL1, "l-fl1", "l.fl1", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.andi $rD,$rA,$uimm16 */
+  {
+    OR1K_INSN_L_ANDI, "l-andi", "l.andi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.ori $rD,$rA,$uimm16 */
+  {
+    OR1K_INSN_L_ORI, "l-ori", "l.ori", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.xori $rD,$rA,$simm16 */
+  {
+    OR1K_INSN_L_XORI, "l-xori", "l.xori", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.addi $rD,$rA,$simm16 */
+  {
+    OR1K_INSN_L_ADDI, "l-addi", "l.addi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.addic $rD,$rA,$simm16 */
+  {
+    OR1K_INSN_L_ADDIC, "l-addic", "l.addic", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.muli $rD,$rA,$simm16 */
+  {
+    OR1K_INSN_L_MULI, "l-muli", "l.muli", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.exths $rD,$rA */
+  {
+    OR1K_INSN_L_EXTHS, "l-exths", "l.exths", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.extbs $rD,$rA */
+  {
+    OR1K_INSN_L_EXTBS, "l-extbs", "l.extbs", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.exthz $rD,$rA */
+  {
+    OR1K_INSN_L_EXTHZ, "l-exthz", "l.exthz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.extbz $rD,$rA */
+  {
+    OR1K_INSN_L_EXTBZ, "l-extbz", "l.extbz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.extws $rD,$rA */
+  {
+    OR1K_INSN_L_EXTWS, "l-extws", "l.extws", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.extwz $rD,$rA */
+  {
+    OR1K_INSN_L_EXTWZ, "l-extwz", "l.extwz", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cmov $rD,$rA,$rB */
+  {
+    OR1K_INSN_L_CMOV, "l-cmov", "l.cmov", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgts $rA,$rB */
+  {
+    OR1K_INSN_L_SFGTS, "l-sfgts", "l.sfgts", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgtsi $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFGTSI, "l-sfgtsi", "l.sfgtsi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgtu $rA,$rB */
+  {
+    OR1K_INSN_L_SFGTU, "l-sfgtu", "l.sfgtu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgtui $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFGTUI, "l-sfgtui", "l.sfgtui", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfges $rA,$rB */
+  {
+    OR1K_INSN_L_SFGES, "l-sfges", "l.sfges", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgesi $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFGESI, "l-sfgesi", "l.sfgesi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgeu $rA,$rB */
+  {
+    OR1K_INSN_L_SFGEU, "l-sfgeu", "l.sfgeu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfgeui $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFGEUI, "l-sfgeui", "l.sfgeui", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sflts $rA,$rB */
+  {
+    OR1K_INSN_L_SFLTS, "l-sflts", "l.sflts", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfltsi $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFLTSI, "l-sfltsi", "l.sfltsi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfltu $rA,$rB */
+  {
+    OR1K_INSN_L_SFLTU, "l-sfltu", "l.sfltu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfltui $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFLTUI, "l-sfltui", "l.sfltui", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfles $rA,$rB */
+  {
+    OR1K_INSN_L_SFLES, "l-sfles", "l.sfles", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sflesi $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFLESI, "l-sflesi", "l.sflesi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfleu $rA,$rB */
+  {
+    OR1K_INSN_L_SFLEU, "l-sfleu", "l.sfleu", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfleui $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFLEUI, "l-sfleui", "l.sfleui", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfeq $rA,$rB */
+  {
+    OR1K_INSN_L_SFEQ, "l-sfeq", "l.sfeq", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfeqi $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFEQI, "l-sfeqi", "l.sfeqi", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfne $rA,$rB */
+  {
+    OR1K_INSN_L_SFNE, "l-sfne", "l.sfne", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.sfnei $rA,$simm16 */
+  {
+    OR1K_INSN_L_SFNEI, "l-sfnei", "l.sfnei", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.mac $rA,$rB */
+  {
+    OR1K_INSN_L_MAC, "l-mac", "l.mac", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.msb $rA,$rB */
+  {
+    OR1K_INSN_L_MSB, "l-msb", "l.msb", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.maci $rA,${simm16} */
+  {
+    OR1K_INSN_L_MACI, "l-maci", "l.maci", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust1 */
+  {
+    OR1K_INSN_L_CUST1, "l-cust1", "l.cust1", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust2 */
+  {
+    OR1K_INSN_L_CUST2, "l-cust2", "l.cust2", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust3 */
+  {
+    OR1K_INSN_L_CUST3, "l-cust3", "l.cust3", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust4 */
+  {
+    OR1K_INSN_L_CUST4, "l-cust4", "l.cust4", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust5 */
+  {
+    OR1K_INSN_L_CUST5, "l-cust5", "l.cust5", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust6 */
+  {
+    OR1K_INSN_L_CUST6, "l-cust6", "l.cust6", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust7 */
+  {
+    OR1K_INSN_L_CUST7, "l-cust7", "l.cust7", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* l.cust8 */
+  {
+    OR1K_INSN_L_CUST8, "l-cust8", "l.cust8", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.add.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_ADD_S, "lf-add-s", "lf.add.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.add.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_ADD_D, "lf-add-d", "lf.add.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sub.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_SUB_S, "lf-sub-s", "lf.sub.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sub.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_SUB_D, "lf-sub-d", "lf.sub.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.mul.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_MUL_S, "lf-mul-s", "lf.mul.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.mul.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_MUL_D, "lf-mul-d", "lf.mul.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.div.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_DIV_S, "lf-div-s", "lf.div.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.div.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_DIV_D, "lf-div-d", "lf.div.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.rem.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_REM_S, "lf-rem-s", "lf.rem.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.rem.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_REM_D, "lf-rem-d", "lf.rem.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.itof.s $rDSF,$rA */
+  {
+    OR1K_INSN_LF_ITOF_S, "lf-itof-s", "lf.itof.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.itof.d $rDSF,$rA */
+  {
+    OR1K_INSN_LF_ITOF_D, "lf-itof-d", "lf.itof.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.ftoi.s $rD,$rASF */
+  {
+    OR1K_INSN_LF_FTOI_S, "lf-ftoi-s", "lf.ftoi.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.ftoi.d $rD,$rADF */
+  {
+    OR1K_INSN_LF_FTOI_D, "lf-ftoi-d", "lf.ftoi.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfeq.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_EQ_S, "lf-eq-s", "lf.sfeq.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfeq.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_EQ_D, "lf-eq-d", "lf.sfeq.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfne.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_NE_S, "lf-ne-s", "lf.sfne.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfne.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_NE_D, "lf-ne-d", "lf.sfne.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfge.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_GE_S, "lf-ge-s", "lf.sfge.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfge.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_GE_D, "lf-ge-d", "lf.sfge.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfgt.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_GT_S, "lf-gt-s", "lf.sfgt.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfgt.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_GT_D, "lf-gt-d", "lf.sfgt.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sflt.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_LT_S, "lf-lt-s", "lf.sflt.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sflt.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_LT_D, "lf-lt-d", "lf.sflt.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfle.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_LE_S, "lf-le-s", "lf.sfle.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.sfle.d $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_LE_D, "lf-le-d", "lf.sfle.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.madd.s $rDSF,$rASF,$rBSF */
+  {
+    OR1K_INSN_LF_MADD_S, "lf-madd-s", "lf.madd.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.madd.d $rDDF,$rADF,$rBDF */
+  {
+    OR1K_INSN_LF_MADD_D, "lf-madd-d", "lf.madd.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.cust1.s $rASF,$rBSF */
+  {
+    OR1K_INSN_LF_CUST1_S, "lf-cust1-s", "lf.cust1.s", 32,
+    { 0, { { { (1<<MACH_OR32)|(1<<MACH_OR32ND)|(1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+/* lf.cust1.d */
+  {
+    OR1K_INSN_LF_CUST1_D, "lf-cust1-d", "lf.cust1.d", 32,
+    { 0, { { { (1<<MACH_OR64)|(1<<MACH_OR64ND), 0 } } } }
+  },
+};
+
+#undef OP
+#undef A
+
+/* Initialize anything needed to be done once, before any cpu_open call.  */
+
+static void
+init_tables (void)
+{
+}
+
+static const CGEN_MACH * lookup_mach_via_bfd_name (const CGEN_MACH *, const char *);
+static void build_hw_table      (CGEN_CPU_TABLE *);
+static void build_ifield_table  (CGEN_CPU_TABLE *);
+static void build_operand_table (CGEN_CPU_TABLE *);
+static void build_insn_table    (CGEN_CPU_TABLE *);
+static void or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *);
+
+/* Subroutine of or1k_cgen_cpu_open to look up a mach via its bfd name.  */
+
+static const CGEN_MACH *
+lookup_mach_via_bfd_name (const CGEN_MACH *table, const char *name)
+{
+  while (table->name)
+    {
+      if (strcmp (name, table->bfd_name) == 0)
+	return table;
+      ++table;
+    }
+  abort ();
+}
+
+/* Subroutine of or1k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_hw_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_HW_ENTRY *init = & or1k_cgen_hw_table[0];
+  /* MAX_HW is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_HW_ENTRY **selected =
+    (const CGEN_HW_ENTRY **) xmalloc (MAX_HW * sizeof (CGEN_HW_ENTRY *));
+
+  cd->hw_table.init_entries = init;
+  cd->hw_table.entry_size = sizeof (CGEN_HW_ENTRY);
+  memset (selected, 0, MAX_HW * sizeof (CGEN_HW_ENTRY *));
+  /* ??? For now we just use machs to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_HW_ATTR_VALUE (&init[i], CGEN_HW_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->hw_table.entries = selected;
+  cd->hw_table.num_entries = MAX_HW;
+}
+
+/* Subroutine of or1k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_ifield_table (CGEN_CPU_TABLE *cd)
+{
+  cd->ifld_table = & or1k_cgen_ifld_table[0];
+}
+
+/* Subroutine of or1k_cgen_cpu_open to build the hardware table.  */
+
+static void
+build_operand_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  int machs = cd->machs;
+  const CGEN_OPERAND *init = & or1k_cgen_operand_table[0];
+  /* MAX_OPERANDS is only an upper bound on the number of selected entries.
+     However each entry is indexed by it's enum so there can be holes in
+     the table.  */
+  const CGEN_OPERAND **selected = xmalloc (MAX_OPERANDS * sizeof (* selected));
+
+  cd->operand_table.init_entries = init;
+  cd->operand_table.entry_size = sizeof (CGEN_OPERAND);
+  memset (selected, 0, MAX_OPERANDS * sizeof (CGEN_OPERAND *));
+  /* ??? For now we just use mach to determine which ones we want.  */
+  for (i = 0; init[i].name != NULL; ++i)
+    if (CGEN_OPERAND_ATTR_VALUE (&init[i], CGEN_OPERAND_MACH)
+	& machs)
+      selected[init[i].type] = &init[i];
+  cd->operand_table.entries = selected;
+  cd->operand_table.num_entries = MAX_OPERANDS;
+}
+
+/* Subroutine of or1k_cgen_cpu_open to build the hardware table.
+   ??? This could leave out insns not supported by the specified mach/isa,
+   but that would cause errors like "foo only supported by bar" to become
+   "unknown insn", so for now we include all insns and require the app to
+   do the checking later.
+   ??? On the other hand, parsing of such insns may require their hardware or
+   operand elements to be in the table [which they mightn't be].  */
+
+static void
+build_insn_table (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  const CGEN_IBASE *ib = & or1k_cgen_insn_table[0];
+  CGEN_INSN *insns = xmalloc (MAX_INSNS * sizeof (CGEN_INSN));
+
+  memset (insns, 0, MAX_INSNS * sizeof (CGEN_INSN));
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].base = &ib[i];
+  cd->insn_table.init_entries = insns;
+  cd->insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->insn_table.num_init_entries = MAX_INSNS;
+}
+
+/* Subroutine of or1k_cgen_cpu_open to rebuild the tables.  */
+
+static void
+or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)
+{
+  int i;
+  CGEN_BITSET *isas = cd->isas;
+  unsigned int machs = cd->machs;
+
+  cd->int_insn_p = CGEN_INT_INSN_P;
+
+  /* Data derived from the isa spec.  */
+#define UNSET (CGEN_SIZE_UNKNOWN + 1)
+  cd->default_insn_bitsize = UNSET;
+  cd->base_insn_bitsize = UNSET;
+  cd->min_insn_bitsize = 65535; /* Some ridiculously big number.  */
+  cd->max_insn_bitsize = 0;
+  for (i = 0; i < MAX_ISAS; ++i)
+    if (cgen_bitset_contains (isas, i))
+      {
+	const CGEN_ISA *isa = & or1k_cgen_isa_table[i];
+
+	/* Default insn sizes of all selected isas must be
+	   equal or we set the result to 0, meaning "unknown".  */
+	if (cd->default_insn_bitsize == UNSET)
+	  cd->default_insn_bitsize = isa->default_insn_bitsize;
+	else if (isa->default_insn_bitsize == cd->default_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->default_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Base insn sizes of all selected isas must be equal
+	   or we set the result to 0, meaning "unknown".  */
+	if (cd->base_insn_bitsize == UNSET)
+	  cd->base_insn_bitsize = isa->base_insn_bitsize;
+	else if (isa->base_insn_bitsize == cd->base_insn_bitsize)
+	  ; /* This is ok.  */
+	else
+	  cd->base_insn_bitsize = CGEN_SIZE_UNKNOWN;
+
+	/* Set min,max insn sizes.  */
+	if (isa->min_insn_bitsize < cd->min_insn_bitsize)
+	  cd->min_insn_bitsize = isa->min_insn_bitsize;
+	if (isa->max_insn_bitsize > cd->max_insn_bitsize)
+	  cd->max_insn_bitsize = isa->max_insn_bitsize;
+      }
+
+  /* Data derived from the mach spec.  */
+  for (i = 0; i < MAX_MACHS; ++i)
+    if (((1 << i) & machs) != 0)
+      {
+	const CGEN_MACH *mach = & or1k_cgen_mach_table[i];
+
+	if (mach->insn_chunk_bitsize != 0)
+	{
+	  if (cd->insn_chunk_bitsize != 0 && cd->insn_chunk_bitsize != mach->insn_chunk_bitsize)
+	    {
+	      fprintf (stderr, "or1k_cgen_rebuild_tables: conflicting insn-chunk-bitsize values: `%d' vs. `%d'\n",
+		       cd->insn_chunk_bitsize, mach->insn_chunk_bitsize);
+	      abort ();
+	    }
+
+ 	  cd->insn_chunk_bitsize = mach->insn_chunk_bitsize;
+	}
+      }
+
+  /* Determine which hw elements are used by MACH.  */
+  build_hw_table (cd);
+
+  /* Build the ifield table.  */
+  build_ifield_table (cd);
+
+  /* Determine which operands are used by MACH/ISA.  */
+  build_operand_table (cd);
+
+  /* Build the instruction table.  */
+  build_insn_table (cd);
+}
+
+/* Initialize a cpu table and return a descriptor.
+   It's much like opening a file, and must be the first function called.
+   The arguments are a set of (type/value) pairs, terminated with
+   CGEN_CPU_OPEN_END.
+
+   Currently supported values:
+   CGEN_CPU_OPEN_ISAS:    bitmap of values in enum isa_attr
+   CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr
+   CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name
+   CGEN_CPU_OPEN_ENDIAN:  specify endian choice
+   CGEN_CPU_OPEN_END:     terminates arguments
+
+   ??? Simultaneous multiple isas might not make sense, but it's not (yet)
+   precluded.  */
+
+CGEN_CPU_DESC
+or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)
+{
+  CGEN_CPU_TABLE *cd = (CGEN_CPU_TABLE *) xmalloc (sizeof (CGEN_CPU_TABLE));
+  static int init_p;
+  CGEN_BITSET *isas = 0;  /* 0 = "unspecified" */
+  unsigned int machs = 0; /* 0 = "unspecified" */
+  enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;
+  va_list ap;
+
+  if (! init_p)
+    {
+      init_tables ();
+      init_p = 1;
+    }
+
+  memset (cd, 0, sizeof (*cd));
+
+  va_start (ap, arg_type);
+  while (arg_type != CGEN_CPU_OPEN_END)
+    {
+      switch (arg_type)
+	{
+	case CGEN_CPU_OPEN_ISAS :
+	  isas = va_arg (ap, CGEN_BITSET *);
+	  break;
+	case CGEN_CPU_OPEN_MACHS :
+	  machs = va_arg (ap, unsigned int);
+	  break;
+	case CGEN_CPU_OPEN_BFDMACH :
+	  {
+	    const char *name = va_arg (ap, const char *);
+	    const CGEN_MACH *mach =
+	      lookup_mach_via_bfd_name (or1k_cgen_mach_table, name);
+
+	    machs |= 1 << mach->num;
+	    break;
+	  }
+	case CGEN_CPU_OPEN_ENDIAN :
+	  endian = va_arg (ap, enum cgen_endian);
+	  break;
+	default :
+	  fprintf (stderr, "or1k_cgen_cpu_open: unsupported argument `%d'\n",
+		   arg_type);
+	  abort (); /* ??? return NULL? */
+	}
+      arg_type = va_arg (ap, enum cgen_cpu_open_arg);
+    }
+  va_end (ap);
+
+  /* Mach unspecified means "all".  */
+  if (machs == 0)
+    machs = (1 << MAX_MACHS) - 1;
+  /* Base mach is always selected.  */
+  machs |= 1;
+  if (endian == CGEN_ENDIAN_UNKNOWN)
+    {
+      /* ??? If target has only one, could have a default.  */
+      fprintf (stderr, "or1k_cgen_cpu_open: no endianness specified\n");
+      abort ();
+    }
+
+  cd->isas = cgen_bitset_copy (isas);
+  cd->machs = machs;
+  cd->endian = endian;
+  /* FIXME: for the sparc case we can determine insn-endianness statically.
+     The worry here is where both data and insn endian can be independently
+     chosen, in which case this function will need another argument.
+     Actually, will want to allow for more arguments in the future anyway.  */
+  cd->insn_endian = endian;
+
+  /* Table (re)builder.  */
+  cd->rebuild_tables = or1k_cgen_rebuild_tables;
+  or1k_cgen_rebuild_tables (cd);
+
+  /* Default to not allowing signed overflow.  */
+  cd->signed_overflow_ok_p = 0;
+  
+  return (CGEN_CPU_DESC) cd;
+}
+
+/* Cover fn to or1k_cgen_cpu_open to handle the simple case of 1 isa, 1 mach.
+   MACH_NAME is the bfd name of the mach.  */
+
+CGEN_CPU_DESC
+or1k_cgen_cpu_open_1 (const char *mach_name, enum cgen_endian endian)
+{
+  return or1k_cgen_cpu_open (CGEN_CPU_OPEN_BFDMACH, mach_name,
+			       CGEN_CPU_OPEN_ENDIAN, endian,
+			       CGEN_CPU_OPEN_END);
+}
+
+/* Close a cpu table.
+   ??? This can live in a machine independent file, but there's currently
+   no place to put this file (there's no libcgen).  libopcodes is the wrong
+   place as some simulator ports use this but they don't use libopcodes.  */
+
+void
+or1k_cgen_cpu_close (CGEN_CPU_DESC cd)
+{
+  unsigned int i;
+  const CGEN_INSN *insns;
+
+  if (cd->macro_insn_table.init_entries)
+    {
+      insns = cd->macro_insn_table.init_entries;
+      for (i = 0; i < cd->macro_insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX ((insns)))
+	  regfree (CGEN_INSN_RX (insns));
+    }
+
+  if (cd->insn_table.init_entries)
+    {
+      insns = cd->insn_table.init_entries;
+      for (i = 0; i < cd->insn_table.num_init_entries; ++i, ++insns)
+	if (CGEN_INSN_RX (insns))
+	  regfree (CGEN_INSN_RX (insns));
+    }  
+
+  if (cd->macro_insn_table.init_entries)
+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);
+
+  if (cd->insn_table.init_entries)
+    free ((CGEN_INSN *) cd->insn_table.init_entries);
+
+  if (cd->hw_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);
+
+  if (cd->operand_table.entries)
+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);
+
+  free (cd);
+}
+
--- /dev/null
+++ b/opcodes/or1k-desc.h
@@ -0,0 +1,682 @@
+/* CPU data header for or1k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2010 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef OR1K_CPU_H
+#define OR1K_CPU_H
+
+#define CGEN_ARCH or1k
+
+/* Given symbol S, return or1k_cgen_<S>.  */
+#define CGEN_SYM(s) or1k##_cgen_##s
+
+
+/* Selected cpu families.  */
+#define HAVE_CPU_OR1K32BF
+#define HAVE_CPU_OR1K64BF
+
+#define CGEN_INSN_LSB0_P 1
+
+/* Minimum size of any insn (in bytes).  */
+#define CGEN_MIN_INSN_SIZE 4
+
+/* Maximum size of any insn (in bytes).  */
+#define CGEN_MAX_INSN_SIZE 4
+
+#define CGEN_INT_INSN_P 1
+
+/* Maximum number of syntax elements in an instruction.  */
+#define CGEN_ACTUAL_MAX_SYNTAX_ELEMENTS 17
+
+/* CGEN_MNEMONIC_OPERANDS is defined if mnemonics have operands.
+   e.g. In "b,a foo" the ",a" is an operand.  If mnemonics have operands
+   we can't hash on everything up to the space.  */
+#define CGEN_MNEMONIC_OPERANDS
+
+/* Maximum number of fields in an instruction.  */
+#define CGEN_ACTUAL_MAX_IFMT_OPERANDS 8
+
+/* Enums.  */
+
+/* Enum declaration for Exception numbers.  */
+typedef enum except_number {
+  EXCEPT_NONE, EXCEPT_RESET, EXCEPT_BUSERR, EXCEPT_DPF
+ , EXCEPT_IPF, EXCEPT_TICK, EXCEPT_ALIGN, EXCEPT_ILLEGAL
+ , EXCEPT_INT, EXCEPT_DTLBMISS, EXCEPT_ITLBMISS, EXCEPT_RANGE
+ , EXCEPT_SYSCALL, EXCEPT_FPE, EXCEPT_TRAP
+} EXCEPT_NUMBER;
+
+/* Enum declaration for special purpose register groups.  */
+typedef enum spr_groups {
+  SPR_GROUP_SYS, SPR_GROUP_DMMU, SPR_GROUP_IMMU, SPR_GROUP_DCACHE
+ , SPR_GROUP_ICACHE, SPR_GROUP_MAC, SPR_GROUP_DEBUG, SPR_GROUP_PERF
+ , SPR_GROUP_POWER, SPR_GROUP_PIC, SPR_GROUP_TICK, SPR_GROUP_FPU
+} SPR_GROUPS;
+
+/* Enum declaration for special purpose register indicies.  */
+typedef enum spr_reg_indices {
+  SPR_INDEX_SYS_VR = 0, SPR_INDEX_SYS_UPR = 1, SPR_INDEX_SYS_CPUCFGR = 2, SPR_INDEX_SYS_DMMUCFGR = 3
+ , SPR_INDEX_SYS_IMMUCFGR = 4, SPR_INDEX_SYS_DCCFGR = 5, SPR_INDEX_SYS_ICCFGR = 6, SPR_INDEX_SYS_DCFGR = 7
+ , SPR_INDEX_SYS_PCCFGR = 8, SPR_INDEX_SYS_NPC = 16, SPR_INDEX_SYS_SR = 17, SPR_INDEX_SYS_PPC = 18
+ , SPR_INDEX_SYS_FPCSR = 20, SPR_INDEX_SYS_EPCR0 = 32, SPR_INDEX_SYS_EPCR1 = 33, SPR_INDEX_SYS_EPCR2 = 34
+ , SPR_INDEX_SYS_EPCR3 = 35, SPR_INDEX_SYS_EPCR4 = 36, SPR_INDEX_SYS_EPCR5 = 37, SPR_INDEX_SYS_EPCR6 = 38
+ , SPR_INDEX_SYS_EPCR7 = 39, SPR_INDEX_SYS_EPCR8 = 40, SPR_INDEX_SYS_EPCR9 = 41, SPR_INDEX_SYS_EPCR10 = 42
+ , SPR_INDEX_SYS_EPCR11 = 43, SPR_INDEX_SYS_EPCR12 = 44, SPR_INDEX_SYS_EPCR13 = 45, SPR_INDEX_SYS_EPCR14 = 46
+ , SPR_INDEX_SYS_EPCR15 = 47, SPR_INDEX_SYS_EEAR0 = 48, SPR_INDEX_SYS_EEAR1 = 49, SPR_INDEX_SYS_EEAR2 = 50
+ , SPR_INDEX_SYS_EEAR3 = 51, SPR_INDEX_SYS_EEAR4 = 52, SPR_INDEX_SYS_EEAR5 = 53, SPR_INDEX_SYS_EEAR6 = 54
+ , SPR_INDEX_SYS_EEAR7 = 55, SPR_INDEX_SYS_EEAR8 = 56, SPR_INDEX_SYS_EEAR9 = 57, SPR_INDEX_SYS_EEAR10 = 58
+ , SPR_INDEX_SYS_EEAR11 = 59, SPR_INDEX_SYS_EEAR12 = 60, SPR_INDEX_SYS_EEAR13 = 61, SPR_INDEX_SYS_EEAR14 = 62
+ , SPR_INDEX_SYS_EEAR15 = 63, SPR_INDEX_SYS_ESR0 = 64, SPR_INDEX_SYS_ESR1 = 65, SPR_INDEX_SYS_ESR2 = 66
+ , SPR_INDEX_SYS_ESR3 = 67, SPR_INDEX_SYS_ESR4 = 68, SPR_INDEX_SYS_ESR5 = 69, SPR_INDEX_SYS_ESR6 = 70
+ , SPR_INDEX_SYS_ESR7 = 71, SPR_INDEX_SYS_ESR8 = 72, SPR_INDEX_SYS_ESR9 = 73, SPR_INDEX_SYS_ESR10 = 74
+ , SPR_INDEX_SYS_ESR11 = 75, SPR_INDEX_SYS_ESR12 = 76, SPR_INDEX_SYS_ESR13 = 77, SPR_INDEX_SYS_ESR14 = 78
+ , SPR_INDEX_SYS_ESR15 = 79, SPR_INDEX_SYS_GPR0 = 1024, SPR_INDEX_SYS_GPR1 = 1025, SPR_INDEX_SYS_GPR2 = 1026
+ , SPR_INDEX_SYS_GPR3 = 1027, SPR_INDEX_SYS_GPR4 = 1028, SPR_INDEX_SYS_GPR5 = 1029, SPR_INDEX_SYS_GPR6 = 1030
+ , SPR_INDEX_SYS_GPR7 = 1031, SPR_INDEX_SYS_GPR8 = 1032, SPR_INDEX_SYS_GPR9 = 1033, SPR_INDEX_SYS_GPR10 = 1034
+ , SPR_INDEX_SYS_GPR11 = 1035, SPR_INDEX_SYS_GPR12 = 1036, SPR_INDEX_SYS_GPR13 = 1037, SPR_INDEX_SYS_GPR14 = 1038
+ , SPR_INDEX_SYS_GPR15 = 1039, SPR_INDEX_SYS_GPR16 = 1040, SPR_INDEX_SYS_GPR17 = 1041, SPR_INDEX_SYS_GPR18 = 1042
+ , SPR_INDEX_SYS_GPR19 = 1043, SPR_INDEX_SYS_GPR20 = 1044, SPR_INDEX_SYS_GPR21 = 1045, SPR_INDEX_SYS_GPR22 = 1046
+ , SPR_INDEX_SYS_GPR23 = 1047, SPR_INDEX_SYS_GPR24 = 1048, SPR_INDEX_SYS_GPR25 = 1049, SPR_INDEX_SYS_GPR26 = 1050
+ , SPR_INDEX_SYS_GPR27 = 1051, SPR_INDEX_SYS_GPR28 = 1052, SPR_INDEX_SYS_GPR29 = 1053, SPR_INDEX_SYS_GPR30 = 1054
+ , SPR_INDEX_SYS_GPR31 = 1055, SPR_INDEX_SYS_GPR32 = 1056, SPR_INDEX_SYS_GPR33 = 1057, SPR_INDEX_SYS_GPR34 = 1058
+ , SPR_INDEX_SYS_GPR35 = 1059, SPR_INDEX_SYS_GPR36 = 1060, SPR_INDEX_SYS_GPR37 = 1061, SPR_INDEX_SYS_GPR38 = 1062
+ , SPR_INDEX_SYS_GPR39 = 1063, SPR_INDEX_SYS_GPR40 = 1064, SPR_INDEX_SYS_GPR41 = 1065, SPR_INDEX_SYS_GPR42 = 1066
+ , SPR_INDEX_SYS_GPR43 = 1067, SPR_INDEX_SYS_GPR44 = 1068, SPR_INDEX_SYS_GPR45 = 1069, SPR_INDEX_SYS_GPR46 = 1070
+ , SPR_INDEX_SYS_GPR47 = 1071, SPR_INDEX_SYS_GPR48 = 1072, SPR_INDEX_SYS_GPR49 = 1073, SPR_INDEX_SYS_GPR50 = 1074
+ , SPR_INDEX_SYS_GPR51 = 1075, SPR_INDEX_SYS_GPR52 = 1076, SPR_INDEX_SYS_GPR53 = 1077, SPR_INDEX_SYS_GPR54 = 1078
+ , SPR_INDEX_SYS_GPR55 = 1079, SPR_INDEX_SYS_GPR56 = 1080, SPR_INDEX_SYS_GPR57 = 1081, SPR_INDEX_SYS_GPR58 = 1082
+ , SPR_INDEX_SYS_GPR59 = 1083, SPR_INDEX_SYS_GPR60 = 1084, SPR_INDEX_SYS_GPR61 = 1085, SPR_INDEX_SYS_GPR62 = 1086
+ , SPR_INDEX_SYS_GPR63 = 1087, SPR_INDEX_SYS_GPR64 = 1088, SPR_INDEX_SYS_GPR65 = 1089, SPR_INDEX_SYS_GPR66 = 1090
+ , SPR_INDEX_SYS_GPR67 = 1091, SPR_INDEX_SYS_GPR68 = 1092, SPR_INDEX_SYS_GPR69 = 1093, SPR_INDEX_SYS_GPR70 = 1094
+ , SPR_INDEX_SYS_GPR71 = 1095, SPR_INDEX_SYS_GPR72 = 1096, SPR_INDEX_SYS_GPR73 = 1097, SPR_INDEX_SYS_GPR74 = 1098
+ , SPR_INDEX_SYS_GPR75 = 1099, SPR_INDEX_SYS_GPR76 = 1100, SPR_INDEX_SYS_GPR77 = 1101, SPR_INDEX_SYS_GPR78 = 1102
+ , SPR_INDEX_SYS_GPR79 = 1103, SPR_INDEX_SYS_GPR80 = 1104, SPR_INDEX_SYS_GPR81 = 1105, SPR_INDEX_SYS_GPR82 = 1106
+ , SPR_INDEX_SYS_GPR83 = 1107, SPR_INDEX_SYS_GPR84 = 1108, SPR_INDEX_SYS_GPR85 = 1109, SPR_INDEX_SYS_GPR86 = 1110
+ , SPR_INDEX_SYS_GPR87 = 1111, SPR_INDEX_SYS_GPR88 = 1112, SPR_INDEX_SYS_GPR89 = 1113, SPR_INDEX_SYS_GPR90 = 1114
+ , SPR_INDEX_SYS_GPR91 = 1115, SPR_INDEX_SYS_GPR92 = 1116, SPR_INDEX_SYS_GPR93 = 1117, SPR_INDEX_SYS_GPR94 = 1118
+ , SPR_INDEX_SYS_GPR95 = 1119, SPR_INDEX_SYS_GPR96 = 1120, SPR_INDEX_SYS_GPR97 = 1121, SPR_INDEX_SYS_GPR98 = 1122
+ , SPR_INDEX_SYS_GPR99 = 1123, SPR_INDEX_SYS_GPR100 = 1124, SPR_INDEX_SYS_GPR101 = 1125, SPR_INDEX_SYS_GPR102 = 1126
+ , SPR_INDEX_SYS_GPR103 = 1127, SPR_INDEX_SYS_GPR104 = 1128, SPR_INDEX_SYS_GPR105 = 1129, SPR_INDEX_SYS_GPR106 = 1130
+ , SPR_INDEX_SYS_GPR107 = 1131, SPR_INDEX_SYS_GPR108 = 1132, SPR_INDEX_SYS_GPR109 = 1133, SPR_INDEX_SYS_GPR110 = 1134
+ , SPR_INDEX_SYS_GPR111 = 1135, SPR_INDEX_SYS_GPR112 = 1136, SPR_INDEX_SYS_GPR113 = 1137, SPR_INDEX_SYS_GPR114 = 1138
+ , SPR_INDEX_SYS_GPR115 = 1139, SPR_INDEX_SYS_GPR116 = 1140, SPR_INDEX_SYS_GPR117 = 1141, SPR_INDEX_SYS_GPR118 = 1142
+ , SPR_INDEX_SYS_GPR119 = 1143, SPR_INDEX_SYS_GPR120 = 1144, SPR_INDEX_SYS_GPR121 = 1145, SPR_INDEX_SYS_GPR122 = 1146
+ , SPR_INDEX_SYS_GPR123 = 1147, SPR_INDEX_SYS_GPR124 = 1148, SPR_INDEX_SYS_GPR125 = 1149, SPR_INDEX_SYS_GPR126 = 1150
+ , SPR_INDEX_SYS_GPR127 = 1151, SPR_INDEX_SYS_GPR128 = 1152, SPR_INDEX_SYS_GPR129 = 1153, SPR_INDEX_SYS_GPR130 = 1154
+ , SPR_INDEX_SYS_GPR131 = 1155, SPR_INDEX_SYS_GPR132 = 1156, SPR_INDEX_SYS_GPR133 = 1157, SPR_INDEX_SYS_GPR134 = 1158
+ , SPR_INDEX_SYS_GPR135 = 1159, SPR_INDEX_SYS_GPR136 = 1160, SPR_INDEX_SYS_GPR137 = 1161, SPR_INDEX_SYS_GPR138 = 1162
+ , SPR_INDEX_SYS_GPR139 = 1163, SPR_INDEX_SYS_GPR140 = 1164, SPR_INDEX_SYS_GPR141 = 1165, SPR_INDEX_SYS_GPR142 = 1166
+ , SPR_INDEX_SYS_GPR143 = 1167, SPR_INDEX_SYS_GPR144 = 1168, SPR_INDEX_SYS_GPR145 = 1169, SPR_INDEX_SYS_GPR146 = 1170
+ , SPR_INDEX_SYS_GPR147 = 1171, SPR_INDEX_SYS_GPR148 = 1172, SPR_INDEX_SYS_GPR149 = 1173, SPR_INDEX_SYS_GPR150 = 1174
+ , SPR_INDEX_SYS_GPR151 = 1175, SPR_INDEX_SYS_GPR152 = 1176, SPR_INDEX_SYS_GPR153 = 1177, SPR_INDEX_SYS_GPR154 = 1178
+ , SPR_INDEX_SYS_GPR155 = 1179, SPR_INDEX_SYS_GPR156 = 1180, SPR_INDEX_SYS_GPR157 = 1181, SPR_INDEX_SYS_GPR158 = 1182
+ , SPR_INDEX_SYS_GPR159 = 1183, SPR_INDEX_SYS_GPR160 = 1184, SPR_INDEX_SYS_GPR161 = 1185, SPR_INDEX_SYS_GPR162 = 1186
+ , SPR_INDEX_SYS_GPR163 = 1187, SPR_INDEX_SYS_GPR164 = 1188, SPR_INDEX_SYS_GPR165 = 1189, SPR_INDEX_SYS_GPR166 = 1190
+ , SPR_INDEX_SYS_GPR167 = 1191, SPR_INDEX_SYS_GPR168 = 1192, SPR_INDEX_SYS_GPR169 = 1193, SPR_INDEX_SYS_GPR170 = 1194
+ , SPR_INDEX_SYS_GPR171 = 1195, SPR_INDEX_SYS_GPR172 = 1196, SPR_INDEX_SYS_GPR173 = 1197, SPR_INDEX_SYS_GPR174 = 1198
+ , SPR_INDEX_SYS_GPR175 = 1199, SPR_INDEX_SYS_GPR176 = 1200, SPR_INDEX_SYS_GPR177 = 1201, SPR_INDEX_SYS_GPR178 = 1202
+ , SPR_INDEX_SYS_GPR179 = 1203, SPR_INDEX_SYS_GPR180 = 1204, SPR_INDEX_SYS_GPR181 = 1205, SPR_INDEX_SYS_GPR182 = 1206
+ , SPR_INDEX_SYS_GPR183 = 1207, SPR_INDEX_SYS_GPR184 = 1208, SPR_INDEX_SYS_GPR185 = 1209, SPR_INDEX_SYS_GPR186 = 1210
+ , SPR_INDEX_SYS_GPR187 = 1211, SPR_INDEX_SYS_GPR188 = 1212, SPR_INDEX_SYS_GPR189 = 1213, SPR_INDEX_SYS_GPR190 = 1214
+ , SPR_INDEX_SYS_GPR191 = 1215, SPR_INDEX_SYS_GPR192 = 1216, SPR_INDEX_SYS_GPR193 = 1217, SPR_INDEX_SYS_GPR194 = 1218
+ , SPR_INDEX_SYS_GPR195 = 1219, SPR_INDEX_SYS_GPR196 = 1220, SPR_INDEX_SYS_GPR197 = 1221, SPR_INDEX_SYS_GPR198 = 1222
+ , SPR_INDEX_SYS_GPR199 = 1223, SPR_INDEX_SYS_GPR200 = 1224, SPR_INDEX_SYS_GPR201 = 1225, SPR_INDEX_SYS_GPR202 = 1226
+ , SPR_INDEX_SYS_GPR203 = 1227, SPR_INDEX_SYS_GPR204 = 1228, SPR_INDEX_SYS_GPR205 = 1229, SPR_INDEX_SYS_GPR206 = 1230
+ , SPR_INDEX_SYS_GPR207 = 1231, SPR_INDEX_SYS_GPR208 = 1232, SPR_INDEX_SYS_GPR209 = 1233, SPR_INDEX_SYS_GPR210 = 1234
+ , SPR_INDEX_SYS_GPR211 = 1235, SPR_INDEX_SYS_GPR212 = 1236, SPR_INDEX_SYS_GPR213 = 1237, SPR_INDEX_SYS_GPR214 = 1238
+ , SPR_INDEX_SYS_GPR215 = 1239, SPR_INDEX_SYS_GPR216 = 1240, SPR_INDEX_SYS_GPR217 = 1241, SPR_INDEX_SYS_GPR218 = 1242
+ , SPR_INDEX_SYS_GPR219 = 1243, SPR_INDEX_SYS_GPR220 = 1244, SPR_INDEX_SYS_GPR221 = 1245, SPR_INDEX_SYS_GPR222 = 1246
+ , SPR_INDEX_SYS_GPR223 = 1247, SPR_INDEX_SYS_GPR224 = 1248, SPR_INDEX_SYS_GPR225 = 1249, SPR_INDEX_SYS_GPR226 = 1250
+ , SPR_INDEX_SYS_GPR227 = 1251, SPR_INDEX_SYS_GPR228 = 1252, SPR_INDEX_SYS_GPR229 = 1253, SPR_INDEX_SYS_GPR230 = 1254
+ , SPR_INDEX_SYS_GPR231 = 1255, SPR_INDEX_SYS_GPR232 = 1256, SPR_INDEX_SYS_GPR233 = 1257, SPR_INDEX_SYS_GPR234 = 1258
+ , SPR_INDEX_SYS_GPR235 = 1259, SPR_INDEX_SYS_GPR236 = 1260, SPR_INDEX_SYS_GPR237 = 1261, SPR_INDEX_SYS_GPR238 = 1262
+ , SPR_INDEX_SYS_GPR239 = 1263, SPR_INDEX_SYS_GPR240 = 1264, SPR_INDEX_SYS_GPR241 = 1265, SPR_INDEX_SYS_GPR242 = 1266
+ , SPR_INDEX_SYS_GPR243 = 1267, SPR_INDEX_SYS_GPR244 = 1268, SPR_INDEX_SYS_GPR245 = 1269, SPR_INDEX_SYS_GPR246 = 1270
+ , SPR_INDEX_SYS_GPR247 = 1271, SPR_INDEX_SYS_GPR248 = 1272, SPR_INDEX_SYS_GPR249 = 1273, SPR_INDEX_SYS_GPR250 = 1274
+ , SPR_INDEX_SYS_GPR251 = 1275, SPR_INDEX_SYS_GPR252 = 1276, SPR_INDEX_SYS_GPR253 = 1277, SPR_INDEX_SYS_GPR254 = 1278
+ , SPR_INDEX_SYS_GPR255 = 1279, SPR_INDEX_SYS_GPR256 = 1280, SPR_INDEX_SYS_GPR257 = 1281, SPR_INDEX_SYS_GPR258 = 1282
+ , SPR_INDEX_SYS_GPR259 = 1283, SPR_INDEX_SYS_GPR260 = 1284, SPR_INDEX_SYS_GPR261 = 1285, SPR_INDEX_SYS_GPR262 = 1286
+ , SPR_INDEX_SYS_GPR263 = 1287, SPR_INDEX_SYS_GPR264 = 1288, SPR_INDEX_SYS_GPR265 = 1289, SPR_INDEX_SYS_GPR266 = 1290
+ , SPR_INDEX_SYS_GPR267 = 1291, SPR_INDEX_SYS_GPR268 = 1292, SPR_INDEX_SYS_GPR269 = 1293, SPR_INDEX_SYS_GPR270 = 1294
+ , SPR_INDEX_SYS_GPR271 = 1295, SPR_INDEX_SYS_GPR272 = 1296, SPR_INDEX_SYS_GPR273 = 1297, SPR_INDEX_SYS_GPR274 = 1298
+ , SPR_INDEX_SYS_GPR275 = 1299, SPR_INDEX_SYS_GPR276 = 1300, SPR_INDEX_SYS_GPR277 = 1301, SPR_INDEX_SYS_GPR278 = 1302
+ , SPR_INDEX_SYS_GPR279 = 1303, SPR_INDEX_SYS_GPR280 = 1304, SPR_INDEX_SYS_GPR281 = 1305, SPR_INDEX_SYS_GPR282 = 1306
+ , SPR_INDEX_SYS_GPR283 = 1307, SPR_INDEX_SYS_GPR284 = 1308, SPR_INDEX_SYS_GPR285 = 1309, SPR_INDEX_SYS_GPR286 = 1310
+ , SPR_INDEX_SYS_GPR287 = 1311, SPR_INDEX_SYS_GPR288 = 1312, SPR_INDEX_SYS_GPR289 = 1313, SPR_INDEX_SYS_GPR290 = 1314
+ , SPR_INDEX_SYS_GPR291 = 1315, SPR_INDEX_SYS_GPR292 = 1316, SPR_INDEX_SYS_GPR293 = 1317, SPR_INDEX_SYS_GPR294 = 1318
+ , SPR_INDEX_SYS_GPR295 = 1319, SPR_INDEX_SYS_GPR296 = 1320, SPR_INDEX_SYS_GPR297 = 1321, SPR_INDEX_SYS_GPR298 = 1322
+ , SPR_INDEX_SYS_GPR299 = 1323, SPR_INDEX_SYS_GPR300 = 1324, SPR_INDEX_SYS_GPR301 = 1325, SPR_INDEX_SYS_GPR302 = 1326
+ , SPR_INDEX_SYS_GPR303 = 1327, SPR_INDEX_SYS_GPR304 = 1328, SPR_INDEX_SYS_GPR305 = 1329, SPR_INDEX_SYS_GPR306 = 1330
+ , SPR_INDEX_SYS_GPR307 = 1331, SPR_INDEX_SYS_GPR308 = 1332, SPR_INDEX_SYS_GPR309 = 1333, SPR_INDEX_SYS_GPR310 = 1334
+ , SPR_INDEX_SYS_GPR311 = 1335, SPR_INDEX_SYS_GPR312 = 1336, SPR_INDEX_SYS_GPR313 = 1337, SPR_INDEX_SYS_GPR314 = 1338
+ , SPR_INDEX_SYS_GPR315 = 1339, SPR_INDEX_SYS_GPR316 = 1340, SPR_INDEX_SYS_GPR317 = 1341, SPR_INDEX_SYS_GPR318 = 1342
+ , SPR_INDEX_SYS_GPR319 = 1343, SPR_INDEX_SYS_GPR320 = 1344, SPR_INDEX_SYS_GPR321 = 1345, SPR_INDEX_SYS_GPR322 = 1346
+ , SPR_INDEX_SYS_GPR323 = 1347, SPR_INDEX_SYS_GPR324 = 1348, SPR_INDEX_SYS_GPR325 = 1349, SPR_INDEX_SYS_GPR326 = 1350
+ , SPR_INDEX_SYS_GPR327 = 1351, SPR_INDEX_SYS_GPR328 = 1352, SPR_INDEX_SYS_GPR329 = 1353, SPR_INDEX_SYS_GPR330 = 1354
+ , SPR_INDEX_SYS_GPR331 = 1355, SPR_INDEX_SYS_GPR332 = 1356, SPR_INDEX_SYS_GPR333 = 1357, SPR_INDEX_SYS_GPR334 = 1358
+ , SPR_INDEX_SYS_GPR335 = 1359, SPR_INDEX_SYS_GPR336 = 1360, SPR_INDEX_SYS_GPR337 = 1361, SPR_INDEX_SYS_GPR338 = 1362
+ , SPR_INDEX_SYS_GPR339 = 1363, SPR_INDEX_SYS_GPR340 = 1364, SPR_INDEX_SYS_GPR341 = 1365, SPR_INDEX_SYS_GPR342 = 1366
+ , SPR_INDEX_SYS_GPR343 = 1367, SPR_INDEX_SYS_GPR344 = 1368, SPR_INDEX_SYS_GPR345 = 1369, SPR_INDEX_SYS_GPR346 = 1370
+ , SPR_INDEX_SYS_GPR347 = 1371, SPR_INDEX_SYS_GPR348 = 1372, SPR_INDEX_SYS_GPR349 = 1373, SPR_INDEX_SYS_GPR350 = 1374
+ , SPR_INDEX_SYS_GPR351 = 1375, SPR_INDEX_SYS_GPR352 = 1376, SPR_INDEX_SYS_GPR353 = 1377, SPR_INDEX_SYS_GPR354 = 1378
+ , SPR_INDEX_SYS_GPR355 = 1379, SPR_INDEX_SYS_GPR356 = 1380, SPR_INDEX_SYS_GPR357 = 1381, SPR_INDEX_SYS_GPR358 = 1382
+ , SPR_INDEX_SYS_GPR359 = 1383, SPR_INDEX_SYS_GPR360 = 1384, SPR_INDEX_SYS_GPR361 = 1385, SPR_INDEX_SYS_GPR362 = 1386
+ , SPR_INDEX_SYS_GPR363 = 1387, SPR_INDEX_SYS_GPR364 = 1388, SPR_INDEX_SYS_GPR365 = 1389, SPR_INDEX_SYS_GPR366 = 1390
+ , SPR_INDEX_SYS_GPR367 = 1391, SPR_INDEX_SYS_GPR368 = 1392, SPR_INDEX_SYS_GPR369 = 1393, SPR_INDEX_SYS_GPR370 = 1394
+ , SPR_INDEX_SYS_GPR371 = 1395, SPR_INDEX_SYS_GPR372 = 1396, SPR_INDEX_SYS_GPR373 = 1397, SPR_INDEX_SYS_GPR374 = 1398
+ , SPR_INDEX_SYS_GPR375 = 1399, SPR_INDEX_SYS_GPR376 = 1400, SPR_INDEX_SYS_GPR377 = 1401, SPR_INDEX_SYS_GPR378 = 1402
+ , SPR_INDEX_SYS_GPR379 = 1403, SPR_INDEX_SYS_GPR380 = 1404, SPR_INDEX_SYS_GPR381 = 1405, SPR_INDEX_SYS_GPR382 = 1406
+ , SPR_INDEX_SYS_GPR383 = 1407, SPR_INDEX_SYS_GPR384 = 1408, SPR_INDEX_SYS_GPR385 = 1409, SPR_INDEX_SYS_GPR386 = 1410
+ , SPR_INDEX_SYS_GPR387 = 1411, SPR_INDEX_SYS_GPR388 = 1412, SPR_INDEX_SYS_GPR389 = 1413, SPR_INDEX_SYS_GPR390 = 1414
+ , SPR_INDEX_SYS_GPR391 = 1415, SPR_INDEX_SYS_GPR392 = 1416, SPR_INDEX_SYS_GPR393 = 1417, SPR_INDEX_SYS_GPR394 = 1418
+ , SPR_INDEX_SYS_GPR395 = 1419, SPR_INDEX_SYS_GPR396 = 1420, SPR_INDEX_SYS_GPR397 = 1421, SPR_INDEX_SYS_GPR398 = 1422
+ , SPR_INDEX_SYS_GPR399 = 1423, SPR_INDEX_SYS_GPR400 = 1424, SPR_INDEX_SYS_GPR401 = 1425, SPR_INDEX_SYS_GPR402 = 1426
+ , SPR_INDEX_SYS_GPR403 = 1427, SPR_INDEX_SYS_GPR404 = 1428, SPR_INDEX_SYS_GPR405 = 1429, SPR_INDEX_SYS_GPR406 = 1430
+ , SPR_INDEX_SYS_GPR407 = 1431, SPR_INDEX_SYS_GPR408 = 1432, SPR_INDEX_SYS_GPR409 = 1433, SPR_INDEX_SYS_GPR410 = 1434
+ , SPR_INDEX_SYS_GPR411 = 1435, SPR_INDEX_SYS_GPR412 = 1436, SPR_INDEX_SYS_GPR413 = 1437, SPR_INDEX_SYS_GPR414 = 1438
+ , SPR_INDEX_SYS_GPR415 = 1439, SPR_INDEX_SYS_GPR416 = 1440, SPR_INDEX_SYS_GPR417 = 1441, SPR_INDEX_SYS_GPR418 = 1442
+ , SPR_INDEX_SYS_GPR419 = 1443, SPR_INDEX_SYS_GPR420 = 1444, SPR_INDEX_SYS_GPR421 = 1445, SPR_INDEX_SYS_GPR422 = 1446
+ , SPR_INDEX_SYS_GPR423 = 1447, SPR_INDEX_SYS_GPR424 = 1448, SPR_INDEX_SYS_GPR425 = 1449, SPR_INDEX_SYS_GPR426 = 1450
+ , SPR_INDEX_SYS_GPR427 = 1451, SPR_INDEX_SYS_GPR428 = 1452, SPR_INDEX_SYS_GPR429 = 1453, SPR_INDEX_SYS_GPR430 = 1454
+ , SPR_INDEX_SYS_GPR431 = 1455, SPR_INDEX_SYS_GPR432 = 1456, SPR_INDEX_SYS_GPR433 = 1457, SPR_INDEX_SYS_GPR434 = 1458
+ , SPR_INDEX_SYS_GPR435 = 1459, SPR_INDEX_SYS_GPR436 = 1460, SPR_INDEX_SYS_GPR437 = 1461, SPR_INDEX_SYS_GPR438 = 1462
+ , SPR_INDEX_SYS_GPR439 = 1463, SPR_INDEX_SYS_GPR440 = 1464, SPR_INDEX_SYS_GPR441 = 1465, SPR_INDEX_SYS_GPR442 = 1466
+ , SPR_INDEX_SYS_GPR443 = 1467, SPR_INDEX_SYS_GPR444 = 1468, SPR_INDEX_SYS_GPR445 = 1469, SPR_INDEX_SYS_GPR446 = 1470
+ , SPR_INDEX_SYS_GPR447 = 1471, SPR_INDEX_SYS_GPR448 = 1472, SPR_INDEX_SYS_GPR449 = 1473, SPR_INDEX_SYS_GPR450 = 1474
+ , SPR_INDEX_SYS_GPR451 = 1475, SPR_INDEX_SYS_GPR452 = 1476, SPR_INDEX_SYS_GPR453 = 1477, SPR_INDEX_SYS_GPR454 = 1478
+ , SPR_INDEX_SYS_GPR455 = 1479, SPR_INDEX_SYS_GPR456 = 1480, SPR_INDEX_SYS_GPR457 = 1481, SPR_INDEX_SYS_GPR458 = 1482
+ , SPR_INDEX_SYS_GPR459 = 1483, SPR_INDEX_SYS_GPR460 = 1484, SPR_INDEX_SYS_GPR461 = 1485, SPR_INDEX_SYS_GPR462 = 1486
+ , SPR_INDEX_SYS_GPR463 = 1487, SPR_INDEX_SYS_GPR464 = 1488, SPR_INDEX_SYS_GPR465 = 1489, SPR_INDEX_SYS_GPR466 = 1490
+ , SPR_INDEX_SYS_GPR467 = 1491, SPR_INDEX_SYS_GPR468 = 1492, SPR_INDEX_SYS_GPR469 = 1493, SPR_INDEX_SYS_GPR470 = 1494
+ , SPR_INDEX_SYS_GPR471 = 1495, SPR_INDEX_SYS_GPR472 = 1496, SPR_INDEX_SYS_GPR473 = 1497, SPR_INDEX_SYS_GPR474 = 1498
+ , SPR_INDEX_SYS_GPR475 = 1499, SPR_INDEX_SYS_GPR476 = 1500, SPR_INDEX_SYS_GPR477 = 1501, SPR_INDEX_SYS_GPR478 = 1502
+ , SPR_INDEX_SYS_GPR479 = 1503, SPR_INDEX_SYS_GPR480 = 1504, SPR_INDEX_SYS_GPR481 = 1505, SPR_INDEX_SYS_GPR482 = 1506
+ , SPR_INDEX_SYS_GPR483 = 1507, SPR_INDEX_SYS_GPR484 = 1508, SPR_INDEX_SYS_GPR485 = 1509, SPR_INDEX_SYS_GPR486 = 1510
+ , SPR_INDEX_SYS_GPR487 = 1511, SPR_INDEX_SYS_GPR488 = 1512, SPR_INDEX_SYS_GPR489 = 1513, SPR_INDEX_SYS_GPR490 = 1514
+ , SPR_INDEX_SYS_GPR491 = 1515, SPR_INDEX_SYS_GPR492 = 1516, SPR_INDEX_SYS_GPR493 = 1517, SPR_INDEX_SYS_GPR494 = 1518
+ , SPR_INDEX_SYS_GPR495 = 1519, SPR_INDEX_SYS_GPR496 = 1520, SPR_INDEX_SYS_GPR497 = 1521, SPR_INDEX_SYS_GPR498 = 1522
+ , SPR_INDEX_SYS_GPR499 = 1523, SPR_INDEX_SYS_GPR500 = 1524, SPR_INDEX_SYS_GPR501 = 1525, SPR_INDEX_SYS_GPR502 = 1526
+ , SPR_INDEX_SYS_GPR503 = 1527, SPR_INDEX_SYS_GPR504 = 1528, SPR_INDEX_SYS_GPR505 = 1529, SPR_INDEX_SYS_GPR506 = 1530
+ , SPR_INDEX_SYS_GPR507 = 1531, SPR_INDEX_SYS_GPR508 = 1532, SPR_INDEX_SYS_GPR509 = 1533, SPR_INDEX_SYS_GPR510 = 1534
+ , SPR_INDEX_SYS_GPR511 = 1535, SPR_INDEX_MAC_MACLO = 1, SPR_INDEX_MAC_MACHI = 2, SPR_INDEX_TICK_TTMR = 0
+} SPR_REG_INDICES;
+
+/* Enum declaration for SPR field msb positions.  */
+typedef enum spr_field_msbs {
+  SPR_FIELD_MSB_SYS_VR_REV = 5, SPR_FIELD_MSB_SYS_VR_CFG = 23, SPR_FIELD_MSB_SYS_VR_VER = 31, SPR_FIELD_MSB_SYS_UPR_UP = 0
+ , SPR_FIELD_MSB_SYS_UPR_DCP = 1, SPR_FIELD_MSB_SYS_UPR_ICP = 2, SPR_FIELD_MSB_SYS_UPR_DMP = 3, SPR_FIELD_MSB_SYS_UPR_MP = 4
+ , SPR_FIELD_MSB_SYS_UPR_IMP = 5, SPR_FIELD_MSB_SYS_UPR_DUP = 6, SPR_FIELD_MSB_SYS_UPR_PCUP = 7, SPR_FIELD_MSB_SYS_UPR_PICP = 8
+ , SPR_FIELD_MSB_SYS_UPR_PMP = 9, SPR_FIELD_MSB_SYS_UPR_TTP = 10, SPR_FIELD_MSB_SYS_UPR_CUP = 31, SPR_FIELD_MSB_SYS_CPUCFGR_NSGR = 3
+ , SPR_FIELD_MSB_SYS_CPUCFGR_CGF = 4, SPR_FIELD_MSB_SYS_CPUCFGR_OB32S = 5, SPR_FIELD_MSB_SYS_CPUCFGR_OB64S = 6, SPR_FIELD_MSB_SYS_CPUCFGR_OF32S = 7
+ , SPR_FIELD_MSB_SYS_CPUCFGR_OF64S = 8, SPR_FIELD_MSB_SYS_CPUCFGR_OV64S = 9, SPR_FIELD_MSB_SYS_CPUCFGR_ND = 10, SPR_FIELD_MSB_SYS_SR_SM = 0
+ , SPR_FIELD_MSB_SYS_SR_TEE = 1, SPR_FIELD_MSB_SYS_SR_IEE = 2, SPR_FIELD_MSB_SYS_SR_DCE = 3, SPR_FIELD_MSB_SYS_SR_ICE = 4
+ , SPR_FIELD_MSB_SYS_SR_DME = 5, SPR_FIELD_MSB_SYS_SR_IME = 6, SPR_FIELD_MSB_SYS_SR_LEE = 7, SPR_FIELD_MSB_SYS_SR_CE = 8
+ , SPR_FIELD_MSB_SYS_SR_F = 9, SPR_FIELD_MSB_SYS_SR_CY = 10, SPR_FIELD_MSB_SYS_SR_OV = 11, SPR_FIELD_MSB_SYS_SR_OVE = 12
+ , SPR_FIELD_MSB_SYS_SR_DSX = 13, SPR_FIELD_MSB_SYS_SR_EPH = 14, SPR_FIELD_MSB_SYS_SR_FO = 15, SPR_FIELD_MSB_SYS_SR_SUMRA = 16
+ , SPR_FIELD_MSB_SYS_SR_CID = 31, SPR_FIELD_MSB_SYS_FPCSR_FPEE = 0, SPR_FIELD_MSB_SYS_FPCSR_RM = 2, SPR_FIELD_MSB_SYS_FPCSR_OVF = 3
+ , SPR_FIELD_MSB_SYS_FPCSR_UNF = 4, SPR_FIELD_MSB_SYS_FPCSR_SNF = 5, SPR_FIELD_MSB_SYS_FPCSR_QNF = 6, SPR_FIELD_MSB_SYS_FPCSR_ZF = 7
+ , SPR_FIELD_MSB_SYS_FPCSR_IXF = 8, SPR_FIELD_MSB_SYS_FPCSR_IVF = 9, SPR_FIELD_MSB_SYS_FPCSR_INF = 10, SPR_FIELD_MSB_SYS_FPCSR_DZF = 11
+} SPR_FIELD_MSBS;
+
+/* Enum declaration for SPR field lsb positions.  */
+typedef enum spr_field_lsbs {
+  SPR_FIELD_SIZE_SYS_VR_REV = 0, SPR_FIELD_SIZE_SYS_VR_CFG = 16, SPR_FIELD_SIZE_SYS_VR_VER = 24, SPR_FIELD_SIZE_SYS_UPR_UP = 0
+ , SPR_FIELD_SIZE_SYS_UPR_DCP = 1, SPR_FIELD_SIZE_SYS_UPR_ICP = 2, SPR_FIELD_SIZE_SYS_UPR_DMP = 3, SPR_FIELD_SIZE_SYS_UPR_MP = 4
+ , SPR_FIELD_SIZE_SYS_UPR_IMP = 5, SPR_FIELD_SIZE_SYS_UPR_DUP = 6, SPR_FIELD_SIZE_SYS_UPR_PCUP = 7, SPR_FIELD_SIZE_SYS_UPR_PICP = 8
+ , SPR_FIELD_SIZE_SYS_UPR_PMP = 9, SPR_FIELD_SIZE_SYS_UPR_TTP = 10, SPR_FIELD_SIZE_SYS_UPR_CUP = 24, SPR_FIELD_SIZE_SYS_CPUCFGR_NSGR = 0
+ , SPR_FIELD_SIZE_SYS_CPUCFGR_CGF = 4, SPR_FIELD_SIZE_SYS_CPUCFGR_OB32S = 5, SPR_FIELD_SIZE_SYS_CPUCFGR_OB64S = 6, SPR_FIELD_SIZE_SYS_CPUCFGR_OF32S = 7
+ , SPR_FIELD_SIZE_SYS_CPUCFGR_OF64S = 8, SPR_FIELD_SIZE_SYS_CPUCFGR_OV64S = 9, SPR_FIELD_SIZE_SYS_CPUCFGR_ND = 10, SPR_FIELD_SIZE_SYS_SR_SM = 0
+ , SPR_FIELD_SIZE_SYS_SR_TEE = 1, SPR_FIELD_SIZE_SYS_SR_IEE = 2, SPR_FIELD_SIZE_SYS_SR_DCE = 3, SPR_FIELD_SIZE_SYS_SR_ICE = 4
+ , SPR_FIELD_SIZE_SYS_SR_DME = 5, SPR_FIELD_SIZE_SYS_SR_IME = 6, SPR_FIELD_SIZE_SYS_SR_LEE = 7, SPR_FIELD_SIZE_SYS_SR_CE = 8
+ , SPR_FIELD_SIZE_SYS_SR_F = 9, SPR_FIELD_SIZE_SYS_SR_CY = 10, SPR_FIELD_SIZE_SYS_SR_OV = 11, SPR_FIELD_SIZE_SYS_SR_OVE = 12
+ , SPR_FIELD_SIZE_SYS_SR_DSX = 13, SPR_FIELD_SIZE_SYS_SR_EPH = 14, SPR_FIELD_SIZE_SYS_SR_FO = 15, SPR_FIELD_SIZE_SYS_SR_SUMRA = 16
+ , SPR_FIELD_SIZE_SYS_SR_CID = 28, SPR_FIELD_SIZE_SYS_FPCSR_FPEE = 0, SPR_FIELD_SIZE_SYS_FPCSR_RM = 1, SPR_FIELD_SIZE_SYS_FPCSR_OVF = 3
+ , SPR_FIELD_SIZE_SYS_FPCSR_UNF = 4, SPR_FIELD_SIZE_SYS_FPCSR_SNF = 5, SPR_FIELD_SIZE_SYS_FPCSR_QNF = 6, SPR_FIELD_SIZE_SYS_FPCSR_ZF = 7
+ , SPR_FIELD_SIZE_SYS_FPCSR_IXF = 8, SPR_FIELD_SIZE_SYS_FPCSR_IVF = 9, SPR_FIELD_SIZE_SYS_FPCSR_INF = 10, SPR_FIELD_SIZE_SYS_FPCSR_DZF = 11
+} SPR_FIELD_LSBS;
+
+/* Enum declaration for SPR field masks.  */
+typedef enum spr_field_masks {
+  SPR_FIELD_MASK_SYS_VR_REV = 63, SPR_FIELD_MASK_SYS_VR_CFG = 16711680, SPR_FIELD_MASK_SYS_VR_VER = 4278190080, SPR_FIELD_MASK_SYS_UPR_UP = 1
+ , SPR_FIELD_MASK_SYS_UPR_DCP = 2, SPR_FIELD_MASK_SYS_UPR_ICP = 4, SPR_FIELD_MASK_SYS_UPR_DMP = 8, SPR_FIELD_MASK_SYS_UPR_MP = 16
+ , SPR_FIELD_MASK_SYS_UPR_IMP = 32, SPR_FIELD_MASK_SYS_UPR_DUP = 64, SPR_FIELD_MASK_SYS_UPR_PCUP = 128, SPR_FIELD_MASK_SYS_UPR_PICP = 256
+ , SPR_FIELD_MASK_SYS_UPR_PMP = 512, SPR_FIELD_MASK_SYS_UPR_TTP = 1024, SPR_FIELD_MASK_SYS_UPR_CUP = 4278190080, SPR_FIELD_MASK_SYS_CPUCFGR_NSGR = 15
+ , SPR_FIELD_MASK_SYS_CPUCFGR_CGF = 16, SPR_FIELD_MASK_SYS_CPUCFGR_OB32S = 32, SPR_FIELD_MASK_SYS_CPUCFGR_OB64S = 64, SPR_FIELD_MASK_SYS_CPUCFGR_OF32S = 128
+ , SPR_FIELD_MASK_SYS_CPUCFGR_OF64S = 256, SPR_FIELD_MASK_SYS_CPUCFGR_OV64S = 512, SPR_FIELD_MASK_SYS_CPUCFGR_ND = 1024, SPR_FIELD_MASK_SYS_SR_SM = 1
+ , SPR_FIELD_MASK_SYS_SR_TEE = 2, SPR_FIELD_MASK_SYS_SR_IEE = 4, SPR_FIELD_MASK_SYS_SR_DCE = 8, SPR_FIELD_MASK_SYS_SR_ICE = 16
+ , SPR_FIELD_MASK_SYS_SR_DME = 32, SPR_FIELD_MASK_SYS_SR_IME = 64, SPR_FIELD_MASK_SYS_SR_LEE = 128, SPR_FIELD_MASK_SYS_SR_CE = 256
+ , SPR_FIELD_MASK_SYS_SR_F = 512, SPR_FIELD_MASK_SYS_SR_CY = 1024, SPR_FIELD_MASK_SYS_SR_OV = 2048, SPR_FIELD_MASK_SYS_SR_OVE = 4096
+ , SPR_FIELD_MASK_SYS_SR_DSX = 8192, SPR_FIELD_MASK_SYS_SR_EPH = 16384, SPR_FIELD_MASK_SYS_SR_FO = 32768, SPR_FIELD_MASK_SYS_SR_SUMRA = 65536
+ , SPR_FIELD_MASK_SYS_SR_CID = 4026531840, SPR_FIELD_MASK_SYS_FPCSR_FPEE = 1, SPR_FIELD_MASK_SYS_FPCSR_RM = 6, SPR_FIELD_MASK_SYS_FPCSR_OVF = 8
+ , SPR_FIELD_MASK_SYS_FPCSR_UNF = 16, SPR_FIELD_MASK_SYS_FPCSR_SNF = 32, SPR_FIELD_MASK_SYS_FPCSR_QNF = 64, SPR_FIELD_MASK_SYS_FPCSR_ZF = 128
+ , SPR_FIELD_MASK_SYS_FPCSR_IXF = 256, SPR_FIELD_MASK_SYS_FPCSR_IVF = 512, SPR_FIELD_MASK_SYS_FPCSR_INF = 1024, SPR_FIELD_MASK_SYS_FPCSR_DZF = 2048
+} SPR_FIELD_MASKS;
+
+/* Enum declaration for insn main opcode enums.  */
+typedef enum insn_opcode {
+  OPC_J = 0, OPC_JAL = 1, OPC_BNF = 3, OPC_BF = 4
+ , OPC_NOP = 5, OPC_MOVHIMACRC = 6, OPC_SYSTRAPSYNCS = 8, OPC_RFE = 9
+ , OPC_VECTOR = 10, OPC_JR = 17, OPC_JALR = 18, OPC_MACI = 19
+ , OPC_CUST1 = 28, OPC_CUST2 = 29, OPC_CUST3 = 30, OPC_CUST4 = 31
+ , OPC_LD = 32, OPC_LWZ = 33, OPC_LWS = 34, OPC_LBZ = 35
+ , OPC_LBS = 36, OPC_LHZ = 37, OPC_LHS = 38, OPC_ADDI = 39
+ , OPC_ADDIC = 40, OPC_ANDI = 41, OPC_ORI = 42, OPC_XORI = 43
+ , OPC_MULI = 44, OPC_MFSPR = 45, OPC_SHROTI = 46, OPC_SFI = 47
+ , OPC_MTSPR = 48, OPC_MAC = 49, OPC_FLOAT = 50, OPC_SD = 52
+ , OPC_SW = 53, OPC_SB = 54, OPC_SH = 55, OPC_ALU = 56
+ , OPC_SF = 57, OPC_CUST5 = 60, OPC_CUST6 = 61, OPC_CUST7 = 62
+ , OPC_CUST8 = 63
+} INSN_OPCODE;
+
+/* Enum declaration for systrapsync insn opcode enums.  */
+typedef enum insn_opcode_systrapsyncs {
+  OPC_SYSTRAPSYNCS_SYSCALL = 0, OPC_SYSTRAPSYNCS_TRAP = 8, OPC_SYSTRAPSYNCS_MSYNC = 16, OPC_SYSTRAPSYNCS_PSYNC = 20
+ , OPC_SYSTRAPSYNCS_CSYNC = 24
+} INSN_OPCODE_SYSTRAPSYNCS;
+
+/* Enum declaration for movhi/macrc insn opcode enums.  */
+typedef enum insn_opcode_movehimacrc {
+  OPC_MOVHIMACRC_MOVHI, OPC_MOVHIMACRC_MACRC
+} INSN_OPCODE_MOVEHIMACRC;
+
+/* Enum declaration for multiply/accumulate insn opcode enums.  */
+typedef enum insn_opcode_mac {
+  OPC_MAC_MAC = 1, OPC_MAC_MSB = 2
+} INSN_OPCODE_MAC;
+
+/* Enum declaration for shift/rotate insn opcode enums.  */
+typedef enum insn_opcode_shorts {
+  OPC_SHROTS_SLL, OPC_SHROTS_SRL, OPC_SHROTS_SRA, OPC_SHROTS_ROR
+} INSN_OPCODE_SHORTS;
+
+/* Enum declaration for extend byte/half opcode enums.  */
+typedef enum insn_opcode_extbhs {
+  OPC_EXTBHS_EXTHS, OPC_EXTBHS_EXTBS, OPC_EXTBHS_EXTHZ, OPC_EXTBHS_EXTBZ
+} INSN_OPCODE_EXTBHS;
+
+/* Enum declaration for extend word opcode enums.  */
+typedef enum insn_opcode_extws {
+  OPC_EXTWS_EXTWS, OPC_EXTWS_EXTWZ
+} INSN_OPCODE_EXTWS;
+
+/* Enum declaration for alu reg/reg insn opcode enums.  */
+typedef enum insn_opcode_alu_regreg {
+  OPC_ALU_REGREG_ADD = 0, OPC_ALU_REGREG_ADDC = 1, OPC_ALU_REGREG_SUB = 2, OPC_ALU_REGREG_AND = 3
+ , OPC_ALU_REGREG_OR = 4, OPC_ALU_REGREG_XOR = 5, OPC_ALU_REGREG_MUL = 6, OPC_ALU_REGREG_SHROT = 8
+ , OPC_ALU_REGREG_DIV = 9, OPC_ALU_REGREG_DIVU = 10, OPC_ALU_REGREG_MULU = 11, OPC_ALU_REGREG_EXTBH = 12
+ , OPC_ALU_REGREG_EXTW = 13, OPC_ALU_REGREG_CMOV = 14, OPC_ALU_REGREG_FFL1 = 15
+} INSN_OPCODE_ALU_REGREG;
+
+/* Enum declaration for setflag insn opcode enums.  */
+typedef enum insn_opcode_setflag {
+  OPC_SF_EQ = 0, OPC_SF_NE = 1, OPC_SF_GTU = 2, OPC_SF_GEU = 3
+ , OPC_SF_LTU = 4, OPC_SF_LEU = 5, OPC_SF_GTS = 10, OPC_SF_GES = 11
+ , OPC_SF_LTS = 12, OPC_SF_LES = 13
+} INSN_OPCODE_SETFLAG;
+
+/* Enum declaration for floating point reg/reg insn opcode enums.  */
+typedef enum insn_opcode_float_regreg {
+  OPC_FLOAT_REGREG_ADD_S = 0, OPC_FLOAT_REGREG_SUB_S = 1, OPC_FLOAT_REGREG_MUL_S = 2, OPC_FLOAT_REGREG_DIV_S = 3
+ , OPC_FLOAT_REGREG_ITOF_S = 4, OPC_FLOAT_REGREG_FTOI_S = 5, OPC_FLOAT_REGREG_REM_S = 6, OPC_FLOAT_REGREG_MADD_S = 7
+ , OPC_FLOAT_REGREG_SFEQ_S = 8, OPC_FLOAT_REGREG_SFNE_S = 9, OPC_FLOAT_REGREG_SFGT_S = 10, OPC_FLOAT_REGREG_SFGE_S = 11
+ , OPC_FLOAT_REGREG_SFLT_S = 12, OPC_FLOAT_REGREG_SFLE_S = 13, OPC_FLOAT_REGREG_ADD_D = 16, OPC_FLOAT_REGREG_SUB_D = 17
+ , OPC_FLOAT_REGREG_MUL_D = 18, OPC_FLOAT_REGREG_DIV_D = 19, OPC_FLOAT_REGREG_ITOF_D = 20, OPC_FLOAT_REGREG_FTOI_D = 21
+ , OPC_FLOAT_REGREG_REM_D = 22, OPC_FLOAT_REGREG_MADD_D = 23, OPC_FLOAT_REGREG_SFEQ_D = 24, OPC_FLOAT_REGREG_SFNE_D = 25
+ , OPC_FLOAT_REGREG_SFGT_D = 26, OPC_FLOAT_REGREG_SFGE_D = 27, OPC_FLOAT_REGREG_SFLT_D = 28, OPC_FLOAT_REGREG_SFLE_D = 29
+ , OPC_FLOAT_REGREG_CUST1_S = 208, OPC_FLOAT_REGREG_CUST1_D = 224
+} INSN_OPCODE_FLOAT_REGREG;
+
+/* Attributes.  */
+
+/* Enum declaration for machine type selection.  */
+typedef enum mach_attr {
+  MACH_BASE, MACH_OR32, MACH_OR32ND, MACH_OR64
+ , MACH_OR64ND, MACH_MAX
+} MACH_ATTR;
+
+/* Enum declaration for instruction set selection.  */
+typedef enum isa_attr {
+  ISA_OPENRISC, ISA_MAX
+} ISA_ATTR;
+
+/* Number of architecture variants.  */
+#define MAX_ISAS  1
+#define MAX_MACHS ((int) MACH_MAX)
+
+/* Ifield support.  */
+
+/* Ifield attribute indices.  */
+
+/* Enum declaration for cgen_ifld attrs.  */
+typedef enum cgen_ifld_attr {
+  CGEN_IFLD_VIRTUAL, CGEN_IFLD_PCREL_ADDR, CGEN_IFLD_ABS_ADDR, CGEN_IFLD_RESERVED
+ , CGEN_IFLD_SIGN_OPT, CGEN_IFLD_SIGNED, CGEN_IFLD_END_BOOLS, CGEN_IFLD_START_NBOOLS = 31
+ , CGEN_IFLD_MACH, CGEN_IFLD_END_NBOOLS
+} CGEN_IFLD_ATTR;
+
+/* Number of non-boolean elements in cgen_ifld_attr.  */
+#define CGEN_IFLD_NBOOL_ATTRS (CGEN_IFLD_END_NBOOLS - CGEN_IFLD_START_NBOOLS - 1)
+
+/* cgen_ifld attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_IFLD_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_IFLD_MACH-CGEN_IFLD_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_IFLD_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_RESERVED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_RESERVED)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_IFLD_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_IFLD_SIGNED)) != 0)
+
+/* Enum declaration for or1k ifield types.  */
+typedef enum ifield_type {
+  OR1K_F_NIL, OR1K_F_ANYOF, OR1K_F_OPCODE, OR1K_F_R1
+ , OR1K_F_R2, OR1K_F_R3, OR1K_F_OP_25_2, OR1K_F_OP_25_5
+ , OR1K_F_OP_16_1, OR1K_F_OP_7_4, OR1K_F_OP_3_4, OR1K_F_OP_9_2
+ , OR1K_F_OP_9_4, OR1K_F_OP_7_8, OR1K_F_OP_7_2, OR1K_F_RESV_25_26
+ , OR1K_F_RESV_25_10, OR1K_F_RESV_25_5, OR1K_F_RESV_23_8, OR1K_F_RESV_20_5
+ , OR1K_F_RESV_20_4, OR1K_F_RESV_15_8, OR1K_F_RESV_15_6, OR1K_F_RESV_10_11
+ , OR1K_F_RESV_10_7, OR1K_F_RESV_10_3, OR1K_F_RESV_10_1, OR1K_F_RESV_7_4
+ , OR1K_F_RESV_5_2, OR1K_F_IMM16_25_5, OR1K_F_IMM16_10_11, OR1K_F_DISP26
+ , OR1K_F_UIMM16, OR1K_F_SIMM16, OR1K_F_UIMM6, OR1K_F_UIMM16_SPLIT
+ , OR1K_F_SIMM16_SPLIT, OR1K_F_MAX
+} IFIELD_TYPE;
+
+#define MAX_IFLD ((int) OR1K_F_MAX)
+
+/* Hardware attribute indices.  */
+
+/* Enum declaration for cgen_hw attrs.  */
+typedef enum cgen_hw_attr {
+  CGEN_HW_VIRTUAL, CGEN_HW_CACHE_ADDR, CGEN_HW_PC, CGEN_HW_PROFILE
+ , CGEN_HW_END_BOOLS, CGEN_HW_START_NBOOLS = 31, CGEN_HW_MACH, CGEN_HW_END_NBOOLS
+} CGEN_HW_ATTR;
+
+/* Number of non-boolean elements in cgen_hw_attr.  */
+#define CGEN_HW_NBOOL_ATTRS (CGEN_HW_END_NBOOLS - CGEN_HW_START_NBOOLS - 1)
+
+/* cgen_hw attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_HW_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_HW_MACH-CGEN_HW_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_HW_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_HW_CACHE_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_CACHE_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_HW_PC_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PC)) != 0)
+#define CGEN_ATTR_CGEN_HW_PROFILE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_HW_PROFILE)) != 0)
+
+/* Enum declaration for or1k hardware types.  */
+typedef enum cgen_hw_type {
+  HW_H_MEMORY, HW_H_SINT, HW_H_UINT, HW_H_ADDR
+ , HW_H_IADDR, HW_H_PC, HW_H_FSR, HW_H_FDR
+ , HW_H_SPR, HW_H_GPR, HW_H_SYS_VR, HW_H_SYS_UPR
+ , HW_H_SYS_CPUCFGR, HW_H_SYS_DMMUCFGR, HW_H_SYS_IMMUCFGR, HW_H_SYS_DCCFGR
+ , HW_H_SYS_ICCFGR, HW_H_SYS_DCFGR, HW_H_SYS_PCCFGR, HW_H_SYS_NPC
+ , HW_H_SYS_SR, HW_H_SYS_PPC, HW_H_SYS_FPCSR, HW_H_SYS_EPCR0
+ , HW_H_SYS_EPCR1, HW_H_SYS_EPCR2, HW_H_SYS_EPCR3, HW_H_SYS_EPCR4
+ , HW_H_SYS_EPCR5, HW_H_SYS_EPCR6, HW_H_SYS_EPCR7, HW_H_SYS_EPCR8
+ , HW_H_SYS_EPCR9, HW_H_SYS_EPCR10, HW_H_SYS_EPCR11, HW_H_SYS_EPCR12
+ , HW_H_SYS_EPCR13, HW_H_SYS_EPCR14, HW_H_SYS_EPCR15, HW_H_SYS_EEAR0
+ , HW_H_SYS_EEAR1, HW_H_SYS_EEAR2, HW_H_SYS_EEAR3, HW_H_SYS_EEAR4
+ , HW_H_SYS_EEAR5, HW_H_SYS_EEAR6, HW_H_SYS_EEAR7, HW_H_SYS_EEAR8
+ , HW_H_SYS_EEAR9, HW_H_SYS_EEAR10, HW_H_SYS_EEAR11, HW_H_SYS_EEAR12
+ , HW_H_SYS_EEAR13, HW_H_SYS_EEAR14, HW_H_SYS_EEAR15, HW_H_SYS_ESR0
+ , HW_H_SYS_ESR1, HW_H_SYS_ESR2, HW_H_SYS_ESR3, HW_H_SYS_ESR4
+ , HW_H_SYS_ESR5, HW_H_SYS_ESR6, HW_H_SYS_ESR7, HW_H_SYS_ESR8
+ , HW_H_SYS_ESR9, HW_H_SYS_ESR10, HW_H_SYS_ESR11, HW_H_SYS_ESR12
+ , HW_H_SYS_ESR13, HW_H_SYS_ESR14, HW_H_SYS_ESR15, HW_H_SYS_GPR0
+ , HW_H_SYS_GPR1, HW_H_SYS_GPR2, HW_H_SYS_GPR3, HW_H_SYS_GPR4
+ , HW_H_SYS_GPR5, HW_H_SYS_GPR6, HW_H_SYS_GPR7, HW_H_SYS_GPR8
+ , HW_H_SYS_GPR9, HW_H_SYS_GPR10, HW_H_SYS_GPR11, HW_H_SYS_GPR12
+ , HW_H_SYS_GPR13, HW_H_SYS_GPR14, HW_H_SYS_GPR15, HW_H_SYS_GPR16
+ , HW_H_SYS_GPR17, HW_H_SYS_GPR18, HW_H_SYS_GPR19, HW_H_SYS_GPR20
+ , HW_H_SYS_GPR21, HW_H_SYS_GPR22, HW_H_SYS_GPR23, HW_H_SYS_GPR24
+ , HW_H_SYS_GPR25, HW_H_SYS_GPR26, HW_H_SYS_GPR27, HW_H_SYS_GPR28
+ , HW_H_SYS_GPR29, HW_H_SYS_GPR30, HW_H_SYS_GPR31, HW_H_SYS_GPR32
+ , HW_H_SYS_GPR33, HW_H_SYS_GPR34, HW_H_SYS_GPR35, HW_H_SYS_GPR36
+ , HW_H_SYS_GPR37, HW_H_SYS_GPR38, HW_H_SYS_GPR39, HW_H_SYS_GPR40
+ , HW_H_SYS_GPR41, HW_H_SYS_GPR42, HW_H_SYS_GPR43, HW_H_SYS_GPR44
+ , HW_H_SYS_GPR45, HW_H_SYS_GPR46, HW_H_SYS_GPR47, HW_H_SYS_GPR48
+ , HW_H_SYS_GPR49, HW_H_SYS_GPR50, HW_H_SYS_GPR51, HW_H_SYS_GPR52
+ , HW_H_SYS_GPR53, HW_H_SYS_GPR54, HW_H_SYS_GPR55, HW_H_SYS_GPR56
+ , HW_H_SYS_GPR57, HW_H_SYS_GPR58, HW_H_SYS_GPR59, HW_H_SYS_GPR60
+ , HW_H_SYS_GPR61, HW_H_SYS_GPR62, HW_H_SYS_GPR63, HW_H_SYS_GPR64
+ , HW_H_SYS_GPR65, HW_H_SYS_GPR66, HW_H_SYS_GPR67, HW_H_SYS_GPR68
+ , HW_H_SYS_GPR69, HW_H_SYS_GPR70, HW_H_SYS_GPR71, HW_H_SYS_GPR72
+ , HW_H_SYS_GPR73, HW_H_SYS_GPR74, HW_H_SYS_GPR75, HW_H_SYS_GPR76
+ , HW_H_SYS_GPR77, HW_H_SYS_GPR78, HW_H_SYS_GPR79, HW_H_SYS_GPR80
+ , HW_H_SYS_GPR81, HW_H_SYS_GPR82, HW_H_SYS_GPR83, HW_H_SYS_GPR84
+ , HW_H_SYS_GPR85, HW_H_SYS_GPR86, HW_H_SYS_GPR87, HW_H_SYS_GPR88
+ , HW_H_SYS_GPR89, HW_H_SYS_GPR90, HW_H_SYS_GPR91, HW_H_SYS_GPR92
+ , HW_H_SYS_GPR93, HW_H_SYS_GPR94, HW_H_SYS_GPR95, HW_H_SYS_GPR96
+ , HW_H_SYS_GPR97, HW_H_SYS_GPR98, HW_H_SYS_GPR99, HW_H_SYS_GPR100
+ , HW_H_SYS_GPR101, HW_H_SYS_GPR102, HW_H_SYS_GPR103, HW_H_SYS_GPR104
+ , HW_H_SYS_GPR105, HW_H_SYS_GPR106, HW_H_SYS_GPR107, HW_H_SYS_GPR108
+ , HW_H_SYS_GPR109, HW_H_SYS_GPR110, HW_H_SYS_GPR111, HW_H_SYS_GPR112
+ , HW_H_SYS_GPR113, HW_H_SYS_GPR114, HW_H_SYS_GPR115, HW_H_SYS_GPR116
+ , HW_H_SYS_GPR117, HW_H_SYS_GPR118, HW_H_SYS_GPR119, HW_H_SYS_GPR120
+ , HW_H_SYS_GPR121, HW_H_SYS_GPR122, HW_H_SYS_GPR123, HW_H_SYS_GPR124
+ , HW_H_SYS_GPR125, HW_H_SYS_GPR126, HW_H_SYS_GPR127, HW_H_SYS_GPR128
+ , HW_H_SYS_GPR129, HW_H_SYS_GPR130, HW_H_SYS_GPR131, HW_H_SYS_GPR132
+ , HW_H_SYS_GPR133, HW_H_SYS_GPR134, HW_H_SYS_GPR135, HW_H_SYS_GPR136
+ , HW_H_SYS_GPR137, HW_H_SYS_GPR138, HW_H_SYS_GPR139, HW_H_SYS_GPR140
+ , HW_H_SYS_GPR141, HW_H_SYS_GPR142, HW_H_SYS_GPR143, HW_H_SYS_GPR144
+ , HW_H_SYS_GPR145, HW_H_SYS_GPR146, HW_H_SYS_GPR147, HW_H_SYS_GPR148
+ , HW_H_SYS_GPR149, HW_H_SYS_GPR150, HW_H_SYS_GPR151, HW_H_SYS_GPR152
+ , HW_H_SYS_GPR153, HW_H_SYS_GPR154, HW_H_SYS_GPR155, HW_H_SYS_GPR156
+ , HW_H_SYS_GPR157, HW_H_SYS_GPR158, HW_H_SYS_GPR159, HW_H_SYS_GPR160
+ , HW_H_SYS_GPR161, HW_H_SYS_GPR162, HW_H_SYS_GPR163, HW_H_SYS_GPR164
+ , HW_H_SYS_GPR165, HW_H_SYS_GPR166, HW_H_SYS_GPR167, HW_H_SYS_GPR168
+ , HW_H_SYS_GPR169, HW_H_SYS_GPR170, HW_H_SYS_GPR171, HW_H_SYS_GPR172
+ , HW_H_SYS_GPR173, HW_H_SYS_GPR174, HW_H_SYS_GPR175, HW_H_SYS_GPR176
+ , HW_H_SYS_GPR177, HW_H_SYS_GPR178, HW_H_SYS_GPR179, HW_H_SYS_GPR180
+ , HW_H_SYS_GPR181, HW_H_SYS_GPR182, HW_H_SYS_GPR183, HW_H_SYS_GPR184
+ , HW_H_SYS_GPR185, HW_H_SYS_GPR186, HW_H_SYS_GPR187, HW_H_SYS_GPR188
+ , HW_H_SYS_GPR189, HW_H_SYS_GPR190, HW_H_SYS_GPR191, HW_H_SYS_GPR192
+ , HW_H_SYS_GPR193, HW_H_SYS_GPR194, HW_H_SYS_GPR195, HW_H_SYS_GPR196
+ , HW_H_SYS_GPR197, HW_H_SYS_GPR198, HW_H_SYS_GPR199, HW_H_SYS_GPR200
+ , HW_H_SYS_GPR201, HW_H_SYS_GPR202, HW_H_SYS_GPR203, HW_H_SYS_GPR204
+ , HW_H_SYS_GPR205, HW_H_SYS_GPR206, HW_H_SYS_GPR207, HW_H_SYS_GPR208
+ , HW_H_SYS_GPR209, HW_H_SYS_GPR210, HW_H_SYS_GPR211, HW_H_SYS_GPR212
+ , HW_H_SYS_GPR213, HW_H_SYS_GPR214, HW_H_SYS_GPR215, HW_H_SYS_GPR216
+ , HW_H_SYS_GPR217, HW_H_SYS_GPR218, HW_H_SYS_GPR219, HW_H_SYS_GPR220
+ , HW_H_SYS_GPR221, HW_H_SYS_GPR222, HW_H_SYS_GPR223, HW_H_SYS_GPR224
+ , HW_H_SYS_GPR225, HW_H_SYS_GPR226, HW_H_SYS_GPR227, HW_H_SYS_GPR228
+ , HW_H_SYS_GPR229, HW_H_SYS_GPR230, HW_H_SYS_GPR231, HW_H_SYS_GPR232
+ , HW_H_SYS_GPR233, HW_H_SYS_GPR234, HW_H_SYS_GPR235, HW_H_SYS_GPR236
+ , HW_H_SYS_GPR237, HW_H_SYS_GPR238, HW_H_SYS_GPR239, HW_H_SYS_GPR240
+ , HW_H_SYS_GPR241, HW_H_SYS_GPR242, HW_H_SYS_GPR243, HW_H_SYS_GPR244
+ , HW_H_SYS_GPR245, HW_H_SYS_GPR246, HW_H_SYS_GPR247, HW_H_SYS_GPR248
+ , HW_H_SYS_GPR249, HW_H_SYS_GPR250, HW_H_SYS_GPR251, HW_H_SYS_GPR252
+ , HW_H_SYS_GPR253, HW_H_SYS_GPR254, HW_H_SYS_GPR255, HW_H_SYS_GPR256
+ , HW_H_SYS_GPR257, HW_H_SYS_GPR258, HW_H_SYS_GPR259, HW_H_SYS_GPR260
+ , HW_H_SYS_GPR261, HW_H_SYS_GPR262, HW_H_SYS_GPR263, HW_H_SYS_GPR264
+ , HW_H_SYS_GPR265, HW_H_SYS_GPR266, HW_H_SYS_GPR267, HW_H_SYS_GPR268
+ , HW_H_SYS_GPR269, HW_H_SYS_GPR270, HW_H_SYS_GPR271, HW_H_SYS_GPR272
+ , HW_H_SYS_GPR273, HW_H_SYS_GPR274, HW_H_SYS_GPR275, HW_H_SYS_GPR276
+ , HW_H_SYS_GPR277, HW_H_SYS_GPR278, HW_H_SYS_GPR279, HW_H_SYS_GPR280
+ , HW_H_SYS_GPR281, HW_H_SYS_GPR282, HW_H_SYS_GPR283, HW_H_SYS_GPR284
+ , HW_H_SYS_GPR285, HW_H_SYS_GPR286, HW_H_SYS_GPR287, HW_H_SYS_GPR288
+ , HW_H_SYS_GPR289, HW_H_SYS_GPR290, HW_H_SYS_GPR291, HW_H_SYS_GPR292
+ , HW_H_SYS_GPR293, HW_H_SYS_GPR294, HW_H_SYS_GPR295, HW_H_SYS_GPR296
+ , HW_H_SYS_GPR297, HW_H_SYS_GPR298, HW_H_SYS_GPR299, HW_H_SYS_GPR300
+ , HW_H_SYS_GPR301, HW_H_SYS_GPR302, HW_H_SYS_GPR303, HW_H_SYS_GPR304
+ , HW_H_SYS_GPR305, HW_H_SYS_GPR306, HW_H_SYS_GPR307, HW_H_SYS_GPR308
+ , HW_H_SYS_GPR309, HW_H_SYS_GPR310, HW_H_SYS_GPR311, HW_H_SYS_GPR312
+ , HW_H_SYS_GPR313, HW_H_SYS_GPR314, HW_H_SYS_GPR315, HW_H_SYS_GPR316
+ , HW_H_SYS_GPR317, HW_H_SYS_GPR318, HW_H_SYS_GPR319, HW_H_SYS_GPR320
+ , HW_H_SYS_GPR321, HW_H_SYS_GPR322, HW_H_SYS_GPR323, HW_H_SYS_GPR324
+ , HW_H_SYS_GPR325, HW_H_SYS_GPR326, HW_H_SYS_GPR327, HW_H_SYS_GPR328
+ , HW_H_SYS_GPR329, HW_H_SYS_GPR330, HW_H_SYS_GPR331, HW_H_SYS_GPR332
+ , HW_H_SYS_GPR333, HW_H_SYS_GPR334, HW_H_SYS_GPR335, HW_H_SYS_GPR336
+ , HW_H_SYS_GPR337, HW_H_SYS_GPR338, HW_H_SYS_GPR339, HW_H_SYS_GPR340
+ , HW_H_SYS_GPR341, HW_H_SYS_GPR342, HW_H_SYS_GPR343, HW_H_SYS_GPR344
+ , HW_H_SYS_GPR345, HW_H_SYS_GPR346, HW_H_SYS_GPR347, HW_H_SYS_GPR348
+ , HW_H_SYS_GPR349, HW_H_SYS_GPR350, HW_H_SYS_GPR351, HW_H_SYS_GPR352
+ , HW_H_SYS_GPR353, HW_H_SYS_GPR354, HW_H_SYS_GPR355, HW_H_SYS_GPR356
+ , HW_H_SYS_GPR357, HW_H_SYS_GPR358, HW_H_SYS_GPR359, HW_H_SYS_GPR360
+ , HW_H_SYS_GPR361, HW_H_SYS_GPR362, HW_H_SYS_GPR363, HW_H_SYS_GPR364
+ , HW_H_SYS_GPR365, HW_H_SYS_GPR366, HW_H_SYS_GPR367, HW_H_SYS_GPR368
+ , HW_H_SYS_GPR369, HW_H_SYS_GPR370, HW_H_SYS_GPR371, HW_H_SYS_GPR372
+ , HW_H_SYS_GPR373, HW_H_SYS_GPR374, HW_H_SYS_GPR375, HW_H_SYS_GPR376
+ , HW_H_SYS_GPR377, HW_H_SYS_GPR378, HW_H_SYS_GPR379, HW_H_SYS_GPR380
+ , HW_H_SYS_GPR381, HW_H_SYS_GPR382, HW_H_SYS_GPR383, HW_H_SYS_GPR384
+ , HW_H_SYS_GPR385, HW_H_SYS_GPR386, HW_H_SYS_GPR387, HW_H_SYS_GPR388
+ , HW_H_SYS_GPR389, HW_H_SYS_GPR390, HW_H_SYS_GPR391, HW_H_SYS_GPR392
+ , HW_H_SYS_GPR393, HW_H_SYS_GPR394, HW_H_SYS_GPR395, HW_H_SYS_GPR396
+ , HW_H_SYS_GPR397, HW_H_SYS_GPR398, HW_H_SYS_GPR399, HW_H_SYS_GPR400
+ , HW_H_SYS_GPR401, HW_H_SYS_GPR402, HW_H_SYS_GPR403, HW_H_SYS_GPR404
+ , HW_H_SYS_GPR405, HW_H_SYS_GPR406, HW_H_SYS_GPR407, HW_H_SYS_GPR408
+ , HW_H_SYS_GPR409, HW_H_SYS_GPR410, HW_H_SYS_GPR411, HW_H_SYS_GPR412
+ , HW_H_SYS_GPR413, HW_H_SYS_GPR414, HW_H_SYS_GPR415, HW_H_SYS_GPR416
+ , HW_H_SYS_GPR417, HW_H_SYS_GPR418, HW_H_SYS_GPR419, HW_H_SYS_GPR420
+ , HW_H_SYS_GPR421, HW_H_SYS_GPR422, HW_H_SYS_GPR423, HW_H_SYS_GPR424
+ , HW_H_SYS_GPR425, HW_H_SYS_GPR426, HW_H_SYS_GPR427, HW_H_SYS_GPR428
+ , HW_H_SYS_GPR429, HW_H_SYS_GPR430, HW_H_SYS_GPR431, HW_H_SYS_GPR432
+ , HW_H_SYS_GPR433, HW_H_SYS_GPR434, HW_H_SYS_GPR435, HW_H_SYS_GPR436
+ , HW_H_SYS_GPR437, HW_H_SYS_GPR438, HW_H_SYS_GPR439, HW_H_SYS_GPR440
+ , HW_H_SYS_GPR441, HW_H_SYS_GPR442, HW_H_SYS_GPR443, HW_H_SYS_GPR444
+ , HW_H_SYS_GPR445, HW_H_SYS_GPR446, HW_H_SYS_GPR447, HW_H_SYS_GPR448
+ , HW_H_SYS_GPR449, HW_H_SYS_GPR450, HW_H_SYS_GPR451, HW_H_SYS_GPR452
+ , HW_H_SYS_GPR453, HW_H_SYS_GPR454, HW_H_SYS_GPR455, HW_H_SYS_GPR456
+ , HW_H_SYS_GPR457, HW_H_SYS_GPR458, HW_H_SYS_GPR459, HW_H_SYS_GPR460
+ , HW_H_SYS_GPR461, HW_H_SYS_GPR462, HW_H_SYS_GPR463, HW_H_SYS_GPR464
+ , HW_H_SYS_GPR465, HW_H_SYS_GPR466, HW_H_SYS_GPR467, HW_H_SYS_GPR468
+ , HW_H_SYS_GPR469, HW_H_SYS_GPR470, HW_H_SYS_GPR471, HW_H_SYS_GPR472
+ , HW_H_SYS_GPR473, HW_H_SYS_GPR474, HW_H_SYS_GPR475, HW_H_SYS_GPR476
+ , HW_H_SYS_GPR477, HW_H_SYS_GPR478, HW_H_SYS_GPR479, HW_H_SYS_GPR480
+ , HW_H_SYS_GPR481, HW_H_SYS_GPR482, HW_H_SYS_GPR483, HW_H_SYS_GPR484
+ , HW_H_SYS_GPR485, HW_H_SYS_GPR486, HW_H_SYS_GPR487, HW_H_SYS_GPR488
+ , HW_H_SYS_GPR489, HW_H_SYS_GPR490, HW_H_SYS_GPR491, HW_H_SYS_GPR492
+ , HW_H_SYS_GPR493, HW_H_SYS_GPR494, HW_H_SYS_GPR495, HW_H_SYS_GPR496
+ , HW_H_SYS_GPR497, HW_H_SYS_GPR498, HW_H_SYS_GPR499, HW_H_SYS_GPR500
+ , HW_H_SYS_GPR501, HW_H_SYS_GPR502, HW_H_SYS_GPR503, HW_H_SYS_GPR504
+ , HW_H_SYS_GPR505, HW_H_SYS_GPR506, HW_H_SYS_GPR507, HW_H_SYS_GPR508
+ , HW_H_SYS_GPR509, HW_H_SYS_GPR510, HW_H_SYS_GPR511, HW_H_MAC_MACLO
+ , HW_H_MAC_MACHI, HW_H_TICK_TTMR, HW_H_SYS_VR_REV, HW_H_SYS_VR_CFG
+ , HW_H_SYS_VR_VER, HW_H_SYS_UPR_UP, HW_H_SYS_UPR_DCP, HW_H_SYS_UPR_ICP
+ , HW_H_SYS_UPR_DMP, HW_H_SYS_UPR_MP, HW_H_SYS_UPR_IMP, HW_H_SYS_UPR_DUP
+ , HW_H_SYS_UPR_PCUP, HW_H_SYS_UPR_PICP, HW_H_SYS_UPR_PMP, HW_H_SYS_UPR_TTP
+ , HW_H_SYS_UPR_CUP, HW_H_SYS_CPUCFGR_NSGR, HW_H_SYS_CPUCFGR_CGF, HW_H_SYS_CPUCFGR_OB32S
+ , HW_H_SYS_CPUCFGR_OB64S, HW_H_SYS_CPUCFGR_OF32S, HW_H_SYS_CPUCFGR_OF64S, HW_H_SYS_CPUCFGR_OV64S
+ , HW_H_SYS_CPUCFGR_ND, HW_H_SYS_SR_SM, HW_H_SYS_SR_TEE, HW_H_SYS_SR_IEE
+ , HW_H_SYS_SR_DCE, HW_H_SYS_SR_ICE, HW_H_SYS_SR_DME, HW_H_SYS_SR_IME
+ , HW_H_SYS_SR_LEE, HW_H_SYS_SR_CE, HW_H_SYS_SR_F, HW_H_SYS_SR_CY
+ , HW_H_SYS_SR_OV, HW_H_SYS_SR_OVE, HW_H_SYS_SR_DSX, HW_H_SYS_SR_EPH
+ , HW_H_SYS_SR_FO, HW_H_SYS_SR_SUMRA, HW_H_SYS_SR_CID, HW_H_SYS_FPCSR_FPEE
+ , HW_H_SYS_FPCSR_RM, HW_H_SYS_FPCSR_OVF, HW_H_SYS_FPCSR_UNF, HW_H_SYS_FPCSR_SNF
+ , HW_H_SYS_FPCSR_QNF, HW_H_SYS_FPCSR_ZF, HW_H_SYS_FPCSR_IXF, HW_H_SYS_FPCSR_IVF
+ , HW_H_SYS_FPCSR_INF, HW_H_SYS_FPCSR_DZF, HW_H_SIMM16, HW_H_UIMM16
+ , HW_H_UIMM6, HW_MAX
+} CGEN_HW_TYPE;
+
+#define MAX_HW ((int) HW_MAX)
+
+/* Operand attribute indices.  */
+
+/* Enum declaration for cgen_operand attrs.  */
+typedef enum cgen_operand_attr {
+  CGEN_OPERAND_VIRTUAL, CGEN_OPERAND_PCREL_ADDR, CGEN_OPERAND_ABS_ADDR, CGEN_OPERAND_SIGN_OPT
+ , CGEN_OPERAND_SIGNED, CGEN_OPERAND_NEGATIVE, CGEN_OPERAND_RELAX, CGEN_OPERAND_SEM_ONLY
+ , CGEN_OPERAND_END_BOOLS, CGEN_OPERAND_START_NBOOLS = 31, CGEN_OPERAND_MACH, CGEN_OPERAND_END_NBOOLS
+} CGEN_OPERAND_ATTR;
+
+/* Number of non-boolean elements in cgen_operand_attr.  */
+#define CGEN_OPERAND_NBOOL_ATTRS (CGEN_OPERAND_END_NBOOLS - CGEN_OPERAND_START_NBOOLS - 1)
+
+/* cgen_operand attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_OPERAND_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_OPERAND_MACH-CGEN_OPERAND_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_OPERAND_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_PCREL_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_PCREL_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_ABS_ADDR_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_ABS_ADDR)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGN_OPT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGN_OPT)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SIGNED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SIGNED)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_NEGATIVE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_NEGATIVE)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_RELAX_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_RELAX)) != 0)
+#define CGEN_ATTR_CGEN_OPERAND_SEM_ONLY_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_OPERAND_SEM_ONLY)) != 0)
+
+/* Enum declaration for or1k operand types.  */
+typedef enum cgen_operand_type {
+  OR1K_OPERAND_PC, OR1K_OPERAND_SYS_SR, OR1K_OPERAND_SYS_ESR0, OR1K_OPERAND_SYS_EPCR0
+ , OR1K_OPERAND_SYS_SR_LEE, OR1K_OPERAND_SYS_SR_F, OR1K_OPERAND_SYS_SR_CY, OR1K_OPERAND_SYS_SR_OV
+ , OR1K_OPERAND_SYS_SR_OVE, OR1K_OPERAND_SYS_CPUCFGR_OB64S, OR1K_OPERAND_SYS_CPUCFGR_ND, OR1K_OPERAND_SYS_FPCSR_RM
+ , OR1K_OPERAND_MAC_MACHI, OR1K_OPERAND_MAC_MACLO, OR1K_OPERAND_UIMM6, OR1K_OPERAND_RD
+ , OR1K_OPERAND_RA, OR1K_OPERAND_RB, OR1K_OPERAND_DISP26, OR1K_OPERAND_SIMM16
+ , OR1K_OPERAND_UIMM16, OR1K_OPERAND_SIMM16_SPLIT, OR1K_OPERAND_UIMM16_SPLIT, OR1K_OPERAND_RDSF
+ , OR1K_OPERAND_RASF, OR1K_OPERAND_RBSF, OR1K_OPERAND_RDDF, OR1K_OPERAND_RADF
+ , OR1K_OPERAND_RBDF, OR1K_OPERAND_MAX
+} CGEN_OPERAND_TYPE;
+
+/* Number of operands types.  */
+#define MAX_OPERANDS 29
+
+/* Maximum number of operands referenced by any insn.  */
+#define MAX_OPERAND_INSTANCES 9
+
+/* Insn attribute indices.  */
+
+/* Enum declaration for cgen_insn attrs.  */
+typedef enum cgen_insn_attr {
+  CGEN_INSN_ALIAS, CGEN_INSN_VIRTUAL, CGEN_INSN_UNCOND_CTI, CGEN_INSN_COND_CTI
+ , CGEN_INSN_SKIP_CTI, CGEN_INSN_DELAY_SLOT, CGEN_INSN_RELAXABLE, CGEN_INSN_RELAXED
+ , CGEN_INSN_NO_DIS, CGEN_INSN_PBB, CGEN_INSN_DELAYED_CTI, CGEN_INSN_NOT_IN_DELAY_SLOT
+ , CGEN_INSN_FORCED_CTI, CGEN_INSN_END_BOOLS, CGEN_INSN_START_NBOOLS = 31, CGEN_INSN_MACH
+ , CGEN_INSN_END_NBOOLS
+} CGEN_INSN_ATTR;
+
+/* Number of non-boolean elements in cgen_insn_attr.  */
+#define CGEN_INSN_NBOOL_ATTRS (CGEN_INSN_END_NBOOLS - CGEN_INSN_START_NBOOLS - 1)
+
+/* cgen_insn attribute accessor macros.  */
+#define CGEN_ATTR_CGEN_INSN_MACH_VALUE(attrs) ((attrs)->nonbool[CGEN_INSN_MACH-CGEN_INSN_START_NBOOLS-1].nonbitset)
+#define CGEN_ATTR_CGEN_INSN_ALIAS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_ALIAS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_VIRTUAL_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_VIRTUAL)) != 0)
+#define CGEN_ATTR_CGEN_INSN_UNCOND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_UNCOND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_COND_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_COND_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_SKIP_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_SKIP_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAY_SLOT)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXABLE_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXABLE)) != 0)
+#define CGEN_ATTR_CGEN_INSN_RELAXED_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_RELAXED)) != 0)
+#define CGEN_ATTR_CGEN_INSN_NO_DIS_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NO_DIS)) != 0)
+#define CGEN_ATTR_CGEN_INSN_PBB_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_PBB)) != 0)
+#define CGEN_ATTR_CGEN_INSN_DELAYED_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_DELAYED_CTI)) != 0)
+#define CGEN_ATTR_CGEN_INSN_NOT_IN_DELAY_SLOT_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_NOT_IN_DELAY_SLOT)) != 0)
+#define CGEN_ATTR_CGEN_INSN_FORCED_CTI_VALUE(attrs) (((attrs)->bool_ & (1 << CGEN_INSN_FORCED_CTI)) != 0)
+
+/* cgen.h uses things we just defined.  */
+#include "opcode/cgen.h"
+
+extern const struct cgen_ifld or1k_cgen_ifld_table[];
+
+/* Attributes.  */
+extern const CGEN_ATTR_TABLE or1k_cgen_hardware_attr_table[];
+extern const CGEN_ATTR_TABLE or1k_cgen_ifield_attr_table[];
+extern const CGEN_ATTR_TABLE or1k_cgen_operand_attr_table[];
+extern const CGEN_ATTR_TABLE or1k_cgen_insn_attr_table[];
+
+/* Hardware decls.  */
+
+extern CGEN_KEYWORD or1k_cgen_opval_h_fsr;
+extern CGEN_KEYWORD or1k_cgen_opval_h_fdr;
+extern CGEN_KEYWORD or1k_cgen_opval_h_gpr;
+
+extern const CGEN_HW_ENTRY or1k_cgen_hw_table[];
+
+
+
+#endif /* OR1K_CPU_H */
--- /dev/null
+++ b/opcodes/or1k-dis.c
@@ -0,0 +1,562 @@
+/* Disassembler interface for targets using CGEN. -*- C -*-
+   CGEN: Cpu tools GENerator
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN.
+   - the resultant file is machine generated, cgen-dis.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007,
+   2008, 2010  Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "libiberty.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+#include "opintl.h"
+
+/* Default text to print if an instruction isn't recognized.  */
+#define UNKNOWN_INSN_MSG _("*unknown*")
+
+static void print_normal
+  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
+static void print_address
+  (CGEN_CPU_DESC, void *, bfd_vma, unsigned int, bfd_vma, int) ATTRIBUTE_UNUSED;
+static void print_keyword
+  (CGEN_CPU_DESC, void *, CGEN_KEYWORD *, long, unsigned int) ATTRIBUTE_UNUSED;
+static void print_insn_normal
+  (CGEN_CPU_DESC, void *, const CGEN_INSN *, CGEN_FIELDS *, bfd_vma, int);
+static int print_insn
+  (CGEN_CPU_DESC, bfd_vma,  disassemble_info *, bfd_byte *, unsigned);
+static int default_print_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *) ATTRIBUTE_UNUSED;
+static int read_insn
+  (CGEN_CPU_DESC, bfd_vma, disassemble_info *, bfd_byte *, int, CGEN_EXTRACT_INFO *,
+   unsigned long *);
+
+/* -- disassembler routines inserted here.  */
+
+
+void or1k_cgen_print_operand
+  (CGEN_CPU_DESC, int, PTR, CGEN_FIELDS *, void const *, bfd_vma, int);
+
+/* Main entry point for printing operands.
+   XINFO is a `void *' and not a `disassemble_info *' to not put a requirement
+   of dis-asm.h on cgen.h.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+void
+or1k_cgen_print_operand (CGEN_CPU_DESC cd,
+			   int opindex,
+			   void * xinfo,
+			   CGEN_FIELDS *fields,
+			   void const *attrs ATTRIBUTE_UNUSED,
+			   bfd_vma pc,
+			   int length)
+{
+  disassemble_info *info = (disassemble_info *) xinfo;
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      print_address (cd, info, fields->f_disp26, 0|(1<<CGEN_OPERAND_PCREL_ADDR), pc, length);
+      break;
+    case OR1K_OPERAND_RA :
+      print_keyword (cd, info, & or1k_cgen_opval_h_gpr, fields->f_r2, 0);
+      break;
+    case OR1K_OPERAND_RADF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fdr, fields->f_r1, 0);
+      break;
+    case OR1K_OPERAND_RASF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fsr, fields->f_r2, 0);
+      break;
+    case OR1K_OPERAND_RB :
+      print_keyword (cd, info, & or1k_cgen_opval_h_gpr, fields->f_r3, 0);
+      break;
+    case OR1K_OPERAND_RBDF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fdr, fields->f_r1, 0);
+      break;
+    case OR1K_OPERAND_RBSF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fsr, fields->f_r3, 0);
+      break;
+    case OR1K_OPERAND_RD :
+      print_keyword (cd, info, & or1k_cgen_opval_h_gpr, fields->f_r1, 0);
+      break;
+    case OR1K_OPERAND_RDDF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fdr, fields->f_r1, 0);
+      break;
+    case OR1K_OPERAND_RDSF :
+      print_keyword (cd, info, & or1k_cgen_opval_h_fsr, fields->f_r1, 0);
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      print_normal (cd, info, fields->f_simm16, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT), pc, length);
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      print_normal (cd, info, fields->f_simm16_split, 0|(1<<CGEN_OPERAND_SIGNED)|(1<<CGEN_OPERAND_SIGN_OPT)|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      print_normal (cd, info, fields->f_uimm16, 0, pc, length);
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      print_normal (cd, info, fields->f_uimm16_split, 0|(1<<CGEN_OPERAND_VIRTUAL), pc, length);
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      print_normal (cd, info, fields->f_uimm6, 0, pc, length);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while printing insn.\n"),
+	       opindex);
+    abort ();
+  }
+}
+
+cgen_print_fn * const or1k_cgen_print_handlers[] = 
+{
+  print_insn_normal,
+};
+
+
+void
+or1k_cgen_init_dis (CGEN_CPU_DESC cd)
+{
+  or1k_cgen_init_opcode_table (cd);
+  or1k_cgen_init_ibld_table (cd);
+  cd->print_handlers = & or1k_cgen_print_handlers[0];
+  cd->print_operand = or1k_cgen_print_operand;
+}
+
+
+/* Default print handler.  */
+
+static void
+print_normal (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	      void *dis_info,
+	      long value,
+	      unsigned int attrs,
+	      bfd_vma pc ATTRIBUTE_UNUSED,
+	      int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* nothing to do */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", value);
+}
+
+/* Default address handler.  */
+
+static void
+print_address (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       bfd_vma value,
+	       unsigned int attrs,
+	       bfd_vma pc ATTRIBUTE_UNUSED,
+	       int length ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+
+  /* Print the operand as directed by the attributes.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SEM_ONLY))
+    ; /* Nothing to do.  */
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_PCREL_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_ABS_ADDR))
+    (*info->print_address_func) (value, info);
+  else if (CGEN_BOOL_ATTR (attrs, CGEN_OPERAND_SIGNED))
+    (*info->fprintf_func) (info->stream, "%ld", (long) value);
+  else
+    (*info->fprintf_func) (info->stream, "0x%lx", (long) value);
+}
+
+/* Keyword print handler.  */
+
+static void
+print_keyword (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	       void *dis_info,
+	       CGEN_KEYWORD *keyword_table,
+	       long value,
+	       unsigned int attrs ATTRIBUTE_UNUSED)
+{
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_KEYWORD_ENTRY *ke;
+
+  ke = cgen_keyword_lookup_value (keyword_table, value);
+  if (ke != NULL)
+    (*info->fprintf_func) (info->stream, "%s", ke->name);
+  else
+    (*info->fprintf_func) (info->stream, "???");
+}
+
+/* Default insn printer.
+
+   DIS_INFO is defined as `void *' so the disassembler needn't know anything
+   about disassemble_info.  */
+
+static void
+print_insn_normal (CGEN_CPU_DESC cd,
+		   void *dis_info,
+		   const CGEN_INSN *insn,
+		   CGEN_FIELDS *fields,
+		   bfd_vma pc,
+		   int length)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  disassemble_info *info = (disassemble_info *) dis_info;
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_INIT_PRINT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      if (CGEN_SYNTAX_MNEMONIC_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%s", CGEN_INSN_MNEMONIC (insn));
+	  continue;
+	}
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	{
+	  (*info->fprintf_func) (info->stream, "%c", CGEN_SYNTAX_CHAR (*syn));
+	  continue;
+	}
+
+      /* We have an operand.  */
+      or1k_cgen_print_operand (cd, CGEN_SYNTAX_FIELD (*syn), info,
+				 fields, CGEN_INSN_ATTRS (insn), pc, length);
+    }
+}
+
+/* Subroutine of print_insn. Reads an insn into the given buffers and updates
+   the extract info.
+   Returns 0 if all is well, non-zero otherwise.  */
+
+static int
+read_insn (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	   bfd_vma pc,
+	   disassemble_info *info,
+	   bfd_byte *buf,
+	   int buflen,
+	   CGEN_EXTRACT_INFO *ex_info,
+	   unsigned long *insn_value)
+{
+  int status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  ex_info->dis_info = info;
+  ex_info->valid = (1 << buflen) - 1;
+  ex_info->insn_bytes = buf;
+
+  *insn_value = bfd_get_bits (buf, buflen * 8, info->endian == BFD_ENDIAN_BIG);
+  return 0;
+}
+
+/* Utility to print an insn.
+   BUF is the base part of the insn, target byte order, BUFLEN bytes long.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+print_insn (CGEN_CPU_DESC cd,
+	    bfd_vma pc,
+	    disassemble_info *info,
+	    bfd_byte *buf,
+	    unsigned int buflen)
+{
+  CGEN_INSN_INT insn_value;
+  const CGEN_INSN_LIST *insn_list;
+  CGEN_EXTRACT_INFO ex_info;
+  int basesize;
+
+  /* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
+  basesize = cd->base_insn_bitsize < buflen * 8 ?
+                                     cd->base_insn_bitsize : buflen * 8;
+  insn_value = cgen_get_insn_value (cd, buf, basesize);
+
+
+  /* Fill in ex_info fields like read_insn would.  Don't actually call
+     read_insn, since the incoming buffer is already read (and possibly
+     modified a la m32r).  */
+  ex_info.valid = (1 << buflen) - 1;
+  ex_info.dis_info = info;
+  ex_info.insn_bytes = buf;
+
+  /* The instructions are stored in hash lists.
+     Pick the first one and keep trying until we find the right one.  */
+
+  insn_list = CGEN_DIS_LOOKUP_INSN (cd, (char *) buf, insn_value);
+  while (insn_list != NULL)
+    {
+      const CGEN_INSN *insn = insn_list->insn;
+      CGEN_FIELDS fields;
+      int length;
+      unsigned long insn_value_cropped;
+
+#ifdef CGEN_VALIDATE_INSN_SUPPORTED 
+      /* Not needed as insn shouldn't be in hash lists if not supported.  */
+      /* Supported by this cpu?  */
+      if (! or1k_cgen_insn_supported (cd, insn))
+        {
+          insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+	  continue;
+        }
+#endif
+
+      /* Basic bit mask must be correct.  */
+      /* ??? May wish to allow target to defer this check until the extract
+	 handler.  */
+
+      /* Base size may exceed this instruction's size.  Extract the
+         relevant part from the buffer. */
+      if ((unsigned) (CGEN_INSN_BITSIZE (insn) / 8) < buflen &&
+	  (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	insn_value_cropped = bfd_get_bits (buf, CGEN_INSN_BITSIZE (insn), 
+					   info->endian == BFD_ENDIAN_BIG);
+      else
+	insn_value_cropped = insn_value;
+
+      if ((insn_value_cropped & CGEN_INSN_BASE_MASK (insn))
+	  == CGEN_INSN_BASE_VALUE (insn))
+	{
+	  /* Printing is handled in two passes.  The first pass parses the
+	     machine insn and extracts the fields.  The second pass prints
+	     them.  */
+
+	  /* Make sure the entire insn is loaded into insn_value, if it
+	     can fit.  */
+	  if (((unsigned) CGEN_INSN_BITSIZE (insn) > cd->base_insn_bitsize) &&
+	      (unsigned) (CGEN_INSN_BITSIZE (insn) / 8) <= sizeof (unsigned long))
+	    {
+	      unsigned long full_insn_value;
+	      int rc = read_insn (cd, pc, info, buf,
+				  CGEN_INSN_BITSIZE (insn) / 8,
+				  & ex_info, & full_insn_value);
+	      if (rc != 0)
+		return rc;
+	      length = CGEN_EXTRACT_FN (cd, insn)
+		(cd, insn, &ex_info, full_insn_value, &fields, pc);
+	    }
+	  else
+	    length = CGEN_EXTRACT_FN (cd, insn)
+	      (cd, insn, &ex_info, insn_value_cropped, &fields, pc);
+
+	  /* Length < 0 -> error.  */
+	  if (length < 0)
+	    return length;
+	  if (length > 0)
+	    {
+	      CGEN_PRINT_FN (cd, insn) (cd, info, insn, &fields, pc, length);
+	      /* Length is in bits, result is in bytes.  */
+	      return length / 8;
+	    }
+	}
+
+      insn_list = CGEN_DIS_NEXT_INSN (insn_list);
+    }
+
+  return 0;
+}
+
+/* Default value for CGEN_PRINT_INSN.
+   The result is the size of the insn in bytes or zero for an unknown insn
+   or -1 if an error occured fetching bytes.  */
+
+#ifndef CGEN_PRINT_INSN
+#define CGEN_PRINT_INSN default_print_insn
+#endif
+
+static int
+default_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)
+{
+  bfd_byte buf[CGEN_MAX_INSN_SIZE];
+  int buflen;
+  int status;
+
+  /* Attempt to read the base part of the insn.  */
+  buflen = cd->base_insn_bitsize / 8;
+  status = (*info->read_memory_func) (pc, buf, buflen, info);
+
+  /* Try again with the minimum part, if min < base.  */
+  if (status != 0 && (cd->min_insn_bitsize < cd->base_insn_bitsize))
+    {
+      buflen = cd->min_insn_bitsize / 8;
+      status = (*info->read_memory_func) (pc, buf, buflen, info);
+    }
+
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, pc, info);
+      return -1;
+    }
+
+  return print_insn (cd, pc, info, buf, buflen);
+}
+
+/* Main entry point.
+   Print one instruction from PC on INFO->STREAM.
+   Return the size of the instruction (in bytes).  */
+
+typedef struct cpu_desc_list
+{
+  struct cpu_desc_list *next;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian;
+  CGEN_CPU_DESC cd;
+} cpu_desc_list;
+
+int
+print_insn_or1k (bfd_vma pc, disassemble_info *info)
+{
+  static cpu_desc_list *cd_list = 0;
+  cpu_desc_list *cl = 0;
+  static CGEN_CPU_DESC cd = 0;
+  static CGEN_BITSET *prev_isa;
+  static int prev_mach;
+  static int prev_endian;
+  int length;
+  CGEN_BITSET *isa;
+  int mach;
+  int endian = (info->endian == BFD_ENDIAN_BIG
+		? CGEN_ENDIAN_BIG
+		: CGEN_ENDIAN_LITTLE);
+  enum bfd_architecture arch;
+
+  /* ??? gdb will set mach but leave the architecture as "unknown" */
+#ifndef CGEN_BFD_ARCH
+#define CGEN_BFD_ARCH bfd_arch_or1k
+#endif
+  arch = info->arch;
+  if (arch == bfd_arch_unknown)
+    arch = CGEN_BFD_ARCH;
+   
+  /* There's no standard way to compute the machine or isa number
+     so we leave it to the target.  */
+#ifdef CGEN_COMPUTE_MACH
+  mach = CGEN_COMPUTE_MACH (info);
+#else
+  mach = info->mach;
+#endif
+
+#ifdef CGEN_COMPUTE_ISA
+  {
+    static CGEN_BITSET *permanent_isa;
+
+    if (!permanent_isa)
+      permanent_isa = cgen_bitset_create (MAX_ISAS);
+    isa = permanent_isa;
+    cgen_bitset_clear (isa);
+    cgen_bitset_add (isa, CGEN_COMPUTE_ISA (info));
+  }
+#else
+  isa = info->insn_sets;
+#endif
+
+  /* If we've switched cpu's, try to find a handle we've used before */
+  if (cd
+      && (cgen_bitset_compare (isa, prev_isa) != 0
+	  || mach != prev_mach
+	  || endian != prev_endian))
+    {
+      cd = 0;
+      for (cl = cd_list; cl; cl = cl->next)
+	{
+	  if (cgen_bitset_compare (cl->isa, isa) == 0 &&
+	      cl->mach == mach &&
+	      cl->endian == endian)
+	    {
+	      cd = cl->cd;
+ 	      prev_isa = cd->isas;
+	      break;
+	    }
+	}
+    } 
+
+  /* If we haven't initialized yet, initialize the opcode table.  */
+  if (! cd)
+    {
+      const bfd_arch_info_type *arch_type = bfd_lookup_arch (arch, mach);
+      const char *mach_name;
+
+      if (!arch_type)
+	abort ();
+      mach_name = arch_type->printable_name;
+
+      prev_isa = cgen_bitset_copy (isa);
+      prev_mach = mach;
+      prev_endian = endian;
+      cd = or1k_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,
+				 CGEN_CPU_OPEN_BFDMACH, mach_name,
+				 CGEN_CPU_OPEN_ENDIAN, prev_endian,
+				 CGEN_CPU_OPEN_END);
+      if (!cd)
+	abort ();
+
+      /* Save this away for future reference.  */
+      cl = xmalloc (sizeof (struct cpu_desc_list));
+      cl->cd = cd;
+      cl->isa = prev_isa;
+      cl->mach = mach;
+      cl->endian = endian;
+      cl->next = cd_list;
+      cd_list = cl;
+
+      or1k_cgen_init_dis (cd);
+    }
+
+  /* We try to have as much common code as possible.
+     But at this point some targets need to take over.  */
+  /* ??? Some targets may need a hook elsewhere.  Try to avoid this,
+     but if not possible try to move this hook elsewhere rather than
+     have two hooks.  */
+  length = CGEN_PRINT_INSN (cd, pc, info);
+  if (length > 0)
+    return length;
+  if (length < 0)
+    return -1;
+
+  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG);
+  return cd->default_insn_bitsize / 8;
+}
--- /dev/null
+++ b/opcodes/or1k-ibld.c
@@ -0,0 +1,1051 @@
+/* Instruction building/extraction support for or1k. -*- C -*-
+
+   THIS FILE IS MACHINE GENERATED WITH CGEN: Cpu tools GENerator.
+   - the resultant file is machine generated, cgen-ibld.in isn't
+
+   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2005, 2006, 2007,
+   2008, 2010  Free Software Foundation, Inc.
+
+   This file is part of libopcodes.
+
+   This library is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* ??? Eventually more and more of this stuff can go to cpu-independent files.
+   Keep that in mind.  */
+
+#include "sysdep.h"
+#include <stdio.h>
+#include "ansidecl.h"
+#include "dis-asm.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+#include "cgen/basic-modes.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+#undef  min
+#define min(a,b) ((a) < (b) ? (a) : (b))
+#undef  max
+#define max(a,b) ((a) > (b) ? (a) : (b))
+
+/* Used by the ifield rtx function.  */
+#define FLD(f) (fields->f)
+
+static const char * insert_normal
+  (CGEN_CPU_DESC, long, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, unsigned int, CGEN_INSN_BYTES_PTR);
+static const char * insert_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *,
+   CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+static int extract_normal
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, CGEN_INSN_INT,
+   unsigned int, unsigned int, unsigned int, unsigned int,
+   unsigned int, unsigned int, bfd_vma, long *);
+static int extract_insn_normal
+  (CGEN_CPU_DESC, const CGEN_INSN *, CGEN_EXTRACT_INFO *,
+   CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+#if CGEN_INT_INSN_P
+static void put_insn_int_value
+  (CGEN_CPU_DESC, CGEN_INSN_BYTES_PTR, int, int, CGEN_INSN_INT);
+#endif
+#if ! CGEN_INT_INSN_P
+static CGEN_INLINE void insert_1
+  (CGEN_CPU_DESC, unsigned long, int, int, int, unsigned char *);
+static CGEN_INLINE int fill_cache
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *,  int, int, bfd_vma);
+static CGEN_INLINE long extract_1
+  (CGEN_CPU_DESC, CGEN_EXTRACT_INFO *, int, int, int, unsigned char *, bfd_vma);
+#endif
+
+/* Operand insertion.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of insert_normal.  */
+
+static CGEN_INLINE void
+insert_1 (CGEN_CPU_DESC cd,
+	  unsigned long value,
+	  int start,
+	  int length,
+	  int word_length,
+	  unsigned char *bufp)
+{
+  unsigned long x,mask;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  x = (x & ~(mask << shift)) | ((value & mask) << shift);
+
+  cgen_put_insn_value (cd, bufp, word_length, (bfd_vma) x);
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default insertion routine.
+
+   ATTRS is a mask of the boolean attributes.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   The result is an error message or NULL if success.  */
+
+/* ??? This duplicates functionality with bfd's howto table and
+   bfd_install_relocation.  */
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static const char *
+insert_normal (CGEN_CPU_DESC cd,
+	       long value,
+	       unsigned int attrs,
+	       unsigned int word_offset,
+	       unsigned int start,
+	       unsigned int length,
+	       unsigned int word_length,
+	       unsigned int total_length,
+	       CGEN_INSN_BYTES_PTR buffer)
+{
+  static char errbuf[100];
+  /* Written this way to avoid undefined behaviour.  */
+  unsigned long mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value.  */
+  if (length == 0)
+    return NULL;
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset == 0
+	  && word_length > total_length)
+	word_length = total_length;
+    }
+
+  /* Ensure VALUE will fit.  */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGN_OPT))
+    {
+      long minval = - (1L << (length - 1));
+      unsigned long maxval = mask;
+      
+      if ((value > 0 && (unsigned long) value > maxval)
+	  || value < minval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (%ld not between %ld and %lu)"),
+		   value, minval, maxval);
+	  return errbuf;
+	}
+    }
+  else if (! CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED))
+    {
+      unsigned long maxval = mask;
+      unsigned long val = (unsigned long) value;
+
+      /* For hosts with a word size > 32 check to see if value has been sign
+	 extended beyond 32 bits.  If so then ignore these higher sign bits
+	 as the user is attempting to store a 32-bit signed value into an
+	 unsigned 32-bit field which is allowed.  */
+      if (sizeof (unsigned long) > 4 && ((value >> 32) == -1))
+	val &= 0xFFFFFFFF;
+
+      if (val > maxval)
+	{
+	  /* xgettext:c-format */
+	  sprintf (errbuf,
+		   _("operand out of range (0x%lx not between 0 and 0x%lx)"),
+		   val, maxval);
+	  return errbuf;
+	}
+    }
+  else
+    {
+      if (! cgen_signed_overflow_ok_p (cd))
+	{
+	  long minval = - (1L << (length - 1));
+	  long maxval =   (1L << (length - 1)) - 1;
+	  
+	  if (value < minval || value > maxval)
+	    {
+	      sprintf
+		/* xgettext:c-format */
+		(errbuf, _("operand out of range (%ld not between %ld and %ld)"),
+		 value, minval, maxval);
+	      return errbuf;
+	    }
+	}
+    }
+
+#if CGEN_INT_INSN_P
+
+  {
+    int shift;
+
+    if (CGEN_INSN_LSB0_P)
+      shift = (word_offset + start + 1) - length;
+    else
+      shift = total_length - (word_offset + start + length);
+    *buffer = (*buffer & ~(mask << shift)) | ((value & mask) << shift);
+  }
+
+#else /* ! CGEN_INT_INSN_P */
+
+  {
+    unsigned char *bufp = (unsigned char *) buffer + word_offset / 8;
+
+    insert_1 (cd, value, start, length, word_length, bufp);
+  }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  return NULL;
+}
+
+/* Default insn builder (insert handler).
+   The instruction is recorded in CGEN_INT_INSN_P byte order (meaning
+   that if CGEN_INSN_BYTES_PTR is an int * and thus, the value is
+   recorded in host byte order, otherwise BUFFER is an array of bytes
+   and the value is recorded in target byte order).
+   The result is an error message or NULL if success.  */
+
+static const char *
+insert_insn_normal (CGEN_CPU_DESC cd,
+		    const CGEN_INSN * insn,
+		    CGEN_FIELDS * fields,
+		    CGEN_INSN_BYTES_PTR buffer,
+		    bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  unsigned long value;
+  const CGEN_SYNTAX_CHAR_TYPE * syn;
+
+  CGEN_INIT_INSERT (cd);
+  value = CGEN_INSN_BASE_VALUE (insn);
+
+  /* If we're recording insns as numbers (rather than a string of bytes),
+     target byte order handling is deferred until later.  */
+
+#if CGEN_INT_INSN_P
+
+  put_insn_int_value (cd, buffer, cd->base_insn_bitsize,
+		      CGEN_FIELDS_BITSIZE (fields), value);
+
+#else
+
+  cgen_put_insn_value (cd, buffer, min ((unsigned) cd->base_insn_bitsize,
+					(unsigned) CGEN_FIELDS_BITSIZE (fields)),
+		       value);
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* ??? It would be better to scan the format's fields.
+     Still need to be able to insert a value based on the operand though;
+     e.g. storing a branch displacement that got resolved later.
+     Needs more thought first.  */
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); * syn; ++ syn)
+    {
+      const char *errmsg;
+
+      if (CGEN_SYNTAX_CHAR_P (* syn))
+	continue;
+
+      errmsg = (* cd->insert_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+				       fields, buffer, pc);
+      if (errmsg)
+	return errmsg;
+    }
+
+  return NULL;
+}
+
+#if CGEN_INT_INSN_P
+/* Cover function to store an insn value into an integral insn.  Must go here
+   because it needs <prefix>-desc.h for CGEN_INT_INSN_P.  */
+
+static void
+put_insn_int_value (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+		    CGEN_INSN_BYTES_PTR buf,
+		    int length,
+		    int insn_length,
+		    CGEN_INSN_INT value)
+{
+  /* For architectures with insns smaller than the base-insn-bitsize,
+     length may be too big.  */
+  if (length > insn_length)
+    *buf = value;
+  else
+    {
+      int shift = insn_length - length;
+      /* Written this way to avoid undefined behaviour.  */
+      CGEN_INSN_INT mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+      *buf = (*buf & ~(mask << shift)) | ((value & mask) << shift);
+    }
+}
+#endif
+
+/* Operand extraction.  */
+
+#if ! CGEN_INT_INSN_P
+
+/* Subroutine of extract_normal.
+   Ensure sufficient bytes are cached in EX_INFO.
+   OFFSET is the offset in bytes from the start of the insn of the value.
+   BYTES is the length of the needed value.
+   Returns 1 for success, 0 for failure.  */
+
+static CGEN_INLINE int
+fill_cache (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+	    CGEN_EXTRACT_INFO *ex_info,
+	    int offset,
+	    int bytes,
+	    bfd_vma pc)
+{
+  /* It's doubtful that the middle part has already been fetched so
+     we don't optimize that case.  kiss.  */
+  unsigned int mask;
+  disassemble_info *info = (disassemble_info *) ex_info->dis_info;
+
+  /* First do a quick check.  */
+  mask = (1 << bytes) - 1;
+  if (((ex_info->valid >> offset) & mask) == mask)
+    return 1;
+
+  /* Search for the first byte we need to read.  */
+  for (mask = 1 << offset; bytes > 0; --bytes, ++offset, mask <<= 1)
+    if (! (mask & ex_info->valid))
+      break;
+
+  if (bytes)
+    {
+      int status;
+
+      pc += offset;
+      status = (*info->read_memory_func)
+	(pc, ex_info->insn_bytes + offset, bytes, info);
+
+      if (status != 0)
+	{
+	  (*info->memory_error_func) (status, pc, info);
+	  return 0;
+	}
+
+      ex_info->valid |= ((1 << bytes) - 1) << offset;
+    }
+
+  return 1;
+}
+
+/* Subroutine of extract_normal.  */
+
+static CGEN_INLINE long
+extract_1 (CGEN_CPU_DESC cd,
+	   CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+	   int start,
+	   int length,
+	   int word_length,
+	   unsigned char *bufp,
+	   bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  unsigned long x;
+  int shift;
+
+  x = cgen_get_insn_value (cd, bufp, word_length);
+
+  if (CGEN_INSN_LSB0_P)
+    shift = (start + 1) - length;
+  else
+    shift = (word_length - (start + length));
+  return x >> shift;
+}
+
+#endif /* ! CGEN_INT_INSN_P */
+
+/* Default extraction routine.
+
+   INSN_VALUE is the first base_insn_bitsize bits of the insn in host order,
+   or sometimes less for cases like the m32r where the base insn size is 32
+   but some insns are 16 bits.
+   ATTRS is a mask of the boolean attributes.  We only need `SIGNED',
+   but for generality we take a bitmask of all of them.
+   WORD_OFFSET is the offset in bits from the start of the insn of the value.
+   WORD_LENGTH is the length of the word in bits in which the value resides.
+   START is the starting bit number in the word, architecture origin.
+   LENGTH is the length of VALUE in bits.
+   TOTAL_LENGTH is the total length of the insn in bits.
+
+   Returns 1 for success, 0 for failure.  */
+
+/* ??? The return code isn't properly used.  wip.  */
+
+/* ??? This doesn't handle bfd_vma's.  Create another function when
+   necessary.  */
+
+static int
+extract_normal (CGEN_CPU_DESC cd,
+#if ! CGEN_INT_INSN_P
+		CGEN_EXTRACT_INFO *ex_info,
+#else
+		CGEN_EXTRACT_INFO *ex_info ATTRIBUTE_UNUSED,
+#endif
+		CGEN_INSN_INT insn_value,
+		unsigned int attrs,
+		unsigned int word_offset,
+		unsigned int start,
+		unsigned int length,
+		unsigned int word_length,
+		unsigned int total_length,
+#if ! CGEN_INT_INSN_P
+		bfd_vma pc,
+#else
+		bfd_vma pc ATTRIBUTE_UNUSED,
+#endif
+		long *valuep)
+{
+  long value, mask;
+
+  /* If LENGTH is zero, this operand doesn't contribute to the value
+     so give it a standard value of zero.  */
+  if (length == 0)
+    {
+      *valuep = 0;
+      return 1;
+    }
+
+  if (word_length > 8 * sizeof (CGEN_INSN_INT))
+    abort ();
+
+  /* For architectures with insns smaller than the insn-base-bitsize,
+     word_length may be too big.  */
+  if (cd->min_insn_bitsize < cd->base_insn_bitsize)
+    {
+      if (word_offset + word_length > total_length)
+	word_length = total_length - word_offset;
+    }
+
+  /* Does the value reside in INSN_VALUE, and at the right alignment?  */
+
+  if (CGEN_INT_INSN_P || (word_offset == 0 && word_length == total_length))
+    {
+      if (CGEN_INSN_LSB0_P)
+	value = insn_value >> ((word_offset + start + 1) - length);
+      else
+	value = insn_value >> (total_length - ( word_offset + start + length));
+    }
+
+#if ! CGEN_INT_INSN_P
+
+  else
+    {
+      unsigned char *bufp = ex_info->insn_bytes + word_offset / 8;
+
+      if (word_length > 8 * sizeof (CGEN_INSN_INT))
+	abort ();
+
+      if (fill_cache (cd, ex_info, word_offset / 8, word_length / 8, pc) == 0)
+	return 0;
+
+      value = extract_1 (cd, ex_info, start, length, word_length, bufp, pc);
+    }
+
+#endif /* ! CGEN_INT_INSN_P */
+
+  /* Written this way to avoid undefined behaviour.  */
+  mask = (((1L << (length - 1)) - 1) << 1) | 1;
+
+  value &= mask;
+  /* sign extend? */
+  if (CGEN_BOOL_ATTR (attrs, CGEN_IFLD_SIGNED)
+      && (value & (1L << (length - 1))))
+    value |= ~mask;
+
+  *valuep = value;
+
+  return 1;
+}
+
+/* Default insn extractor.
+
+   INSN_VALUE is the first base_insn_bitsize bits, translated to host order.
+   The extracted fields are stored in FIELDS.
+   EX_INFO is used to handle reading variable length insns.
+   Return the length of the insn in bits, or 0 if no match,
+   or -1 if an error occurs fetching data (memory_error_func will have
+   been called).  */
+
+static int
+extract_insn_normal (CGEN_CPU_DESC cd,
+		     const CGEN_INSN *insn,
+		     CGEN_EXTRACT_INFO *ex_info,
+		     CGEN_INSN_INT insn_value,
+		     CGEN_FIELDS *fields,
+		     bfd_vma pc)
+{
+  const CGEN_SYNTAX *syntax = CGEN_INSN_SYNTAX (insn);
+  const CGEN_SYNTAX_CHAR_TYPE *syn;
+
+  CGEN_FIELDS_BITSIZE (fields) = CGEN_INSN_BITSIZE (insn);
+
+  CGEN_INIT_EXTRACT (cd);
+
+  for (syn = CGEN_SYNTAX_STRING (syntax); *syn; ++syn)
+    {
+      int length;
+
+      if (CGEN_SYNTAX_CHAR_P (*syn))
+	continue;
+
+      length = (* cd->extract_operand) (cd, CGEN_SYNTAX_FIELD (*syn),
+					ex_info, insn_value, fields, pc);
+      if (length <= 0)
+	return length;
+    }
+
+  /* We recognized and successfully extracted this insn.  */
+  return CGEN_INSN_BITSIZE (insn);
+}
+
+/* Machine generated code added here.  */
+
+const char * or1k_cgen_insert_operand
+  (CGEN_CPU_DESC, int, CGEN_FIELDS *, CGEN_INSN_BYTES_PTR, bfd_vma);
+
+/* Main entry point for operand insertion.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `parse_insn_normal', but keeping it
+   separate makes clear the interface between `parse_insn_normal' and each of
+   the handlers.  It's also needed by GAS to insert operands that couldn't be
+   resolved during parsing.  */
+
+const char *
+or1k_cgen_insert_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     CGEN_INSN_BYTES_PTR buffer,
+			     bfd_vma pc ATTRIBUTE_UNUSED)
+{
+  const char * errmsg = NULL;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      {
+        long value = fields->f_disp26;
+        value = ((SI) (((value) - (pc))) >> (2));
+        errmsg = insert_normal (cd, value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, buffer);
+      }
+      break;
+    case OR1K_OPERAND_RA :
+      errmsg = insert_normal (cd, fields->f_r2, 0, 0, 20, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RADF :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RASF :
+      errmsg = insert_normal (cd, fields->f_r2, 0, 0, 20, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RB :
+      errmsg = insert_normal (cd, fields->f_r3, 0, 0, 15, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RBDF :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RBSF :
+      errmsg = insert_normal (cd, fields->f_r3, 0, 0, 15, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RD :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RDDF :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_RDSF :
+      errmsg = insert_normal (cd, fields->f_r1, 0, 0, 25, 5, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      errmsg = insert_normal (cd, fields->f_simm16, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 0, 15, 16, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      {
+{
+  FLD (f_imm16_25_5) = ((((INT) (FLD (f_simm16_split)) >> (11))) & (31));
+  FLD (f_imm16_10_11) = ((FLD (f_simm16_split)) & (2047));
+}
+        errmsg = insert_normal (cd, fields->f_imm16_25_5, 0, 0, 25, 5, 32, total_length, buffer);
+        if (errmsg)
+          break;
+        errmsg = insert_normal (cd, fields->f_imm16_10_11, 0, 0, 10, 11, 32, total_length, buffer);
+        if (errmsg)
+          break;
+      }
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      errmsg = insert_normal (cd, fields->f_uimm16, 0, 0, 15, 16, 32, total_length, buffer);
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      {
+{
+  FLD (f_imm16_25_5) = ((((UINT) (FLD (f_uimm16_split)) >> (11))) & (31));
+  FLD (f_imm16_10_11) = ((FLD (f_uimm16_split)) & (2047));
+}
+        errmsg = insert_normal (cd, fields->f_imm16_25_5, 0, 0, 25, 5, 32, total_length, buffer);
+        if (errmsg)
+          break;
+        errmsg = insert_normal (cd, fields->f_imm16_10_11, 0, 0, 10, 11, 32, total_length, buffer);
+        if (errmsg)
+          break;
+      }
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      errmsg = insert_normal (cd, fields->f_uimm6, 0, 0, 5, 6, 32, total_length, buffer);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while building insn.\n"),
+	       opindex);
+      abort ();
+  }
+
+  return errmsg;
+}
+
+int or1k_cgen_extract_operand
+  (CGEN_CPU_DESC, int, CGEN_EXTRACT_INFO *, CGEN_INSN_INT, CGEN_FIELDS *, bfd_vma);
+
+/* Main entry point for operand extraction.
+   The result is <= 0 for error, >0 for success.
+   ??? Actual values aren't well defined right now.
+
+   This function is basically just a big switch statement.  Earlier versions
+   used tables to look up the function to use, but
+   - if the table contains both assembler and disassembler functions then
+     the disassembler contains much of the assembler and vice-versa,
+   - there's a lot of inlining possibilities as things grow,
+   - using a switch statement avoids the function call overhead.
+
+   This function could be moved into `print_insn_normal', but keeping it
+   separate makes clear the interface between `print_insn_normal' and each of
+   the handlers.  */
+
+int
+or1k_cgen_extract_operand (CGEN_CPU_DESC cd,
+			     int opindex,
+			     CGEN_EXTRACT_INFO *ex_info,
+			     CGEN_INSN_INT insn_value,
+			     CGEN_FIELDS * fields,
+			     bfd_vma pc)
+{
+  /* Assume success (for those operands that are nops).  */
+  int length = 1;
+  unsigned int total_length = CGEN_FIELDS_BITSIZE (fields);
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      {
+        long value;
+        length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_PCREL_ADDR), 0, 25, 26, 32, total_length, pc, & value);
+        value = ((((value) << (2))) + (pc));
+        fields->f_disp26 = value;
+      }
+      break;
+    case OR1K_OPERAND_RA :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 20, 5, 32, total_length, pc, & fields->f_r2);
+      break;
+    case OR1K_OPERAND_RADF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RASF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 20, 5, 32, total_length, pc, & fields->f_r2);
+      break;
+    case OR1K_OPERAND_RB :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 5, 32, total_length, pc, & fields->f_r3);
+      break;
+    case OR1K_OPERAND_RBDF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RBSF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 5, 32, total_length, pc, & fields->f_r3);
+      break;
+    case OR1K_OPERAND_RD :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RDDF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_RDSF :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_r1);
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      length = extract_normal (cd, ex_info, insn_value, 0|(1<<CGEN_IFLD_SIGNED)|(1<<CGEN_IFLD_SIGN_OPT), 0, 15, 16, 32, total_length, pc, & fields->f_simm16);
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      {
+        length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_imm16_25_5);
+        if (length <= 0) break;
+        length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 11, 32, total_length, pc, & fields->f_imm16_10_11);
+        if (length <= 0) break;
+  FLD (f_simm16_split) = ((HI) (UINT) (((((FLD (f_imm16_25_5)) << (11))) | (FLD (f_imm16_10_11)))));
+      }
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 15, 16, 32, total_length, pc, & fields->f_uimm16);
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      {
+        length = extract_normal (cd, ex_info, insn_value, 0, 0, 25, 5, 32, total_length, pc, & fields->f_imm16_25_5);
+        if (length <= 0) break;
+        length = extract_normal (cd, ex_info, insn_value, 0, 0, 10, 11, 32, total_length, pc, & fields->f_imm16_10_11);
+        if (length <= 0) break;
+  FLD (f_uimm16_split) = ((UHI) (UINT) (((((FLD (f_imm16_25_5)) << (11))) | (FLD (f_imm16_10_11)))));
+      }
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      length = extract_normal (cd, ex_info, insn_value, 0, 0, 5, 6, 32, total_length, pc, & fields->f_uimm6);
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while decoding insn.\n"),
+	       opindex);
+      abort ();
+    }
+
+  return length;
+}
+
+cgen_insert_fn * const or1k_cgen_insert_handlers[] = 
+{
+  insert_insn_normal,
+};
+
+cgen_extract_fn * const or1k_cgen_extract_handlers[] = 
+{
+  extract_insn_normal,
+};
+
+int or1k_cgen_get_int_operand     (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+bfd_vma or1k_cgen_get_vma_operand (CGEN_CPU_DESC, int, const CGEN_FIELDS *);
+
+/* Getting values from cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they return.
+   TODO: floating point, inlining support, remove cases where result type
+   not appropriate.  */
+
+int
+or1k_cgen_get_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  int value;
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      value = fields->f_disp26;
+      break;
+    case OR1K_OPERAND_RA :
+      value = fields->f_r2;
+      break;
+    case OR1K_OPERAND_RADF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RASF :
+      value = fields->f_r2;
+      break;
+    case OR1K_OPERAND_RB :
+      value = fields->f_r3;
+      break;
+    case OR1K_OPERAND_RBDF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RBSF :
+      value = fields->f_r3;
+      break;
+    case OR1K_OPERAND_RD :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RDDF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RDSF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      value = fields->f_simm16;
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      value = fields->f_simm16_split;
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      value = fields->f_uimm16;
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      value = fields->f_uimm16_split;
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      value = fields->f_uimm6;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+bfd_vma
+or1k_cgen_get_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     const CGEN_FIELDS * fields)
+{
+  bfd_vma value;
+
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      value = fields->f_disp26;
+      break;
+    case OR1K_OPERAND_RA :
+      value = fields->f_r2;
+      break;
+    case OR1K_OPERAND_RADF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RASF :
+      value = fields->f_r2;
+      break;
+    case OR1K_OPERAND_RB :
+      value = fields->f_r3;
+      break;
+    case OR1K_OPERAND_RBDF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RBSF :
+      value = fields->f_r3;
+      break;
+    case OR1K_OPERAND_RD :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RDDF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_RDSF :
+      value = fields->f_r1;
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      value = fields->f_simm16;
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      value = fields->f_simm16_split;
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      value = fields->f_uimm16;
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      value = fields->f_uimm16_split;
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      value = fields->f_uimm6;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while getting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+
+  return value;
+}
+
+void or1k_cgen_set_int_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, int);
+void or1k_cgen_set_vma_operand  (CGEN_CPU_DESC, int, CGEN_FIELDS *, bfd_vma);
+
+/* Stuffing values in cgen_fields is handled by a collection of functions.
+   They are distinguished by the type of the VALUE argument they accept.
+   TODO: floating point, inlining support, remove cases where argument type
+   not appropriate.  */
+
+void
+or1k_cgen_set_int_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     int value)
+{
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      fields->f_disp26 = value;
+      break;
+    case OR1K_OPERAND_RA :
+      fields->f_r2 = value;
+      break;
+    case OR1K_OPERAND_RADF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RASF :
+      fields->f_r2 = value;
+      break;
+    case OR1K_OPERAND_RB :
+      fields->f_r3 = value;
+      break;
+    case OR1K_OPERAND_RBDF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RBSF :
+      fields->f_r3 = value;
+      break;
+    case OR1K_OPERAND_RD :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RDDF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RDSF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      fields->f_simm16 = value;
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      fields->f_simm16_split = value;
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      fields->f_uimm16 = value;
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      fields->f_uimm16_split = value;
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      fields->f_uimm6 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting int operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+void
+or1k_cgen_set_vma_operand (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
+			     int opindex,
+			     CGEN_FIELDS * fields,
+			     bfd_vma value)
+{
+  switch (opindex)
+    {
+    case OR1K_OPERAND_DISP26 :
+      fields->f_disp26 = value;
+      break;
+    case OR1K_OPERAND_RA :
+      fields->f_r2 = value;
+      break;
+    case OR1K_OPERAND_RADF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RASF :
+      fields->f_r2 = value;
+      break;
+    case OR1K_OPERAND_RB :
+      fields->f_r3 = value;
+      break;
+    case OR1K_OPERAND_RBDF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RBSF :
+      fields->f_r3 = value;
+      break;
+    case OR1K_OPERAND_RD :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RDDF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_RDSF :
+      fields->f_r1 = value;
+      break;
+    case OR1K_OPERAND_SIMM16 :
+      fields->f_simm16 = value;
+      break;
+    case OR1K_OPERAND_SIMM16_SPLIT :
+      fields->f_simm16_split = value;
+      break;
+    case OR1K_OPERAND_UIMM16 :
+      fields->f_uimm16 = value;
+      break;
+    case OR1K_OPERAND_UIMM16_SPLIT :
+      fields->f_uimm16_split = value;
+      break;
+    case OR1K_OPERAND_UIMM6 :
+      fields->f_uimm6 = value;
+      break;
+
+    default :
+      /* xgettext:c-format */
+      fprintf (stderr, _("Unrecognized field %d while setting vma operand.\n"),
+		       opindex);
+      abort ();
+  }
+}
+
+/* Function to call before using the instruction builder tables.  */
+
+void
+or1k_cgen_init_ibld_table (CGEN_CPU_DESC cd)
+{
+  cd->insert_handlers = & or1k_cgen_insert_handlers[0];
+  cd->extract_handlers = & or1k_cgen_extract_handlers[0];
+
+  cd->insert_operand = or1k_cgen_insert_operand;
+  cd->extract_operand = or1k_cgen_extract_operand;
+
+  cd->get_int_operand = or1k_cgen_get_int_operand;
+  cd->set_int_operand = or1k_cgen_set_int_operand;
+  cd->get_vma_operand = or1k_cgen_get_vma_operand;
+  cd->set_vma_operand = or1k_cgen_set_vma_operand;
+}
--- /dev/null
+++ b/opcodes/or1k-opc.c
@@ -0,0 +1,1043 @@
+/* Instruction opcode table for or1k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2010 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+#include "libiberty.h"
+
+/* -- opc.c */
+/* -- */
+/* The hash functions are recorded here to help keep assembler code out of
+   the disassembler and vice versa.  */
+
+static int asm_hash_insn_p        (const CGEN_INSN *);
+static unsigned int asm_hash_insn (const char *);
+static int dis_hash_insn_p        (const CGEN_INSN *);
+static unsigned int dis_hash_insn (const char *, CGEN_INSN_INT);
+
+/* Instruction formats.  */
+
+#define F(f) & or1k_cgen_ifld_table[OR1K_##f]
+static const CGEN_IFMT ifmt_empty ATTRIBUTE_UNUSED = {
+  0, 0, 0x0, { { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_j ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_DISP26) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_jr ATTRIBUTE_UNUSED = {
+  32, 32, 0xffff07ff, { { F (F_OPCODE) }, { F (F_RESV_25_10) }, { F (F_R3) }, { F (F_RESV_10_11) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_trap ATTRIBUTE_UNUSED = {
+  32, 32, 0xffff0000, { { F (F_OPCODE) }, { F (F_OP_25_5) }, { F (F_RESV_20_5) }, { F (F_UIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_rfe ATTRIBUTE_UNUSED = {
+  32, 32, 0xffffffff, { { F (F_OPCODE) }, { F (F_RESV_25_26) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_nop_imm ATTRIBUTE_UNUSED = {
+  32, 32, 0xffff0000, { { F (F_OPCODE) }, { F (F_OP_25_2) }, { F (F_RESV_23_8) }, { F (F_UIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_movhi ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc1f0000, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_RESV_20_4) }, { F (F_OP_16_1) }, { F (F_UIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_macrc ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc1fffff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_RESV_20_4) }, { F (F_OP_16_1) }, { F (F_UIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_mfspr ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_UIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_mtspr ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R2) }, { F (F_R3) }, { F (F_UIMM16_SPLIT) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_lwz ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_sw ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc000000, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R3) }, { F (F_SIMM16_SPLIT) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_sll ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_2) }, { F (F_RESV_5_2) }, { F (F_OP_3_4) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_slli ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffc0, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV_15_8) }, { F (F_OP_7_2) }, { F (F_UIMM6) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_and ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_7) }, { F (F_OP_3_4) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_exths ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_RESV_15_6) }, { F (F_OP_9_4) }, { F (F_RESV_5_2) }, { F (F_OP_3_4) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_cmov ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_1) }, { F (F_OP_9_2) }, { F (F_RESV_7_4) }, { F (F_OP_3_4) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_sfgts ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe007ff, { { F (F_OPCODE) }, { F (F_OP_25_5) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_11) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_sfgtsi ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_OP_25_5) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_mac ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe007ff, { { F (F_OPCODE) }, { F (F_OP_25_5) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_7) }, { F (F_OP_3_4) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_l_maci ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe00000, { { F (F_OPCODE) }, { F (F_RESV_25_5) }, { F (F_R2) }, { F (F_SIMM16) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_add_s ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_add_d ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc0007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R1) }, { F (F_R1) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_itof_s ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_ftoi_s ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_ftoi_d ATTRIBUTE_UNUSED = {
+  32, 32, 0xfc00ffff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R1) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_eq_s ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe007ff, { { F (F_OPCODE) }, { F (F_R1) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_cust1_s ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe007ff, { { F (F_OPCODE) }, { F (F_RESV_25_5) }, { F (F_R2) }, { F (F_R3) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+static const CGEN_IFMT ifmt_lf_cust1_d ATTRIBUTE_UNUSED = {
+  32, 32, 0xffe007ff, { { F (F_OPCODE) }, { F (F_RESV_25_5) }, { F (F_R1) }, { F (F_R1) }, { F (F_RESV_10_3) }, { F (F_OP_7_8) }, { 0 } }
+};
+
+#undef F
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) OR1K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The instruction table.  */
+
+static const CGEN_OPCODE or1k_cgen_insn_opcode_table[MAX_INSNS] =
+{
+  /* Special null first entry.
+     A `num' value of zero is thus invalid.
+     Also, the special `invalid' insn resides here.  */
+  { { 0, 0, 0, 0 }, {{0}}, 0, {0}},
+/* l.j ${disp26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (DISP26), 0 } },
+    & ifmt_l_j, { 0x0 }
+  },
+/* l.jal ${disp26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (DISP26), 0 } },
+    & ifmt_l_j, { 0x4000000 }
+  },
+/* l.jr $rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RB), 0 } },
+    & ifmt_l_jr, { 0x44000000 }
+  },
+/* l.jalr $rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RB), 0 } },
+    & ifmt_l_jr, { 0x48000000 }
+  },
+/* l.bnf ${disp26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (DISP26), 0 } },
+    & ifmt_l_j, { 0xc000000 }
+  },
+/* l.bf ${disp26} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (DISP26), 0 } },
+    & ifmt_l_j, { 0x10000000 }
+  },
+/* l.trap ${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (UIMM16), 0 } },
+    & ifmt_l_trap, { 0x21000000 }
+  },
+/* l.sys ${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (UIMM16), 0 } },
+    & ifmt_l_trap, { 0x20000000 }
+  },
+/* l.rfe */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0x24000000 }
+  },
+/* l.nop ${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (UIMM16), 0 } },
+    & ifmt_l_nop_imm, { 0x15000000 }
+  },
+/* l.nop */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_nop_imm, { 0x15000000 }
+  },
+/* l.movhi $rD,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (UIMM16), 0 } },
+    & ifmt_l_movhi, { 0x18000000 }
+  },
+/* l.macrc $rD */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), 0 } },
+    & ifmt_l_macrc, { 0x18010000 }
+  },
+/* l.mfspr $rD,$rA,${uimm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM16), 0 } },
+    & ifmt_l_mfspr, { 0xb4000000 }
+  },
+/* l.mtspr $rA,$rB,${uimm16-split} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), ',', OP (UIMM16_SPLIT), 0 } },
+    & ifmt_l_mtspr, { 0xc0000000 }
+  },
+/* l.lwz $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x84000000 }
+  },
+/* l.lws $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x88000000 }
+  },
+/* l.lbz $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x8c000000 }
+  },
+/* l.lbs $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x90000000 }
+  },
+/* l.lhz $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x94000000 }
+  },
+/* l.lhs $rD,${simm16}($rA) */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (SIMM16), '(', OP (RA), ')', 0 } },
+    & ifmt_l_lwz, { 0x98000000 }
+  },
+/* l.sw ${simm16-split}($rA),$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM16_SPLIT), '(', OP (RA), ')', ',', OP (RB), 0 } },
+    & ifmt_l_sw, { 0xd4000000 }
+  },
+/* l.sb ${simm16-split}($rA),$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM16_SPLIT), '(', OP (RA), ')', ',', OP (RB), 0 } },
+    & ifmt_l_sw, { 0xd8000000 }
+  },
+/* l.sh ${simm16-split}($rA),$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (SIMM16_SPLIT), '(', OP (RA), ')', ',', OP (RB), 0 } },
+    & ifmt_l_sw, { 0xdc000000 }
+  },
+/* l.sll $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sll, { 0xe0000008 }
+  },
+/* l.slli $rD,$rA,${uimm6} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM6), 0 } },
+    & ifmt_l_slli, { 0xb8000000 }
+  },
+/* l.srl $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sll, { 0xe0000048 }
+  },
+/* l.srli $rD,$rA,${uimm6} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM6), 0 } },
+    & ifmt_l_slli, { 0xb8000040 }
+  },
+/* l.sra $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sll, { 0xe0000088 }
+  },
+/* l.srai $rD,$rA,${uimm6} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM6), 0 } },
+    & ifmt_l_slli, { 0xb8000080 }
+  },
+/* l.ror $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sll, { 0xe00000c8 }
+  },
+/* l.rori $rD,$rA,${uimm6} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM6), 0 } },
+    & ifmt_l_slli, { 0xb80000c0 }
+  },
+/* l.and $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000003 }
+  },
+/* l.or $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000004 }
+  },
+/* l.xor $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000005 }
+  },
+/* l.add $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000000 }
+  },
+/* l.sub $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000002 }
+  },
+/* l.addc $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000001 }
+  },
+/* l.mul $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000306 }
+  },
+/* l.mulu $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe000030b }
+  },
+/* l.div $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe0000309 }
+  },
+/* l.divu $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_and, { 0xe000030a }
+  },
+/* l.ff1 $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_and, { 0xe000000f }
+  },
+/* l.fl1 $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_and, { 0xe000010f }
+  },
+/* l.andi $rD,$rA,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM16), 0 } },
+    & ifmt_l_mfspr, { 0xa4000000 }
+  },
+/* l.ori $rD,$rA,$uimm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (UIMM16), 0 } },
+    & ifmt_l_mfspr, { 0xa8000000 }
+  },
+/* l.xori $rD,$rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_lwz, { 0xac000000 }
+  },
+/* l.addi $rD,$rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_lwz, { 0x9c000000 }
+  },
+/* l.addic $rD,$rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_lwz, { 0xa0000000 }
+  },
+/* l.muli $rD,$rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_lwz, { 0xb0000000 }
+  },
+/* l.exths $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe000000c }
+  },
+/* l.extbs $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe000004c }
+  },
+/* l.exthz $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe000008c }
+  },
+/* l.extbz $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe00000cc }
+  },
+/* l.extws $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe000000d }
+  },
+/* l.extwz $rD,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), 0 } },
+    & ifmt_l_exths, { 0xe000004d }
+  },
+/* l.cmov $rD,$rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_cmov, { 0xe000000e }
+  },
+/* l.sfgts $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe5400000 }
+  },
+/* l.sfgtsi $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbd400000 }
+  },
+/* l.sfgtu $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4400000 }
+  },
+/* l.sfgtui $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbc400000 }
+  },
+/* l.sfges $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe5600000 }
+  },
+/* l.sfgesi $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbd600000 }
+  },
+/* l.sfgeu $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4600000 }
+  },
+/* l.sfgeui $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbc600000 }
+  },
+/* l.sflts $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe5800000 }
+  },
+/* l.sfltsi $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbd800000 }
+  },
+/* l.sfltu $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4800000 }
+  },
+/* l.sfltui $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbc800000 }
+  },
+/* l.sfles $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe5a00000 }
+  },
+/* l.sflesi $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbda00000 }
+  },
+/* l.sfleu $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4a00000 }
+  },
+/* l.sfleui $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbca00000 }
+  },
+/* l.sfeq $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4000000 }
+  },
+/* l.sfeqi $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbc000000 }
+  },
+/* l.sfne $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_sfgts, { 0xe4200000 }
+  },
+/* l.sfnei $rA,$simm16 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_sfgtsi, { 0xbc200000 }
+  },
+/* l.mac $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_mac, { 0xc4000001 }
+  },
+/* l.msb $rA,$rB */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (RB), 0 } },
+    & ifmt_l_mac, { 0xc4000002 }
+  },
+/* l.maci $rA,${simm16} */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RA), ',', OP (SIMM16), 0 } },
+    & ifmt_l_maci, { 0x4c000000 }
+  },
+/* l.cust1 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0x70000000 }
+  },
+/* l.cust2 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0x74000000 }
+  },
+/* l.cust3 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0x78000000 }
+  },
+/* l.cust4 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0x7c000000 }
+  },
+/* l.cust5 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0xf0000000 }
+  },
+/* l.cust6 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0xf4000000 }
+  },
+/* l.cust7 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0xf8000000 }
+  },
+/* l.cust8 */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_l_rfe, { 0xfc000000 }
+  },
+/* lf.add.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000000 }
+  },
+/* lf.add.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000010 }
+  },
+/* lf.sub.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000001 }
+  },
+/* lf.sub.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000011 }
+  },
+/* lf.mul.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000002 }
+  },
+/* lf.mul.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000012 }
+  },
+/* lf.div.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000003 }
+  },
+/* lf.div.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000013 }
+  },
+/* lf.rem.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000006 }
+  },
+/* lf.rem.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000016 }
+  },
+/* lf.itof.s $rDSF,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RA), 0 } },
+    & ifmt_lf_itof_s, { 0xc8000004 }
+  },
+/* lf.itof.d $rDSF,$rA */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RA), 0 } },
+    & ifmt_lf_itof_s, { 0xc8000014 }
+  },
+/* lf.ftoi.s $rD,$rASF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RASF), 0 } },
+    & ifmt_lf_ftoi_s, { 0xc8000005 }
+  },
+/* lf.ftoi.d $rD,$rADF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RD), ',', OP (RADF), 0 } },
+    & ifmt_lf_ftoi_d, { 0xc8000015 }
+  },
+/* lf.sfeq.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc8000008 }
+  },
+/* lf.sfeq.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc8000018 }
+  },
+/* lf.sfne.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc8000009 }
+  },
+/* lf.sfne.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc8000019 }
+  },
+/* lf.sfge.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800000b }
+  },
+/* lf.sfge.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800001b }
+  },
+/* lf.sfgt.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800000a }
+  },
+/* lf.sfgt.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800001a }
+  },
+/* lf.sflt.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800000c }
+  },
+/* lf.sflt.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800001c }
+  },
+/* lf.sfle.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800000d }
+  },
+/* lf.sfle.d $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_eq_s, { 0xc800001d }
+  },
+/* lf.madd.s $rDSF,$rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDSF), ',', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_add_s, { 0xc8000007 }
+  },
+/* lf.madd.d $rDDF,$rADF,$rBDF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RDDF), ',', OP (RADF), ',', OP (RBDF), 0 } },
+    & ifmt_lf_add_d, { 0xc8000017 }
+  },
+/* lf.cust1.s $rASF,$rBSF */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, ' ', OP (RASF), ',', OP (RBSF), 0 } },
+    & ifmt_lf_cust1_s, { 0xc80000d0 }
+  },
+/* lf.cust1.d */
+  {
+    { 0, 0, 0, 0 },
+    { { MNEM, 0 } },
+    & ifmt_lf_cust1_d, { 0xc80000e0 }
+  },
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+/* Formats for ALIAS macro-insns.  */
+
+#define F(f) & or1k_cgen_ifld_table[OR1K_##f]
+#undef F
+
+/* Each non-simple macro entry points to an array of expansion possibilities.  */
+
+#define A(a) (1 << CGEN_INSN_##a)
+#define OPERAND(op) OR1K_OPERAND_##op
+#define MNEM CGEN_SYNTAX_MNEMONIC /* syntax value for mnemonic */
+#define OP(field) CGEN_SYNTAX_MAKE_FIELD (OPERAND (field))
+
+/* The macro instruction table.  */
+
+static const CGEN_IBASE or1k_cgen_macro_insn_table[] =
+{
+};
+
+/* The macro instruction opcode table.  */
+
+static const CGEN_OPCODE or1k_cgen_macro_insn_opcode_table[] =
+{
+};
+
+#undef A
+#undef OPERAND
+#undef MNEM
+#undef OP
+
+#ifndef CGEN_ASM_HASH_P
+#define CGEN_ASM_HASH_P(insn) 1
+#endif
+
+#ifndef CGEN_DIS_HASH_P
+#define CGEN_DIS_HASH_P(insn) 1
+#endif
+
+/* Return non-zero if INSN is to be added to the hash table.
+   Targets are free to override CGEN_{ASM,DIS}_HASH_P in the .opc file.  */
+
+static int
+asm_hash_insn_p (insn)
+     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
+{
+  return CGEN_ASM_HASH_P (insn);
+}
+
+static int
+dis_hash_insn_p (insn)
+     const CGEN_INSN *insn;
+{
+  /* If building the hash table and the NO-DIS attribute is present,
+     ignore.  */
+  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_NO_DIS))
+    return 0;
+  return CGEN_DIS_HASH_P (insn);
+}
+
+#ifndef CGEN_ASM_HASH
+#define CGEN_ASM_HASH_SIZE 127
+#ifdef CGEN_MNEMONIC_OPERANDS
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE)
+#else
+#define CGEN_ASM_HASH(mnem) (*(unsigned char *) (mnem) % CGEN_ASM_HASH_SIZE) /*FIXME*/
+#endif
+#endif
+
+/* It doesn't make much sense to provide a default here,
+   but while this is under development we do.
+   BUFFER is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+#ifndef CGEN_DIS_HASH
+#define CGEN_DIS_HASH_SIZE 256
+#define CGEN_DIS_HASH(buf, value) (*(unsigned char *) (buf))
+#endif
+
+/* The result is the hash value of the insn.
+   Targets are free to override CGEN_{ASM,DIS}_HASH in the .opc file.  */
+
+static unsigned int
+asm_hash_insn (mnem)
+     const char * mnem;
+{
+  return CGEN_ASM_HASH (mnem);
+}
+
+/* BUF is a pointer to the bytes of the insn, target order.
+   VALUE is the first base_insn_bitsize bits as an int in host order.  */
+
+static unsigned int
+dis_hash_insn (buf, value)
+     const char * buf ATTRIBUTE_UNUSED;
+     CGEN_INSN_INT value ATTRIBUTE_UNUSED;
+{
+  return CGEN_DIS_HASH (buf, value);
+}
+
+/* Set the recorded length of the insn in the CGEN_FIELDS struct.  */
+
+static void
+set_fields_bitsize (CGEN_FIELDS *fields, int size)
+{
+  CGEN_FIELDS_BITSIZE (fields) = size;
+}
+
+/* Function to call before using the operand instance table.
+   This plugs the opcode entries and macro instructions into the cpu table.  */
+
+void
+or1k_cgen_init_opcode_table (CGEN_CPU_DESC cd)
+{
+  int i;
+  int num_macros = (sizeof (or1k_cgen_macro_insn_table) /
+		    sizeof (or1k_cgen_macro_insn_table[0]));
+  const CGEN_IBASE *ib = & or1k_cgen_macro_insn_table[0];
+  const CGEN_OPCODE *oc = & or1k_cgen_macro_insn_opcode_table[0];
+  CGEN_INSN *insns = xmalloc (num_macros * sizeof (CGEN_INSN));
+
+  /* This test has been added to avoid a warning generated
+     if memset is called with a third argument of value zero.  */
+  if (num_macros >= 1)
+    memset (insns, 0, num_macros * sizeof (CGEN_INSN));
+  for (i = 0; i < num_macros; ++i)
+    {
+      insns[i].base = &ib[i];
+      insns[i].opcode = &oc[i];
+      or1k_cgen_build_insn_regex (& insns[i]);
+    }
+  cd->macro_insn_table.init_entries = insns;
+  cd->macro_insn_table.entry_size = sizeof (CGEN_IBASE);
+  cd->macro_insn_table.num_init_entries = num_macros;
+
+  oc = & or1k_cgen_insn_opcode_table[0];
+  insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    {
+      insns[i].opcode = &oc[i];
+      or1k_cgen_build_insn_regex (& insns[i]);
+    }
+
+  cd->sizeof_fields = sizeof (CGEN_FIELDS);
+  cd->set_fields_bitsize = set_fields_bitsize;
+
+  cd->asm_hash_p = asm_hash_insn_p;
+  cd->asm_hash = asm_hash_insn;
+  cd->asm_hash_size = CGEN_ASM_HASH_SIZE;
+
+  cd->dis_hash_p = dis_hash_insn_p;
+  cd->dis_hash = dis_hash_insn;
+  cd->dis_hash_size = CGEN_DIS_HASH_SIZE;
+}
--- /dev/null
+++ b/opcodes/or1k-opc.h
@@ -0,0 +1,133 @@
+/* Instruction opcode header for or1k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2010 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#ifndef OR1K_OPC_H
+#define OR1K_OPC_H
+
+/* -- opc.h */
+
+#undef  CGEN_DIS_HASH_SIZE
+#define CGEN_DIS_HASH_SIZE 256
+#undef  CGEN_DIS_HASH
+#define CGEN_DIS_HASH(buffer, value) (((unsigned char *) (buffer))[0] >> 2)
+
+/* -- */
+/* Enum declaration for or1k instruction types.  */
+typedef enum cgen_insn_type {
+  OR1K_INSN_INVALID, OR1K_INSN_L_J, OR1K_INSN_L_JAL, OR1K_INSN_L_JR
+ , OR1K_INSN_L_JALR, OR1K_INSN_L_BNF, OR1K_INSN_L_BF, OR1K_INSN_L_TRAP
+ , OR1K_INSN_L_SYS, OR1K_INSN_L_RFE, OR1K_INSN_L_NOP_IMM, OR1K_INSN_L_NOP
+ , OR1K_INSN_L_MOVHI, OR1K_INSN_L_MACRC, OR1K_INSN_L_MFSPR, OR1K_INSN_L_MTSPR
+ , OR1K_INSN_L_LWZ, OR1K_INSN_L_LWS, OR1K_INSN_L_LBZ, OR1K_INSN_L_LBS
+ , OR1K_INSN_L_LHZ, OR1K_INSN_L_LHS, OR1K_INSN_L_SW, OR1K_INSN_L_SB
+ , OR1K_INSN_L_SH, OR1K_INSN_L_SLL, OR1K_INSN_L_SLLI, OR1K_INSN_L_SRL
+ , OR1K_INSN_L_SRLI, OR1K_INSN_L_SRA, OR1K_INSN_L_SRAI, OR1K_INSN_L_ROR
+ , OR1K_INSN_L_RORI, OR1K_INSN_L_AND, OR1K_INSN_L_OR, OR1K_INSN_L_XOR
+ , OR1K_INSN_L_ADD, OR1K_INSN_L_SUB, OR1K_INSN_L_ADDC, OR1K_INSN_L_MUL
+ , OR1K_INSN_L_MULU, OR1K_INSN_L_DIV, OR1K_INSN_L_DIVU, OR1K_INSN_L_FF1
+ , OR1K_INSN_L_FL1, OR1K_INSN_L_ANDI, OR1K_INSN_L_ORI, OR1K_INSN_L_XORI
+ , OR1K_INSN_L_ADDI, OR1K_INSN_L_ADDIC, OR1K_INSN_L_MULI, OR1K_INSN_L_EXTHS
+ , OR1K_INSN_L_EXTBS, OR1K_INSN_L_EXTHZ, OR1K_INSN_L_EXTBZ, OR1K_INSN_L_EXTWS
+ , OR1K_INSN_L_EXTWZ, OR1K_INSN_L_CMOV, OR1K_INSN_L_SFGTS, OR1K_INSN_L_SFGTSI
+ , OR1K_INSN_L_SFGTU, OR1K_INSN_L_SFGTUI, OR1K_INSN_L_SFGES, OR1K_INSN_L_SFGESI
+ , OR1K_INSN_L_SFGEU, OR1K_INSN_L_SFGEUI, OR1K_INSN_L_SFLTS, OR1K_INSN_L_SFLTSI
+ , OR1K_INSN_L_SFLTU, OR1K_INSN_L_SFLTUI, OR1K_INSN_L_SFLES, OR1K_INSN_L_SFLESI
+ , OR1K_INSN_L_SFLEU, OR1K_INSN_L_SFLEUI, OR1K_INSN_L_SFEQ, OR1K_INSN_L_SFEQI
+ , OR1K_INSN_L_SFNE, OR1K_INSN_L_SFNEI, OR1K_INSN_L_MAC, OR1K_INSN_L_MSB
+ , OR1K_INSN_L_MACI, OR1K_INSN_L_CUST1, OR1K_INSN_L_CUST2, OR1K_INSN_L_CUST3
+ , OR1K_INSN_L_CUST4, OR1K_INSN_L_CUST5, OR1K_INSN_L_CUST6, OR1K_INSN_L_CUST7
+ , OR1K_INSN_L_CUST8, OR1K_INSN_LF_ADD_S, OR1K_INSN_LF_ADD_D, OR1K_INSN_LF_SUB_S
+ , OR1K_INSN_LF_SUB_D, OR1K_INSN_LF_MUL_S, OR1K_INSN_LF_MUL_D, OR1K_INSN_LF_DIV_S
+ , OR1K_INSN_LF_DIV_D, OR1K_INSN_LF_REM_S, OR1K_INSN_LF_REM_D, OR1K_INSN_LF_ITOF_S
+ , OR1K_INSN_LF_ITOF_D, OR1K_INSN_LF_FTOI_S, OR1K_INSN_LF_FTOI_D, OR1K_INSN_LF_EQ_S
+ , OR1K_INSN_LF_EQ_D, OR1K_INSN_LF_NE_S, OR1K_INSN_LF_NE_D, OR1K_INSN_LF_GE_S
+ , OR1K_INSN_LF_GE_D, OR1K_INSN_LF_GT_S, OR1K_INSN_LF_GT_D, OR1K_INSN_LF_LT_S
+ , OR1K_INSN_LF_LT_D, OR1K_INSN_LF_LE_S, OR1K_INSN_LF_LE_D, OR1K_INSN_LF_MADD_S
+ , OR1K_INSN_LF_MADD_D, OR1K_INSN_LF_CUST1_S, OR1K_INSN_LF_CUST1_D
+} CGEN_INSN_TYPE;
+
+/* Index of `invalid' insn place holder.  */
+#define CGEN_INSN_INVALID OR1K_INSN_INVALID
+
+/* Total number of insns in table.  */
+#define MAX_INSNS ((int) OR1K_INSN_LF_CUST1_D + 1)
+
+/* This struct records data prior to insertion or after extraction.  */
+struct cgen_fields
+{
+  int length;
+  long f_nil;
+  long f_anyof;
+  long f_opcode;
+  long f_r1;
+  long f_r2;
+  long f_r3;
+  long f_op_25_2;
+  long f_op_25_5;
+  long f_op_16_1;
+  long f_op_7_4;
+  long f_op_3_4;
+  long f_op_9_2;
+  long f_op_9_4;
+  long f_op_7_8;
+  long f_op_7_2;
+  long f_resv_25_26;
+  long f_resv_25_10;
+  long f_resv_25_5;
+  long f_resv_23_8;
+  long f_resv_20_5;
+  long f_resv_20_4;
+  long f_resv_15_8;
+  long f_resv_15_6;
+  long f_resv_10_11;
+  long f_resv_10_7;
+  long f_resv_10_3;
+  long f_resv_10_1;
+  long f_resv_7_4;
+  long f_resv_5_2;
+  long f_imm16_25_5;
+  long f_imm16_10_11;
+  long f_disp26;
+  long f_uimm16;
+  long f_simm16;
+  long f_uimm6;
+  long f_uimm16_split;
+  long f_simm16_split;
+};
+
+#define CGEN_INIT_PARSE(od) \
+{\
+}
+#define CGEN_INIT_INSERT(od) \
+{\
+}
+#define CGEN_INIT_EXTRACT(od) \
+{\
+}
+#define CGEN_INIT_PRINT(od) \
+{\
+}
+
+
+#endif /* OR1K_OPC_H */
--- /dev/null
+++ b/opcodes/or1k-opinst.c
@@ -0,0 +1,556 @@
+/* Semantic operand instances for or1k.
+
+THIS FILE IS MACHINE GENERATED WITH CGEN.
+
+Copyright 1996-2010 Free Software Foundation, Inc.
+
+This file is part of the GNU Binutils and/or GDB, the GNU debugger.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   It is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with this program; if not, write to the Free Software Foundation, Inc.,
+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+
+*/
+
+#include "sysdep.h"
+#include "ansidecl.h"
+#include "bfd.h"
+#include "symcat.h"
+#include "or1k-desc.h"
+#include "or1k-opc.h"
+
+/* Operand references.  */
+
+#define OP_ENT(op) OR1K_OPERAND_##op
+#define INPUT CGEN_OPINST_INPUT
+#define OUTPUT CGEN_OPINST_OUTPUT
+#define END CGEN_OPINST_END
+#define COND_REF CGEN_OPINST_COND_REF
+
+static const CGEN_OPINST sfmt_empty_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_j_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "disp26", HW_H_IADDR, CGEN_MODE_UDI, OP_ENT (DISP26), 0, 0 },
+  { INPUT, "sys_cpucfgr_nd", HW_H_SYS_CPUCFGR_ND, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_jal_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "disp26", HW_H_IADDR, CGEN_MODE_UDI, OP_ENT (DISP26), 0, 0 },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_cpucfgr_nd", HW_H_SYS_CPUCFGR_ND, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "h_gpr_UDI_9", HW_H_GPR, CGEN_MODE_UDI, 0, 9, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_jr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "sys_cpucfgr_nd", HW_H_SYS_CPUCFGR_ND, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_jalr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "sys_cpucfgr_nd", HW_H_SYS_CPUCFGR_ND, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "h_gpr_UDI_9", HW_H_GPR, CGEN_MODE_UDI, 0, 9, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_bnf_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "disp26", HW_H_IADDR, CGEN_MODE_UDI, OP_ENT (DISP26), 0, COND_REF },
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "sys_cpucfgr_nd", HW_H_SYS_CPUCFGR_ND, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_trap_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_rfe_ops[] ATTRIBUTE_UNUSED = {
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_nop_imm_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_movhi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_macrc_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "mac_machi", HW_H_MAC_MACHI, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_mfspr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "uimm16", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_mtspr_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "uimm16_split", HW_H_UIMM16, CGEN_MODE_UINT, OP_ENT (UIMM16_SPLIT), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lwz_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_USI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_4", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lws_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_SI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_4", HW_H_MEMORY, CGEN_MODE_SI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lbz_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UQI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_1", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lbs_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_QI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_1", HW_H_MEMORY, CGEN_MODE_QI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lhz_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_UHI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_2", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_lhs_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "h_memory_HI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_2", HW_H_MEMORY, CGEN_MODE_HI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sw_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "simm16_split", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16_SPLIT), 0, 0 },
+  { OUTPUT, "h_memory_USI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_split_4", HW_H_MEMORY, CGEN_MODE_USI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sb_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "simm16_split", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16_SPLIT), 0, 0 },
+  { OUTPUT, "h_memory_UQI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_split_1", HW_H_MEMORY, CGEN_MODE_UQI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sh_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "simm16_split", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16_SPLIT), 0, 0 },
+  { OUTPUT, "h_memory_UHI_c_call__AI_@cpu@_make_load_store_addr_rA_ext__SI_simm16_split_2", HW_H_MEMORY, CGEN_MODE_UHI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sll_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_slli_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "uimm6", HW_H_UIMM6, CGEN_MODE_UINT, OP_ENT (UIMM6), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_and_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_add_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ove", HW_H_SYS_SR_OVE, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { OUTPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_addc_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ove", HW_H_SYS_SR_OVE, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { OUTPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_div_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, COND_REF },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { INPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ove", HW_H_SYS_SR_OVE, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, COND_REF },
+  { OUTPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { OUTPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_ff1_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_xori_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_addi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { INPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ove", HW_H_SYS_SR_OVE, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { OUTPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_addic_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "pc", HW_H_PC, CGEN_MODE_UDI, 0, 0, COND_REF },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { INPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "sys_sr_ove", HW_H_SYS_SR_OVE, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { OUTPUT, "sys_sr_cy", HW_H_SYS_SR_CY, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "sys_sr_ov", HW_H_SYS_SR_OV, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_exths_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_cmov_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, COND_REF },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, COND_REF },
+  { INPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, COND_REF },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sfgts_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { OUTPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_sfgtsi_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_mac_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "mac_machi", HW_H_MAC_MACHI, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "rB", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RB), 0, 0 },
+  { OUTPUT, "mac_machi", HW_H_MAC_MACHI, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_l_maci_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "mac_machi", HW_H_MAC_MACHI, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "simm16", HW_H_SIMM16, CGEN_MODE_INT, OP_ENT (SIMM16), 0, 0 },
+  { OUTPUT, "mac_machi", HW_H_MAC_MACHI, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "mac_maclo", HW_H_MAC_MACLO, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_add_s_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rASF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RASF), 0, 0 },
+  { INPUT, "rBSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RBSF), 0, 0 },
+  { OUTPUT, "rDSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RDSF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_add_d_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rADF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RADF), 0, 0 },
+  { INPUT, "rBDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RBDF), 0, 0 },
+  { OUTPUT, "rDDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RDDF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_itof_s_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "sys_fpcsr_rm", HW_H_SYS_FPCSR_RM, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rDSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RDSF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_itof_d_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rA", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RA), 0, 0 },
+  { INPUT, "sys_fpcsr_rm", HW_H_SYS_FPCSR_RM, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rDDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RDDF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_ftoi_s_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rASF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RASF), 0, 0 },
+  { INPUT, "sys_fpcsr_rm", HW_H_SYS_FPCSR_RM, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_ftoi_d_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rADF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RADF), 0, 0 },
+  { INPUT, "sys_fpcsr_rm", HW_H_SYS_FPCSR_RM, CGEN_MODE_UDI, 0, 0, 0 },
+  { OUTPUT, "rD", HW_H_GPR, CGEN_MODE_UDI, OP_ENT (RD), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_eq_s_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rASF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RASF), 0, 0 },
+  { INPUT, "rBSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RBSF), 0, 0 },
+  { OUTPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_eq_d_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rADF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RADF), 0, 0 },
+  { INPUT, "rBDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RBDF), 0, 0 },
+  { OUTPUT, "sys_sr_f", HW_H_SYS_SR_F, CGEN_MODE_UDI, 0, 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_madd_s_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rASF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RASF), 0, 0 },
+  { INPUT, "rBSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RBSF), 0, 0 },
+  { INPUT, "rDSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RDSF), 0, 0 },
+  { OUTPUT, "rDSF", HW_H_FSR, CGEN_MODE_SF, OP_ENT (RDSF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+static const CGEN_OPINST sfmt_lf_madd_d_ops[] ATTRIBUTE_UNUSED = {
+  { INPUT, "rADF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RADF), 0, 0 },
+  { INPUT, "rBDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RBDF), 0, 0 },
+  { INPUT, "rDDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RDDF), 0, 0 },
+  { OUTPUT, "rDDF", HW_H_FDR, CGEN_MODE_DF, OP_ENT (RDDF), 0, 0 },
+  { END, (const char *)0, (enum cgen_hw_type)0, (enum cgen_mode)0, (enum cgen_operand_type)0, 0, 0 }
+};
+
+#undef OP_ENT
+#undef INPUT
+#undef OUTPUT
+#undef END
+#undef COND_REF
+
+/* Operand instance lookup table.  */
+
+static const CGEN_OPINST *or1k_cgen_opinst_table[MAX_INSNS] = {
+  0,
+  & sfmt_l_j_ops[0],
+  & sfmt_l_jal_ops[0],
+  & sfmt_l_jr_ops[0],
+  & sfmt_l_jalr_ops[0],
+  & sfmt_l_bnf_ops[0],
+  & sfmt_l_bnf_ops[0],
+  & sfmt_l_trap_ops[0],
+  & sfmt_l_trap_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_nop_imm_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_movhi_ops[0],
+  & sfmt_l_macrc_ops[0],
+  & sfmt_l_mfspr_ops[0],
+  & sfmt_l_mtspr_ops[0],
+  & sfmt_l_lwz_ops[0],
+  & sfmt_l_lws_ops[0],
+  & sfmt_l_lbz_ops[0],
+  & sfmt_l_lbs_ops[0],
+  & sfmt_l_lhz_ops[0],
+  & sfmt_l_lhs_ops[0],
+  & sfmt_l_sw_ops[0],
+  & sfmt_l_sb_ops[0],
+  & sfmt_l_sh_ops[0],
+  & sfmt_l_sll_ops[0],
+  & sfmt_l_slli_ops[0],
+  & sfmt_l_sll_ops[0],
+  & sfmt_l_slli_ops[0],
+  & sfmt_l_sll_ops[0],
+  & sfmt_l_slli_ops[0],
+  & sfmt_l_sll_ops[0],
+  & sfmt_l_slli_ops[0],
+  & sfmt_l_and_ops[0],
+  & sfmt_l_and_ops[0],
+  & sfmt_l_and_ops[0],
+  & sfmt_l_add_ops[0],
+  & sfmt_l_add_ops[0],
+  & sfmt_l_addc_ops[0],
+  & sfmt_l_add_ops[0],
+  & sfmt_l_add_ops[0],
+  & sfmt_l_div_ops[0],
+  & sfmt_l_div_ops[0],
+  & sfmt_l_ff1_ops[0],
+  & sfmt_l_ff1_ops[0],
+  & sfmt_l_mfspr_ops[0],
+  & sfmt_l_mfspr_ops[0],
+  & sfmt_l_xori_ops[0],
+  & sfmt_l_addi_ops[0],
+  & sfmt_l_addic_ops[0],
+  & sfmt_l_addi_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_exths_ops[0],
+  & sfmt_l_cmov_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_sfgts_ops[0],
+  & sfmt_l_sfgtsi_ops[0],
+  & sfmt_l_mac_ops[0],
+  & sfmt_l_mac_ops[0],
+  & sfmt_l_maci_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_lf_add_s_ops[0],
+  & sfmt_lf_add_d_ops[0],
+  & sfmt_lf_add_s_ops[0],
+  & sfmt_lf_add_d_ops[0],
+  & sfmt_lf_add_s_ops[0],
+  & sfmt_lf_add_d_ops[0],
+  & sfmt_lf_add_s_ops[0],
+  & sfmt_lf_add_d_ops[0],
+  & sfmt_lf_add_s_ops[0],
+  & sfmt_lf_add_d_ops[0],
+  & sfmt_lf_itof_s_ops[0],
+  & sfmt_lf_itof_d_ops[0],
+  & sfmt_lf_ftoi_s_ops[0],
+  & sfmt_lf_ftoi_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_eq_s_ops[0],
+  & sfmt_lf_eq_d_ops[0],
+  & sfmt_lf_madd_s_ops[0],
+  & sfmt_lf_madd_d_ops[0],
+  & sfmt_l_rfe_ops[0],
+  & sfmt_l_rfe_ops[0],
+};
+
+/* Function to call before using the operand instance table.  */
+
+void
+or1k_cgen_init_opinst_table (cd)
+     CGEN_CPU_DESC cd;
+{
+  int i;
+  const CGEN_OPINST **oi = & or1k_cgen_opinst_table[0];
+  CGEN_INSN *insns = (CGEN_INSN *) cd->insn_table.init_entries;
+  for (i = 0; i < MAX_INSNS; ++i)
+    insns[i].opinst = oi[i];
+}
--- a/opcodes/or32-dis.c
+++ /dev/null
@@ -1,325 +0,0 @@
-/* Instruction printing code for the OpenRISC 1000
-   Copyright (C) 2002, 2005, 2007, 2012 Free Software Foundation, Inc.
-   Contributed by Damjan Lampret <lampret@opencores.org>.
-   Modified from a29k port.
-
-   This file is part of the GNU opcodes library.
-
-   This library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#ifndef DEBUG
-#define DEBUG 0
-#endif
-
-#include "sysdep.h"
-#include "dis-asm.h"
-#include "opcode/or32.h"
-#include "safe-ctype.h"
-
-#define EXTEND29(x) ((x) & (unsigned long) 0x10000000 ? ((x) | (unsigned long) 0xf0000000) : ((x)))
-
-/* Now find the four bytes of INSN_CH and put them in *INSN.  */
-
-static void
-find_bytes_big (unsigned char *insn_ch, unsigned long *insn)
-{
-  *insn =
-    ((unsigned long) insn_ch[0] << 24) +
-    ((unsigned long) insn_ch[1] << 16) +
-    ((unsigned long) insn_ch[2] << 8) +
-    ((unsigned long) insn_ch[3]);
-#if DEBUG
-  printf ("find_bytes_big3: %lx\n", *insn);
-#endif
-}
-
-static void
-find_bytes_little (unsigned char *insn_ch, unsigned long *insn)
-{
-  *insn =
-    ((unsigned long) insn_ch[3] << 24) +
-    ((unsigned long) insn_ch[2] << 16) +
-    ((unsigned long) insn_ch[1] << 8) +
-    ((unsigned long) insn_ch[0]);
-}
-
-typedef void (*find_byte_func_type) (unsigned char *, unsigned long *);
-
-static unsigned long
-or32_extract (char param_ch, char *enc_initial, unsigned long insn)
-{
-  char *enc;
-  unsigned long ret = 0;
-  int opc_pos = 0;
-  int param_pos = 0;
-
-  for (enc = enc_initial; *enc != '\0'; enc++)
-    if (*enc == param_ch)
-      {
-	if (enc - 2 >= enc_initial && (*(enc - 2) == '0') && (*(enc - 1) == 'x'))
-	  continue;
-	else
-	  param_pos++;
-      }
-
-#if DEBUG
-  printf ("or32_extract: %c %x ", param_ch, param_pos);
-#endif
-  opc_pos = 32;
-
-  for (enc = enc_initial; *enc != '\0'; )
-    if ((*enc == '0') && (*(enc + 1) == 'x'))
-      {
-	opc_pos -= 4;
-
-	if ((param_ch == '0') || (param_ch == '1'))
-	  {
-	    unsigned long tmp = strtoul (enc, NULL, 16);
-#if DEBUG
-	    printf (" enc=%s, tmp=%lx ", enc, tmp);
-#endif
-	    if (param_ch == '0')
-	      tmp = 15 - tmp;
-	    ret |= tmp << opc_pos;
-	  }
-	enc += 3;
-      }
-    else if ((*enc == '0') || (*enc == '1'))
-      {
-	opc_pos--;
-	if (param_ch == *enc)
-	  ret |= 1 << opc_pos;
-	enc++;
-      }
-    else if (*enc == param_ch)
-      {
-	opc_pos--;
-	param_pos--;
-#if DEBUG
-	printf ("\n  ret=%lx opc_pos=%x, param_pos=%x\n", ret, opc_pos, param_pos);
-#endif
-	ret += ((insn >> opc_pos) & 0x1) << param_pos;
-
-	if (!param_pos
-	    && letter_signed (param_ch)
-	    && ret >> (letter_range (param_ch) - 1))
-	  {
-#if DEBUG
-	    printf ("\n  ret=%lx opc_pos=%x, param_pos=%x\n",
-		    ret, opc_pos, param_pos);
-#endif
-	    ret |= 0xffffffff << letter_range(param_ch);
-#if DEBUG
-	    printf ("\n  after conversion to signed: ret=%lx\n", ret);
-#endif
-	  }
-	enc++;
-      }
-    else if (ISALPHA (*enc))
-      {
-	opc_pos--;
-	enc++;
-      }
-    else if (*enc == '-')
-      {
-	opc_pos--;
-	enc++;
-      }
-    else
-      enc++;
-
-#if DEBUG
-  printf ("ret=%lx\n", ret);
-#endif
-  return ret;
-}
-
-static int
-or32_opcode_match (unsigned long insn, char *encoding)
-{
-  unsigned long ones, zeros;
-
-#if DEBUG
-  printf ("or32_opcode_match: %.8lx\n", insn);
-#endif    
-  ones  = or32_extract ('1', encoding, insn);
-  zeros = or32_extract ('0', encoding, insn);
-  
-#if DEBUG
-  printf ("ones: %lx \n", ones);
-  printf ("zeros: %lx \n", zeros);
-#endif
-  if ((insn & ones) != ones)
-    {
-#if DEBUG
-      printf ("ret1\n");
-#endif
-      return 0;
-    }
-    
-  if ((~insn & zeros) != zeros)
-    {
-#if DEBUG
-      printf ("ret2\n");
-#endif
-      return 0;
-    }
-  
-#if DEBUG
-  printf ("ret3\n");
-#endif
-  return 1;
-}
-
-/* Print register to INFO->STREAM. Used only by print_insn.  */
-
-static void
-or32_print_register (char param_ch,
-		     char *encoding,
-		     unsigned long insn,
-		     struct disassemble_info *info)
-{
-  int regnum = or32_extract (param_ch, encoding, insn);
-  
-#if DEBUG
-  printf ("or32_print_register: %c, %s, %lx\n", param_ch, encoding, insn);
-#endif  
-  if (param_ch == 'A')
-    (*info->fprintf_func) (info->stream, "r%d", regnum);
-  else if (param_ch == 'B')
-    (*info->fprintf_func) (info->stream, "r%d", regnum);
-  else if (param_ch == 'D')
-    (*info->fprintf_func) (info->stream, "r%d", regnum);
-  else if (regnum < 16)
-    (*info->fprintf_func) (info->stream, "r%d", regnum);
-  else if (regnum < 32)
-    (*info->fprintf_func) (info->stream, "r%d", regnum-16);
-  else
-    (*info->fprintf_func) (info->stream, "X%d", regnum);
-}
-
-/* Print immediate to INFO->STREAM. Used only by print_insn.  */
-
-static void
-or32_print_immediate (char param_ch,
-		      char *encoding,
-		      unsigned long insn,
-		      struct disassemble_info *info)
-{
-  int imm = or32_extract(param_ch, encoding, insn);
-  
-  if (letter_signed(param_ch))
-    (*info->fprintf_func) (info->stream, "0x%x", imm);
-/*    (*info->fprintf_func) (info->stream, "%d", imm); */
-  else
-    (*info->fprintf_func) (info->stream, "0x%x", imm);
-}
-
-/* Print one instruction from MEMADDR on INFO->STREAM.
-   Return the size of the instruction (always 4 on or32).  */
-
-static int
-print_insn (bfd_vma memaddr, struct disassemble_info *info)
-{
-  /* The raw instruction.  */
-  unsigned char insn_ch[4];
-  /* Address. Will be sign extened 27-bit.  */
-  unsigned long addr;
-  /* The four bytes of the instruction.  */
-  unsigned long insn;
-  find_byte_func_type find_byte_func = (find_byte_func_type) info->private_data;
-  struct or32_opcode const * opcode;
-
-  {
-    int status =
-      (*info->read_memory_func) (memaddr, (bfd_byte *) &insn_ch[0], 4, info);
-
-    if (status != 0)
-      {
-        (*info->memory_error_func) (status, memaddr, info);
-        return -1;
-      }
-  }
-
-  (*find_byte_func) (&insn_ch[0], &insn);
-
-  for (opcode = &or32_opcodes[0];
-       opcode < &or32_opcodes[or32_num_opcodes];
-       ++opcode)
-    {
-      if (or32_opcode_match (insn, opcode->encoding))
-        {
-          char *s;
-
-          (*info->fprintf_func) (info->stream, "%s ", opcode->name);
-
-          for (s = opcode->args; *s != '\0'; ++s)
-            {
-              switch (*s)
-                {
-                case '\0':
-                  return 4;
-      
-                case 'r':
-                  or32_print_register (*++s, opcode->encoding, insn, info);
-                  break;
-
-                case 'X':
-                  addr = or32_extract ('X', opcode->encoding, insn) << 2;
-
-                  /* Calulate the correct address.  XXX is this really correct ??  */
-                  addr = memaddr + EXTEND29 (addr);
-
-                  (*info->print_address_func)
-                    (addr, info);
-                  break;
-
-                default:
-                  if (strchr (opcode->encoding, *s))
-                    or32_print_immediate (*s, opcode->encoding, insn, info);
-                  else
-                    (*info->fprintf_func) (info->stream, "%c", *s);
-                }
-            }
-
-          return 4;
-        }
-    }
-
-  /* This used to be %8x for binutils.  */
-  (*info->fprintf_func)
-    (info->stream, ".word 0x%08lx", insn);
-  return 4;
-}
-
-/* Disassemble a big-endian or32 instruction.  */
-
-int
-print_insn_big_or32 (bfd_vma memaddr, struct disassemble_info *info)
-{
-  info->private_data = find_bytes_big;
-
-  return print_insn (memaddr, info);
-}
-
-/* Disassemble a little-endian or32 instruction.  */
-
-int
-print_insn_little_or32 (bfd_vma memaddr, struct disassemble_info *info)
-{
-  info->private_data = find_bytes_little;
-  return print_insn (memaddr, info);
-}
--- a/opcodes/or32-opc.c
+++ /dev/null
@@ -1,1031 +0,0 @@
-/* Table of opcodes for the OpenRISC 1000 ISA.
-   Copyright 2002, 2004, 2005, 2007, 2008, 2009, 2012
-   Free Software Foundation, Inc.
-   Contributed by Damjan Lampret (lampret@opencores.org).
-   
-   This file is part of the GNU opcodes library.
-
-   This library is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3, or (at your option)
-   any later version.
-
-   It is distributed in the hope that it will be useful, but WITHOUT
-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
-   License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program; if not, write to the Free Software
-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
-   MA 02110-1301, USA.  */
-
-#include "sysdep.h"
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "safe-ctype.h"
-#include "ansidecl.h"
-#include "opcode/or32.h"
-
-/* We treat all letters the same in encode/decode routines so
-   we need to assign some characteristics to them like signess etc.  */
-
-const struct or32_letter or32_letters[] =
-{
-  { 'A', NUM_UNSIGNED },
-  { 'B', NUM_UNSIGNED },
-  { 'D', NUM_UNSIGNED },
-  { 'I', NUM_SIGNED },
-  { 'K', NUM_UNSIGNED },
-  { 'L', NUM_UNSIGNED },
-  { 'N', NUM_SIGNED },
-  { '0', NUM_UNSIGNED },
-  { '\0', 0 }     /* Dummy entry.  */
-};
-
-/* Opcode encoding:
-   machine[31:30]: first two bits of opcode
-   		   00 - neither of source operands is GPR
-   		   01 - second source operand is GPR (rB)
-   		   10 - first source operand is GPR (rA)
-   		   11 - both source operands are GPRs (rA and rB)
-   machine[29:26]: next four bits of opcode
-   machine[25:00]: instruction operands (specific to individual instruction)
-
-  Recommendation: irrelevant instruction bits should be set with a value of
-  bits in same positions of instruction preceding current instruction in the
-  code (when assembling).  */
-
-#define EFN &l_none
-
-#ifdef HAS_EXECUTION
-#define EF(func) &(func)
-#define EFI &l_invalid
-#else  /* HAS_EXECUTION */
-#define EF(func) EFN
-#define EFI EFN
-#endif /* HAS_EXECUTION */
-
-const struct or32_opcode or32_opcodes[] =
-{
-  { "l.j",       "N",            "00 0x0  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_j), OR32_IF_DELAY },
-  { "l.jal",     "N",            "00 0x1  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_jal), OR32_IF_DELAY },
-  { "l.bnf",     "N",            "00 0x3  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bnf), OR32_IF_DELAY | OR32_R_FLAG},
-  { "l.bf",      "N",            "00 0x4  NNNNN NNNNN NNNN NNNN NNNN NNNN", EF(l_bf), OR32_IF_DELAY | OR32_R_FLAG },
-  { "l.nop",     "K",            "00 0x5  01--- ----- KKKK KKKK KKKK KKKK", EF(l_nop), 0 },
-  { "l.movhi",   "rD,K",         "00 0x6  DDDDD ----0 KKKK KKKK KKKK KKKK", EF(l_movhi), 0 }, /*MM*/
-  { "l.macrc",   "rD",           "00 0x6  DDDDD ----1 0000 0000 0000 0000", EF(l_macrc), 0 }, /*MM*/
-
-  { "l.sys",     "K",            "00 0x8  00000 00000 KKKK KKKK KKKK KKKK", EF(l_sys), 0 },
-  { "l.trap",    "K",            "00 0x8  01000 00000 KKKK KKKK KKKK KKKK", EF(l_trap), 0 }, /* CZ 21/06/01 */
-  { "l.msync",   "",             "00 0x8  10000 00000 0000 0000 0000 0000", EFN, 0 },
-  { "l.psync",   "",             "00 0x8  10100 00000 0000 0000 0000 0000", EFN, 0 },
-  { "l.csync",   "",             "00 0x8  11000 00000 0000 0000 0000 0000", EFN, 0 },
-  { "l.rfe",     "",             "00 0x9  ----- ----- ---- ---- ---- ----", EF(l_rfe), OR32_IF_DELAY },
-
-  { "lv.all_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
-  { "lv.all_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
-  { "lv.all_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
-  { "lv.all_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
-  { "lv.all_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
-  { "lv.all_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
-  { "lv.all_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
-  { "lv.all_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
-  { "lv.all_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
-  { "lv.all_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
-  { "lv.all_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
-  { "lv.all_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
-  { "lv.any_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x0", EFI, 0 },
-  { "lv.any_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x1", EFI, 0 },
-  { "lv.any_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x2", EFI, 0 },
-  { "lv.any_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x3", EFI, 0 },
-  { "lv.any_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x4", EFI, 0 },
-  { "lv.any_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x5", EFI, 0 },
-  { "lv.any_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x6", EFI, 0 },
-  { "lv.any_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x7", EFI, 0 },
-  { "lv.any_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x8", EFI, 0 },
-  { "lv.any_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0x9", EFI, 0 },
-  { "lv.any_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xA", EFI, 0 },
-  { "lv.any_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x2 0xB", EFI, 0 },
-  { "lv.add.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x0", EFI, 0 },
-  { "lv.add.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x1", EFI, 0 },
-  { "lv.adds.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x2", EFI, 0 },
-  { "lv.adds.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x3", EFI, 0 },
-  { "lv.addu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x4", EFI, 0 },
-  { "lv.addu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x5", EFI, 0 },
-  { "lv.addus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x6", EFI, 0 },
-  { "lv.addus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x7", EFI, 0 },
-  { "lv.and",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x8", EFI, 0 },
-  { "lv.avg.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0x9", EFI, 0 },
-  { "lv.avg.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x3 0xA", EFI, 0 },
-  { "lv.cmp_eq.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x0", EFI, 0 },
-  { "lv.cmp_eq.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x1", EFI, 0 },
-  { "lv.cmp_ge.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x2", EFI, 0 },
-  { "lv.cmp_ge.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x3", EFI, 0 },
-  { "lv.cmp_gt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x4", EFI, 0 },
-  { "lv.cmp_gt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x5", EFI, 0 },
-  { "lv.cmp_le.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x6", EFI, 0 },
-  { "lv.cmp_le.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x7", EFI, 0 },
-  { "lv.cmp_lt.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x8", EFI, 0 },
-  { "lv.cmp_lt.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0x9", EFI, 0 },
-  { "lv.cmp_ne.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xA", EFI, 0 },
-  { "lv.cmp_ne.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x4 0xB", EFI, 0 },
-  { "lv.madds.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x4", EFI, 0 },
-  { "lv.max.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x5", EFI, 0 },
-  { "lv.max.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x6", EFI, 0 },
-  { "lv.merge.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x7", EFI, 0 },
-  { "lv.merge.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x8", EFI, 0 },
-  { "lv.min.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0x9", EFI, 0 },
-  { "lv.min.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xA", EFI, 0 },
-  { "lv.msubs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xB", EFI, 0 },
-  { "lv.muls.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xC", EFI, 0 },
-  { "lv.nand",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xD", EFI, 0 },
-  { "lv.nor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xE", EFI, 0 },
-  { "lv.or",     "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x5 0xF", EFI, 0 },
-  { "lv.pack.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x0", EFI, 0 },
-  { "lv.pack.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x1", EFI, 0 },
-  { "lv.packs.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x2", EFI, 0 },
-  { "lv.packs.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x3", EFI, 0 },
-  { "lv.packus.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x4", EFI, 0 },
-  { "lv.packus.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x5", EFI, 0 },
-  { "lv.perm.n", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x6", EFI, 0 },
-  { "lv.rl.b",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x7", EFI, 0 },
-  { "lv.rl.h",   "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x8", EFI, 0 },
-  { "lv.sll.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0x9", EFI, 0 },
-  { "lv.sll.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xA", EFI, 0 },
-  { "lv.sll",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xB", EFI, 0 },
-  { "lv.srl.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xC", EFI, 0 },
-  { "lv.srl.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xD", EFI, 0 },
-  { "lv.sra.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xE", EFI, 0 },
-  { "lv.sra.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x6 0xF", EFI, 0 },
-  { "lv.srl",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x0", EFI, 0 },
-  { "lv.sub.b",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x1", EFI, 0 },
-  { "lv.sub.h",  "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x2", EFI, 0 },
-  { "lv.subs.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x3", EFI, 0 },
-  { "lv.subs.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x4", EFI, 0 },
-  { "lv.subu.b", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x5", EFI, 0 },
-  { "lv.subu.h", "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x6", EFI, 0 },
-  { "lv.subus.b","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x7", EFI, 0 },
-  { "lv.subus.h","rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x8", EFI, 0 },
-  { "lv.unpack.b","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0x9", EFI, 0 },
-  { "lv.unpack.h","rD,rA,rB",    "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xA", EFI, 0 },
-  { "lv.xor",    "rD,rA,rB",     "00 0xA  DDDDD AAAAA BBBB B--- 0x7 0xB", EFI, 0 },
-  { "lv.cust1",  "",	       "00 0xA  ----- ----- ---- ---- 0xC ----", EFI, 0 },
-  { "lv.cust2",  "",	       "00 0xA  ----- ----- ---- ---- 0xD ----", EFI, 0 },
-  { "lv.cust3",  "",	       "00 0xA  ----- ----- ---- ---- 0xE ----", EFI, 0 },
-  { "lv.cust4",  "",	       "00 0xA  ----- ----- ---- ---- 0xF ----", EFI, 0 },
-  
-  { "lf.add.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
-  { "lf.sub.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
-  { "lf.mul.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
-  { "lf.div.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
-  { "lf.itof.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
-  { "lf.ftoi.s",  "rD,rA",       "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
-  { "lf.rem.s",   "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
-  { "lf.madd.s",  "rD,rA,rB",    "00 0xB  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
-  { "lf.sfeq.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
-  { "lf.sfne.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
-  { "lf.sfgt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
-  { "lf.sfge.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
-  { "lf.sflt.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
-  { "lf.sfle.s",  "rA,rB",       "00 0xB  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
-  { "lf.cust1.s", "",	       "00 0xB  ----- ----- ---- ---- 0xE ----", EFI, 0 },
-
-  { "lf.add.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
-  { "lf.sub.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
-  { "lf.mul.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x2", EFI, 0 },
-  { "lf.div.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x3", EFI, 0 },
-  { "lf.itof.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x4", EFI, 0 },
-  { "lf.ftoi.d",  "rD,rA",       "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x5", EFI, 0 },
-  { "lf.rem.d",   "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x6", EFI, 0 },
-  { "lf.madd.d",  "rD,rA,rB",    "00 0xC  DDDDD AAAAA BBBB B--- 0x1 0x7", EFI, 0 },
-  { "lf.sfeq.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x8", EFI, 0 },
-  { "lf.sfne.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0x9", EFI, 0 },
-  { "lf.sfgt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xA", EFI, 0 },
-  { "lf.sfge.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xB", EFI, 0 },
-  { "lf.sflt.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xC", EFI, 0 },
-  { "lf.sfle.d",  "rA,rB",       "00 0xC  ----- AAAAA BBBB B--- 0x1 0xD", EFI, 0 },
-  { "lf.cust1.d", "",	       "00 0xC  ----- ----- ---- ---- 0xE ----", EFI, 0 },
-
-  { "lvf.ld",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x0", EFI, 0 },
-  { "lvf.lw",     "rD,0(rA)",    "00 0xD  DDDDD AAAAA ---- ---- 0x0 0x1", EFI, 0 },
-  { "lvf.sd",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x0", EFI, 0 },
-  { "lvf.sw",     "0(rA),rB",    "00 0xD  ----- AAAAA BBBB B--- 0x1 0x1", EFI, 0 },
-
-  { "l.jr",      "rB",           "01 0x1  ----- ----- BBBB B--- ---- ----", EF(l_jr), OR32_IF_DELAY },
-  { "l.jalr",    "rB",           "01 0x2  ----- ----- BBBB B--- ---- ----", EF(l_jalr), OR32_IF_DELAY },
-  { "l.maci",    "rB,I",         "01 0x3  IIIII ----- BBBB BIII IIII IIII", EF(l_mac), 0 },
-  { "l.cust1",   "",	       "01 0xC  ----- ----- ---- ---- ---- ----", EF(l_cust1), 0 },
-  { "l.cust2",   "",	       "01 0xD  ----- ----- ---- ---- ---- ----", EF(l_cust2), 0 },
-  { "l.cust3",   "",	       "01 0xE  ----- ----- ---- ---- ---- ----", EF(l_cust3), 0 },
-  { "l.cust4",   "",	       "01 0xF  ----- ----- ---- ---- ---- ----", EF(l_cust4), 0 },
-
-  { "l.ld",      "rD,I(rA)",     "10 0x0  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
-  { "l.lwz",     "rD,I(rA)",     "10 0x1  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lwz), 0 },
-  { "l.lws",     "rD,I(rA)",     "10 0x2  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
-  { "l.lbz",     "rD,I(rA)",     "10 0x3  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbz), 0 },
-  { "l.lbs",     "rD,I(rA)",     "10 0x4  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lbs), 0 },
-  { "l.lhz",     "rD,I(rA)",     "10 0x5  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhz), 0 },
-  { "l.lhs",     "rD,I(rA)",     "10 0x6  DDDDD AAAAA IIII IIII IIII IIII", EF(l_lhs), 0 },
-
-  { "l.addi",    "rD,rA,I",      "10 0x7  DDDDD AAAAA IIII IIII IIII IIII", EF(l_add), 0 },
-  { "l.addic",   "rD,rA,I",      "10 0x8  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
-  { "l.andi",    "rD,rA,K",      "10 0x9  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_and), 0 },
-  { "l.ori",     "rD,rA,K",      "10 0xA  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_or), 0  },
-  { "l.xori",    "rD,rA,I",      "10 0xB  DDDDD AAAAA IIII IIII IIII IIII", EF(l_xor), 0 },
-  { "l.muli",    "rD,rA,I",      "10 0xC  DDDDD AAAAA IIII IIII IIII IIII", EFI, 0 },
-  { "l.mfspr",   "rD,rA,K",      "10 0xD  DDDDD AAAAA KKKK KKKK KKKK KKKK", EF(l_mfspr), 0 },
-  { "l.slli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 00LL LLLL", EF(l_sll), 0 },
-  { "l.srli",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 01LL LLLL", EF(l_srl), 0 },
-  { "l.srai",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 10LL LLLL", EF(l_sra), 0 },
-  { "l.rori",    "rD,rA,L",      "10 0xE  DDDDD AAAAA ---- ---- 11LL LLLL", EFI, 0 },
-
-  { "l.sfeqi",   "rA,I",         "10 0xF  00000 AAAAA IIII IIII IIII IIII", EF(l_sfeq), OR32_W_FLAG },
-  { "l.sfnei",   "rA,I",         "10 0xF  00001 AAAAA IIII IIII IIII IIII", EF(l_sfne), OR32_W_FLAG },
-  { "l.sfgtui",  "rA,I",         "10 0xF  00010 AAAAA IIII IIII IIII IIII", EF(l_sfgtu), OR32_W_FLAG },
-  { "l.sfgeui",  "rA,I",         "10 0xF  00011 AAAAA IIII IIII IIII IIII", EF(l_sfgeu), OR32_W_FLAG },
-  { "l.sfltui",  "rA,I",         "10 0xF  00100 AAAAA IIII IIII IIII IIII", EF(l_sfltu), OR32_W_FLAG },
-  { "l.sfleui",  "rA,I",         "10 0xF  00101 AAAAA IIII IIII IIII IIII", EF(l_sfleu), OR32_W_FLAG },
-  { "l.sfgtsi",  "rA,I",         "10 0xF  01010 AAAAA IIII IIII IIII IIII", EF(l_sfgts), OR32_W_FLAG },
-  { "l.sfgesi",  "rA,I",         "10 0xF  01011 AAAAA IIII IIII IIII IIII", EF(l_sfges), OR32_W_FLAG },
-  { "l.sfltsi",  "rA,I",         "10 0xF  01100 AAAAA IIII IIII IIII IIII", EF(l_sflts), OR32_W_FLAG },
-  { "l.sflesi",  "rA,I",         "10 0xF  01101 AAAAA IIII IIII IIII IIII", EF(l_sfles), OR32_W_FLAG },
-
-  { "l.mtspr",   "rA,rB,K",      "11 0x0  KKKKK AAAAA BBBB BKKK KKKK KKKK", EF(l_mtspr), 0 },
-  { "l.mac",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x1", EF(l_mac), 0 }, /*MM*/
-  { "l.msb",     "rA,rB",        "11 0x1  ----- AAAAA BBBB B--- ---- 0x2", EF(l_msb), 0 }, /*MM*/
-
-  { "l.sd",      "I(rA),rB",     "11 0x4  IIIII AAAAA BBBB BIII IIII IIII", EFI, 0 },
-  { "l.sw",      "I(rA),rB",     "11 0x5  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sw), 0 },
-  { "l.sb",      "I(rA),rB",     "11 0x6  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sb), 0 },
-  { "l.sh",      "I(rA),rB",     "11 0x7  IIIII AAAAA BBBB BIII IIII IIII", EF(l_sh), 0 },
-    
-  { "l.add",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x0", EF(l_add), 0 },
-  { "l.addc",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x1", EFI, 0 },
-  { "l.sub",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x2", EF(l_sub), 0 },
-  { "l.and",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x3", EF(l_and), 0 },
-  { "l.or",      "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x4", EF(l_or), 0 },
-  { "l.xor",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x5", EF(l_xor), 0 },
-  { "l.mul",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0x6", EF(l_mul), 0 },
-
-  { "l.sll",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0x8", EF(l_sll), 0 },
-  { "l.srl",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0x8", EF(l_srl), 0 },
-  { "l.sra",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0x8", EF(l_sra), 0 },
-  { "l.ror",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0x8", EFI, 0 },
-  { "l.div",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0x9", EF(l_div), 0 },
-  { "l.divu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xA", EF(l_divu), 0 },
-  { "l.mulu",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-11 ---- 0xB", EFI, 0 },
-  { "l.exths",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xC", EFI, 0 },
-  { "l.extbs",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xC", EFI, 0 },
-  { "l.exthz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 10-- 0xC", EFI, 0 },
-  { "l.extbz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 11-- 0xC", EFI, 0 },
-  { "l.extws",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 00-- 0xD", EFI, 0 },
-  { "l.extwz",   "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 01-- 0xD", EFI, 0 },
-  { "l.cmov",    "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xE", EFI, 0 },
-  { "l.ff1",     "rD,rA,rB",     "11 0x8  DDDDD AAAAA BBBB B-00 ---- 0xF", EFI, 0 },
-
-  { "l.sfeq",    "rA,rB",        "11 0x9  00000 AAAAA BBBB B--- ---- ----", EF(l_sfeq), OR32_W_FLAG },
-  { "l.sfne",    "rA,rB",        "11 0x9  00001 AAAAA BBBB B--- ---- ----", EF(l_sfne), OR32_W_FLAG },
-  { "l.sfgtu",   "rA,rB",        "11 0x9  00010 AAAAA BBBB B--- ---- ----", EF(l_sfgtu), OR32_W_FLAG },
-  { "l.sfgeu",   "rA,rB",        "11 0x9  00011 AAAAA BBBB B--- ---- ----", EF(l_sfgeu), OR32_W_FLAG },
-  { "l.sfltu",   "rA,rB",        "11 0x9  00100 AAAAA BBBB B--- ---- ----", EF(l_sfltu), OR32_W_FLAG },
-  { "l.sfleu",   "rA,rB",        "11 0x9  00101 AAAAA BBBB B--- ---- ----", EF(l_sfleu), OR32_W_FLAG },
-  { "l.sfgts",   "rA,rB",        "11 0x9  01010 AAAAA BBBB B--- ---- ----", EF(l_sfgts), OR32_W_FLAG },
-  { "l.sfges",   "rA,rB",        "11 0x9  01011 AAAAA BBBB B--- ---- ----", EF(l_sfges), OR32_W_FLAG },
-  { "l.sflts",   "rA,rB",        "11 0x9  01100 AAAAA BBBB B--- ---- ----", EF(l_sflts), OR32_W_FLAG },
-  { "l.sfles",   "rA,rB",        "11 0x9  01101 AAAAA BBBB B--- ---- ----", EF(l_sfles), OR32_W_FLAG },
-
-  { "l.cust5",   "",	       "11 0xC  ----- ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust6",   "",	       "11 0xD  ----- ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust7",   "",	       "11 0xE  ----- ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust8",   "",	       "11 0xF  ----- ----- ---- ---- ---- ----", EFI, 0 },
-
-  /* This section should not be defined in or1ksim, since it contains duplicates,
-     which would cause machine builder to complain.  */
-#ifdef HAS_CUST
-  { "l.cust5_1",   "rD",	       "11 0xC  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust5_2",   "rD,rA"   ,   "11 0xC  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
-  { "l.cust5_3",   "rD,rA,rB",   "11 0xC  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
-
-  { "l.cust6_1",   "rD",	       "11 0xD  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust6_2",   "rD,rA"   ,   "11 0xD  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
-  { "l.cust6_3",   "rD,rA,rB",   "11 0xD  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
-
-  { "l.cust7_1",   "rD",	       "11 0xE  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust7_2",   "rD,rA"   ,   "11 0xE  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
-  { "l.cust7_3",   "rD,rA,rB",   "11 0xE  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
-
-  { "l.cust8_1",   "rD",	       "11 0xF  DDDDD ----- ---- ---- ---- ----", EFI, 0 },
-  { "l.cust8_2",   "rD,rA"   ,   "11 0xF  DDDDD AAAAA ---- ---- ---- ----", EFI, 0 },
-  { "l.cust8_3",   "rD,rA,rB",   "11 0xF  DDDDD AAAAA BBBB B--- ---- ----", EFI, 0 },
-#endif
-
-  /* Dummy entry, not included in num_opcodes.  This
-     lets code examine entry i+1 without checking
-     if we've run off the end of the table.  */
-  { "", "", "", EFI, 0 }
-};
-
-#undef EFI
-#undef EFN
-#undef EF 
-
-/* Define dummy, if debug is not defined.  */
-
-#if !defined HAS_DEBUG
-static void ATTRIBUTE_PRINTF_2
-debug (int level ATTRIBUTE_UNUSED, const char *format ATTRIBUTE_UNUSED, ...)
-{
-}
-#endif
-
-const unsigned int or32_num_opcodes = ((sizeof(or32_opcodes)) / (sizeof(struct or32_opcode))) - 1;
-
-/* Calculates instruction length in bytes. Always 4 for OR32.  */
-
-int
-insn_len (int i_index ATTRIBUTE_UNUSED)
-{
-  return 4;
-}
-
-/* Is individual insn's operand signed or unsigned?  */
-
-int
-letter_signed (char l)
-{
-  const struct or32_letter *pletter;
-  
-  for (pletter = or32_letters; pletter->letter != '\0'; pletter++)
-    if (pletter->letter == l)
-      return pletter->sign;
-  
-  printf ("letter_signed(%c): Unknown letter.\n", l);
-  return 0;
-}
-
-/* Number of letters in the individual lettered operand.  */
-
-int
-letter_range (char l)
-{
-  const struct or32_opcode *pinsn;
-  char *enc;
-  int range = 0;
-  
-  for (pinsn = or32_opcodes; strlen (pinsn->name); pinsn ++)
-    {
-      if (strchr (pinsn->encoding,l))
-	{
-	  for (enc = pinsn->encoding; *enc != '\0'; enc ++)
-	    if ((*enc == '0') && (*(enc + 1) == 'x'))
-	      enc += 2;
-	    else if (*enc == l)
-	      range++;
-	  return range;
-	}
-    }
-
-  printf ("\nABORT: letter_range(%c): Never used letter.\n", l);
-  exit (1);
-}
-
-/* MM: Returns index of given instruction name.  */
-
-int
-insn_index (char *insn)
-{
-  unsigned int i;
-  int found = -1;
-
-  for (i = 0; i < or32_num_opcodes; i++)
-    if (!strcmp (or32_opcodes[i].name, insn))
-      {
-	found = i;
-	break;
-      }
-  return found;
-}
-
-const char *
-insn_name (int op_index)
-{
-  if (op_index >= 0 && op_index < (int) or32_num_opcodes)
-    return or32_opcodes[op_index].name;
-  else
-    return "???";
-}
-
-void
-l_none (void)
-{
-}
-
-/* Finite automata for instruction decoding building code.  */
-
-/* Find simbols in encoding.  */
-
-static unsigned long
-insn_extract (char param_ch, char *enc_initial)
-{
-  char *enc;
-  unsigned long ret = 0;
-  unsigned opc_pos = 32;
-
-  for (enc = enc_initial; *enc != '\0'; )
-    if ((*enc == '0') && (*(enc + 1) == 'x')) 
-      {
-	unsigned long tmp = strtol (enc+2, NULL, 16);
-
-        opc_pos -= 4;
-	if (param_ch == '0' || param_ch == '1')
-	  {
-	    if (param_ch == '0')
-	      tmp = 15 - tmp;
-	    ret |= tmp << opc_pos;
-	  }
-        enc += 3;
-      }
-    else
-      {
-	if (*enc == '0' || *enc == '1' || *enc == '-' || ISALPHA (*enc))
-	  {
-	    opc_pos--;
-	    if (param_ch == *enc)
-	      ret |= 1 << opc_pos;
-	  }
-	enc++;
-      }
-  return ret;
-}
-
-#define MAX_AUTOMATA_SIZE  1200
-#define MAX_OP_TABLE_SIZE  1200
-#define LEAF_FLAG          0x80000000
-#define MAX_LEN            8
-
-#ifndef MIN
-#define MIN(x, y)          ((x) < (y) ? (x) : (y))
-#endif
-
-unsigned long *automata;
-int nuncovered;
-int curpass = 0;
-
-/* MM: Struct that hold runtime build information about instructions.  */
-struct temp_insn_struct
-{
-  unsigned long insn;
-  unsigned long insn_mask;
-  int in_pass;
-} *ti;
-
-struct insn_op_struct *op_data, **op_start;
-
-/* Recursive utility function used to find best match and to build automata.  */
-
-static unsigned long *
-cover_insn (unsigned long * cur, int pass, unsigned int mask)
-{
-  int best_first = 0, last_match = -1, ninstr = 0;
-  unsigned int best_len = 0;
-  unsigned int i;
-  unsigned long cur_mask = mask;
-  unsigned long *next;
-
-  for (i = 0; i < or32_num_opcodes; i++)
-    if (ti[i].in_pass == pass)
-      {
-	cur_mask &= ti[i].insn_mask;
-	ninstr++;
-	last_match = i;
-      }
-  
-  debug (8, "%08X %08lX\n", mask, cur_mask);
-
-  if (ninstr == 0)
-    return 0;
-
-  if (ninstr == 1)
-    {
-      /* Leaf holds instruction index.  */
-      debug (8, "%li>I%i %s\n",
-	     (long)(cur - automata), last_match, or32_opcodes[last_match].name);
-
-      *cur = LEAF_FLAG | last_match;
-      cur++;
-      nuncovered--;
-    }
-  else
-    {
-      /* Find longest match.  */
-      for (i = 0; i < 32; i++)
-	{
-	  unsigned int len;
-
-	  for (len = best_len + 1; len < MIN (MAX_LEN, 33 - i); len++)
-	    {
-	      unsigned long m = (1UL << ((unsigned long) len)) - 1;
-
-	      debug (9, " (%i(%08lX & %08lX>>%i = %08lX, %08lX)",
-		     len,m, cur_mask, i, (cur_mask >> (unsigned)i),
-		     (cur_mask >> (unsigned) i) & m);
-
-	      if ((m & (cur_mask >> (unsigned) i)) == m)
-		{
-		  best_len = len;
-		  best_first = i;
-		  debug (9, "!");
-		}
-	      else
-		break;
-	    }
-	}
-
-      debug (9, "\n");
-
-      if (!best_len)
-	{
-	  fprintf (stderr, "%i instructions match mask 0x%08X:\n", ninstr, mask);
-
-	  for (i = 0; i < or32_num_opcodes; i++)
-	    if (ti[i].in_pass == pass)
-	      fprintf (stderr, "%s ", or32_opcodes[i].name);
-	  
-	  fprintf (stderr, "\n");
-	  exit (1);
-	}
-
-      debug (8, "%li> #### %i << %i (%i) ####\n",
-	     (long)(cur - automata), best_len, best_first, ninstr);
-
-      *cur = best_first;
-      cur++;
-      *cur = (1 << best_len) - 1;
-      cur++;
-      next = cur;    
-
-      /* Allocate space for pointers.  */
-      cur += 1 << best_len;
-      cur_mask = (1 << (unsigned long) best_len) - 1;
-      
-      for (i = 0; i < ((unsigned) 1 << best_len); i++)
-	{
-	  unsigned int j;
-	  unsigned long *c;
-
-	  curpass++;
-	  for (j = 0; j < or32_num_opcodes; j++)
-	    if (ti[j].in_pass == pass
-		&& ((ti[j].insn >> best_first) & cur_mask) == (unsigned long) i
-		&& ((ti[j].insn_mask >> best_first) & cur_mask) == cur_mask)
-	      ti[j].in_pass = curpass;
-
-	  debug (9, "%08X %08lX %i\n", mask, cur_mask, best_first);
-	  c = cover_insn (cur, curpass, mask & (~(cur_mask << best_first)));
-	  if (c)
-	    {
-	      debug (8, "%li> #%X -> %lu\n", (long)(next - automata), i,
-		     (unsigned long)(cur - automata));
-	      *next = cur - automata;
-	      cur = c;	 
-	    }
-	  else 
-	    {
-	      debug (8, "%li> N/A\n", (long)(next - automata));
-	      *next = 0;
-	    }
-	  next++;
-	}
-    }
-  return cur;
-}
-
-/* Returns number of nonzero bits.  */
-
-static int
-num_ones (unsigned long value)
-{
-  int c = 0;
-
-  while (value)
-    {
-      if (value & 1)
-	c++;
-      value >>= 1;
-    }
-  return c;
-}
-
-/* Utility function, which converts parameters from or32_opcode
-   format to more binary form.  Parameters are stored in ti struct.  */
-
-static struct insn_op_struct *
-parse_params (const struct or32_opcode * opcode,
-	      struct insn_op_struct * cur)
-{
-  char *args = opcode->args;
-  int i, type;
-  
-  i = 0;
-  type = 0;
-  /* In case we don't have any parameters, we add dummy read from r0.  */
-
-  if (!(*args))
-    {
-      cur->type = OPTYPE_REG | OPTYPE_OP | OPTYPE_LAST;
-      cur->data = 0;
-      debug (9, "#%08lX %08lX\n", cur->type, cur->data);
-      cur++;
-      return cur;
-  }
-  
-  while (*args != '\0')
-    {     
-      if (*args == 'r')
-	{
-	  args++;
-	  type |= OPTYPE_REG;
-	}
-      else if (ISALPHA (*args))
-	{
-	  unsigned long arg;
-
-	  arg = insn_extract (*args, opcode->encoding);
-	  debug (9, "%s : %08lX ------\n", opcode->name, arg);
-	  if (letter_signed (*args))
-	    {
-	      type |= OPTYPE_SIG;
-	      type |= ((num_ones (arg) - 1) << OPTYPE_SBIT_SHR) & OPTYPE_SBIT;
-	    }
-
-	  /* Split argument to sequences of consecutive ones.  */
-	  while (arg)
-	    {
-	      int shr = 0;
-	      unsigned long tmp = arg, mask = 0;
-
-	      while ((tmp & 1) == 0)
-		{
-		  shr++;
-		  tmp >>= 1;
-		}
-	      while (tmp & 1)
-		{
-		  mask++;
-		  tmp >>= 1;
-		}
-	      cur->type = type | shr;
-	      cur->data = mask;
-	      arg &= ~(((1 << mask) - 1) << shr);
-	      debug (6, "|%08lX %08lX\n", cur->type, cur->data);
-	      cur++;
-	    }
-	  args++;
-	}
-      else if (*args == '(')
-	{
-	  /* Next param is displacement.
-	     Later we will treat them as one operand.  */
-	  cur--;
-	  cur->type = type | cur->type | OPTYPE_DIS | OPTYPE_OP;
-	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
-	  cur++;
-	  type = 0;
-	  i++;
-	  args++;
-	}
-      else if (*args == OPERAND_DELIM)
-	{
-	  cur--;
-	  cur->type = type | cur->type | OPTYPE_OP;
-	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
-	  cur++;
-	  type = 0;
-	  i++;
-	  args++;
-	}
-      else if (*args == '0')
-	{
-	  cur->type = type;
-	  cur->data = 0;
-	  debug (9, ">%08lX %08lX\n", cur->type, cur->data);
-	  cur++;
-	  type = 0;
-	  i++;
-	  args++;
-	}
-      else if (*args == ')')
-	args++;
-      else
-	{
-	  fprintf (stderr, "%s : parse error in args.\n", opcode->name);
-	  exit (1);
-	}
-    }
-
-  cur--;
-  cur->type = type | cur->type | OPTYPE_OP | OPTYPE_LAST;
-  debug (9, "#%08lX %08lX\n", cur->type, cur->data);
-  cur++;
-
-  return cur;
-}
-
-/* Constructs new automata based on or32_opcodes array.  */
-
-void
-build_automata (void)
-{
-  unsigned int i;
-  unsigned long *end;
-  struct insn_op_struct *cur;
-  
-  automata = malloc (MAX_AUTOMATA_SIZE * sizeof (unsigned long));
-  ti = malloc (sizeof (struct temp_insn_struct) * or32_num_opcodes);
-
-  nuncovered = or32_num_opcodes;
-  printf ("Building automata... ");
-  /* Build temporary information about instructions.  */
-  for (i = 0; i < or32_num_opcodes; i++)
-    {
-      unsigned long ones, zeros;
-      char *encoding = or32_opcodes[i].encoding;
-
-      ones  = insn_extract('1', encoding);
-      zeros = insn_extract('0', encoding);
-
-      ti[i].insn_mask = ones | zeros;
-      ti[i].insn = ones;
-      ti[i].in_pass = curpass = 0;
-
-      /*debug(9, "%s: %s %08X %08X\n", or32_opcodes[i].name,
-	or32_opcodes[i].encoding, ti[i].insn_mask, ti[i].insn);*/
-    }
-  
-  /* Until all are covered search for best criteria to separate them.  */
-  end = cover_insn (automata, curpass, 0xFFFFFFFF);
-
-  if (end - automata > MAX_AUTOMATA_SIZE)
-    {
-      fprintf (stderr, "Automata too large. Increase MAX_AUTOMATA_SIZE.");
-      exit (1);
-    }
-
-  printf ("done, num uncovered: %i/%i.\n", nuncovered, or32_num_opcodes);
-  printf ("Parsing operands data... ");
-
-  op_data = malloc (MAX_OP_TABLE_SIZE * sizeof (struct insn_op_struct));
-  op_start = malloc (or32_num_opcodes * sizeof (struct insn_op_struct *));
-  cur = op_data;
-
-  for (i = 0; i < or32_num_opcodes; i++)
-    {
-      op_start[i] = cur;
-      cur = parse_params (&or32_opcodes[i], cur);
-
-      if (cur - op_data > MAX_OP_TABLE_SIZE)
-	{
-	  fprintf (stderr, "Operands table too small, increase MAX_OP_TABLE_SIZE.\n");
-	  exit (1);
-	}
-    }
-  printf ("done.\n");
-}
-
-void
-destruct_automata (void)
-{
-  free (ti);
-  free (automata);
-  free (op_data);
-  free (op_start);
-}
-
-/* Decodes instruction and returns instruction index.  */
-
-int
-insn_decode (unsigned int insn)
-{
-  unsigned long *a = automata;
-  int i;
-
-  while (!(*a & LEAF_FLAG))
-    {
-      unsigned int first = *a;
-
-      debug (9, "%li ", (long)(a - automata));
-
-      a++;
-      i = (insn >> first) & *a;
-      a++;
-      if (!*(a + i))
-	{
-	  /* Invalid instruction found?  */
-	  debug (9, "XXX\n");
-	  return -1;
-	}
-      a = automata + *(a + i);
-    }
-
-  i = *a & ~LEAF_FLAG;
-
-  debug (9, "%i\n", i);
-
-  /* Final check - do we have direct match?
-     (based on or32_opcodes this should be the only possibility,
-     but in case of invalid/missing instruction we must perform a check)  */
-  if ((ti[i].insn_mask & insn) == ti[i].insn) 
-    return i;
-  else
-    return -1;
-}
-
-static char disassembled_str[50];
-char *disassembled = &disassembled_str[0];
-
-/* Automagically does zero- or sign- extension and also finds correct
-   sign bit position if sign extension is correct extension. Which extension
-   is proper is figured out from letter description.  */
-   
-static unsigned long
-extend_imm (unsigned long imm, char l)
-{
-  unsigned long mask;
-  int letter_bits;
-  
-  /* First truncate all bits above valid range for this letter
-     in case it is zero extend.  */
-  letter_bits = letter_range (l);
-  mask = (1 << letter_bits) - 1;
-  imm &= mask;
-  
-  /* Do sign extend if this is the right one.  */
-  if (letter_signed(l) && (imm >> (letter_bits - 1)))
-    imm |= (~mask);
-
-  return imm;
-}
-
-static unsigned long
-or32_extract (char param_ch, char *enc_initial, unsigned long insn)
-{
-  char *enc;
-  unsigned long ret = 0;
-  int opc_pos = 0;
-  int param_pos = 0;
-
-  for (enc = enc_initial; *enc != '\0'; enc++)
-    if (*enc == param_ch)
-      {
-        if (enc - 2 >= enc_initial && (*(enc - 2) == '0') && (*(enc - 1) == 'x'))
-      	  continue;
-        else
-          param_pos++;
-      }
-
-#if DEBUG
-  printf ("or32_extract: %x ", param_pos);
-#endif
-  opc_pos = 32;
-
-  for (enc = enc_initial; *enc != '\0'; )
-    if ((*enc == '0') && (*(enc + 1) == 'x')) 
-      {
-        opc_pos -= 4;
-        if ((param_ch == '0') || (param_ch == '1')) 
-          {
-            unsigned long tmp = strtol (enc, NULL, 16);
-#if DEBUG
-            printf (" enc=%s, tmp=%lx ", enc, tmp);
-#endif
-            if (param_ch == '0')
-              tmp = 15 - tmp;
-            ret |= tmp << opc_pos;
-          }
-        enc += 3;
-      }
-    else if ((*enc == '0') || (*enc == '1')) 
-      {
-        opc_pos--;
-        if (param_ch == *enc)
-          ret |= 1 << opc_pos;
-        enc++;
-      }
-    else if (*enc == param_ch) 
-      {
-        opc_pos--;
-        param_pos--;
-#if DEBUG
-        printf ("\n  ret=%lx opc_pos=%x, param_pos=%x\n", ret, opc_pos, param_pos);
-#endif  
-        if (ISLOWER (param_ch))
-          ret -= ((insn >> opc_pos) & 0x1) << param_pos;
-        else
-          ret += ((insn >> opc_pos) & 0x1) << param_pos;
-        enc++;
-      }
-    else if (ISALPHA (*enc)) 
-      {
-        opc_pos--;
-        enc++;
-      }
-    else if (*enc == '-') 
-      {
-        opc_pos--;
-        enc++;
-      }
-    else
-      enc++;
-
-#if DEBUG
-  printf ("ret=%lx\n", ret);
-#endif
-  return ret;
-}
-
-/* Print register. Used only by print_insn.  */
-
-static void
-or32_print_register (char param_ch, char *encoding, unsigned long insn)
-{
-  int regnum = or32_extract(param_ch, encoding, insn);
-  char s_regnum[20];
-
-  sprintf (s_regnum, "r%d", regnum);
-  strcat (disassembled, s_regnum);
-}
-
-/* Print immediate. Used only by print_insn.  */
-
-static void
-or32_print_immediate (char param_ch, char *encoding, unsigned long insn)
-{
-  int imm = or32_extract (param_ch, encoding, insn);
-  char s_imm[20];
-
-  imm = extend_imm (imm, param_ch);
-
-  if (letter_signed (param_ch))
-    {
-      if (imm < 0)
-	sprintf (s_imm, "%d", imm);
-      else
-	sprintf (s_imm, "0x%x", imm);
-    }
-  else
-    sprintf (s_imm, "%#x", imm);
-  strcat (disassembled, s_imm);
-}
-
-/* Disassemble one instruction from insn to disassemble.
-   Return the size of the instruction.  */
-
-int
-disassemble_insn (unsigned long insn)
-{
-  int op_index;
-  op_index = insn_decode (insn);
-
-  if (op_index >= 0)
-    {
-      struct or32_opcode const *opcode = &or32_opcodes[op_index];
-      char *s;
-
-      sprintf (disassembled, "%s ", opcode->name);
-      for (s = opcode->args; *s != '\0'; ++s)
-        {
-          switch (*s)
-            {
-            case '\0':
-              return 4;
-  
-            case 'r':
-              or32_print_register (*++s, opcode->encoding, insn);
-              break;
-  
-            default:
-              if (strchr (opcode->encoding, *s))
-                or32_print_immediate (*s, opcode->encoding, insn);
-              else
-		{
-		  char s_encoding[2] = { *s, '\0' };
-
-		  strcat (disassembled, s_encoding);
-		}
-
-            }
-        }
-    }
-  else
-    {
-      char s_insn[20];
-
-      /* This used to be %8x for binutils.  */
-      sprintf (s_insn, ".word 0x%08lx", insn);
-      strcat (disassembled, s_insn);
-    }
-
-  return insn_len (insn);
-}
--- /dev/null
+++ b/or1k/allinsn.d
@@ -0,0 +1,689 @@
+#as:
+#objdump: -dr
+#name: allinsn
+
+.*: +file format .*
+
+
+Disassembly of section \.text:
+
+00000000 <localtext>:
+   0:	15 00 00 00 	l\.nop 0x0
+
+00000004 <globaltext>:
+   4:	15 00 00 00 	l\.nop 0x0
+
+00000008 <l_j>:
+   8:	03 ff ff ff 	l\.j 4 <globaltext>
+   c:	00 00 00 01 	l\.j 10 <l_j\+0x8>
+  10:	00 00 00 00 	l\.j 10 <l_j\+0x8>
+  14:	03 ff ff fb 	l\.j 0 <localtext>
+	\.\.\.
+			18: R_OR1K_INSN_REL_26	\.data
+			1c: R_OR1K_INSN_REL_26	globaltext
+			20: R_OR1K_INSN_REL_26	globaldata
+  24:	03 ff ff f9 	l\.j 8 <l_j>
+  28:	00 00 00 01 	l\.j 2c <l_jal>
+
+0000002c <l_jal>:
+  2c:	07 ff ff ff 	l\.jal 28 <l_j\+0x20>
+  30:	04 00 00 01 	l\.jal 34 <l_jal\+0x8>
+  34:	04 00 00 00 	l\.jal 34 <l_jal\+0x8>
+  38:	07 ff ff f2 	l\.jal 0 <localtext>
+  3c:	04 00 00 00 	l\.jal 3c <l_jal\+0x10>
+			3c: R_OR1K_INSN_REL_26	\.data
+  40:	04 00 00 00 	l\.jal 40 <l_jal\+0x14>
+			40: R_OR1K_INSN_REL_26	globaltext
+  44:	04 00 00 00 	l\.jal 44 <l_jal\+0x18>
+			44: R_OR1K_INSN_REL_26	globaldata
+  48:	07 ff ff f0 	l\.jal 8 <l_j>
+  4c:	07 ff ff f8 	l\.jal 2c <l_jal>
+
+00000050 <l_jr>:
+  50:	44 00 00 00 	l\.jr r0
+  54:	44 00 f8 00 	l\.jr r31
+  58:	44 00 80 00 	l\.jr r16
+  5c:	44 00 78 00 	l\.jr r15
+  60:	44 00 08 00 	l\.jr r1
+  64:	44 00 d8 00 	l\.jr r27
+  68:	44 00 70 00 	l\.jr r14
+  6c:	44 00 b0 00 	l\.jr r22
+
+00000070 <l_jalr>:
+  70:	48 00 00 00 	l\.jalr r0
+  74:	48 00 f8 00 	l\.jalr r31
+  78:	48 00 80 00 	l\.jalr r16
+  7c:	48 00 78 00 	l\.jalr r15
+  80:	48 00 08 00 	l\.jalr r1
+  84:	48 00 d8 00 	l\.jalr r27
+  88:	48 00 70 00 	l\.jalr r14
+  8c:	48 00 b0 00 	l\.jalr r22
+
+00000090 <l_bnf>:
+  90:	0f ff ff ff 	l\.bnf 8c <l_jalr\+0x1c>
+  94:	0c 00 00 01 	l\.bnf 98 <l_bnf\+0x8>
+  98:	0c 00 00 00 	l\.bnf 98 <l_bnf\+0x8>
+  9c:	0f ff ff d9 	l\.bnf 0 <localtext>
+  a0:	0c 00 00 00 	l\.bnf a0 <l_bnf\+0x10>
+			a0: R_OR1K_INSN_REL_26	\.data
+  a4:	0c 00 00 00 	l\.bnf a4 <l_bnf\+0x14>
+			a4: R_OR1K_INSN_REL_26	globaltext
+  a8:	0c 00 00 00 	l\.bnf a8 <l_bnf\+0x18>
+			a8: R_OR1K_INSN_REL_26	globaldata
+  ac:	0f ff ff d7 	l\.bnf 8 <l_j>
+  b0:	0f ff ff df 	l\.bnf 2c <l_jal>
+
+000000b4 <l_bf>:
+  b4:	13 ff ff ff 	l\.bf b0 <l_bnf\+0x20>
+  b8:	10 00 00 01 	l\.bf bc <l_bf\+0x8>
+  bc:	10 00 00 00 	l\.bf bc <l_bf\+0x8>
+  c0:	13 ff ff d0 	l\.bf 0 <localtext>
+  c4:	10 00 00 00 	l\.bf c4 <l_bf\+0x10>
+			c4: R_OR1K_INSN_REL_26	\.data
+  c8:	10 00 00 00 	l\.bf c8 <l_bf\+0x14>
+			c8: R_OR1K_INSN_REL_26	globaltext
+  cc:	10 00 00 00 	l\.bf cc <l_bf\+0x18>
+			cc: R_OR1K_INSN_REL_26	globaldata
+  d0:	13 ff ff ce 	l\.bf 8 <l_j>
+  d4:	13 ff ff d6 	l\.bf 2c <l_jal>
+
+000000d8 <l_trap>:
+  d8:	21 00 00 00 	l\.trap 0x0
+  dc:	21 00 ff ff 	l\.trap 0xffff
+  e0:	21 00 80 00 	l\.trap 0x8000
+  e4:	21 00 7f ff 	l\.trap 0x7fff
+  e8:	21 00 00 01 	l\.trap 0x1
+  ec:	21 00 d1 4f 	l\.trap 0xd14f
+  f0:	21 00 7f 7c 	l\.trap 0x7f7c
+  f4:	21 00 d2 4a 	l\.trap 0xd24a
+
+000000f8 <l_sys>:
+  f8:	20 00 00 00 	l\.sys 0x0
+  fc:	20 00 ff ff 	l\.sys 0xffff
+ 100:	20 00 80 00 	l\.sys 0x8000
+ 104:	20 00 7f ff 	l\.sys 0x7fff
+ 108:	20 00 00 01 	l\.sys 0x1
+ 10c:	20 00 d2 85 	l\.sys 0xd285
+ 110:	20 00 e3 15 	l\.sys 0xe315
+ 114:	20 00 80 fa 	l\.sys 0x80fa
+
+00000118 <l_rfe>:
+ 118:	24 00 00 00 	l\.rfe
+
+0000011c <l_nop>:
+ 11c:	15 00 00 00 	l\.nop 0x0
+
+00000120 <l_movhi>:
+ 120:	18 00 00 00 	l\.movhi r0,0x0
+ 124:	1b e0 ff ff 	l\.movhi r31,0xffff
+ 128:	1a 00 80 00 	l\.movhi r16,0x8000
+ 12c:	19 e0 7f ff 	l\.movhi r15,0x7fff
+ 130:	18 20 00 01 	l\.movhi r1,0x1
+ 134:	1b 80 81 ce 	l\.movhi r28,0x81ce
+ 138:	1a e0 e8 ac 	l\.movhi r23,0xe8ac
+ 13c:	1a 60 d8 c0 	l\.movhi r19,0xd8c0
+
+00000140 <l_mfspr>:
+ 140:	b4 00 00 00 	l\.mfspr r0,r0,0x0
+ 144:	b7 ff ff ff 	l\.mfspr r31,r31,0xffff
+ 148:	b6 10 80 00 	l\.mfspr r16,r16,0x8000
+ 14c:	b5 ef 7f ff 	l\.mfspr r15,r15,0x7fff
+ 150:	b4 21 00 01 	l\.mfspr r1,r1,0x1
+ 154:	b6 fd d4 98 	l\.mfspr r23,r29,0xd498
+ 158:	b6 74 11 81 	l\.mfspr r19,r20,0x1181
+ 15c:	b7 42 f7 d6 	l\.mfspr r26,r2,0xf7d6
+
+00000160 <l_mtspr>:
+ 160:	c0 00 00 00 	l\.mtspr r0,r0,0x0
+ 164:	c3 ff ff ff 	l\.mtspr r31,r31,0xffff
+ 168:	c2 10 80 00 	l\.mtspr r16,r16,0x8000
+ 16c:	c1 ef 7f ff 	l\.mtspr r15,r15,0x7fff
+ 170:	c0 01 08 01 	l\.mtspr r1,r1,0x1
+ 174:	c0 fe 33 77 	l\.mtspr r30,r6,0x3b77
+ 178:	c2 a9 3c cc 	l\.mtspr r9,r7,0xaccc
+ 17c:	c3 f9 3d 7b 	l\.mtspr r25,r7,0xfd7b
+
+00000180 <l_lwz>:
+ 180:	84 00 00 00 	l\.lwz r0,0\(r0\)
+ 184:	87 ff ff ff 	l\.lwz r31,-1\(r31\)
+ 188:	86 10 80 00 	l\.lwz r16,-32768\(r16\)
+ 18c:	85 ef 7f ff 	l\.lwz r15,32767\(r15\)
+ 190:	84 21 00 01 	l\.lwz r1,1\(r1\)
+ 194:	85 f9 0b 75 	l\.lwz r15,2933\(r25\)
+ 198:	86 35 fc e1 	l\.lwz r17,-799\(r21\)
+ 19c:	84 12 bb 45 	l\.lwz r0,-17595\(r18\)
+
+000001a0 <l_lws>:
+ 1a0:	88 00 00 00 	l\.lws r0,0\(r0\)
+ 1a4:	8b ff ff ff 	l\.lws r31,-1\(r31\)
+ 1a8:	8a 10 80 00 	l\.lws r16,-32768\(r16\)
+ 1ac:	89 ef 7f ff 	l\.lws r15,32767\(r15\)
+ 1b0:	88 21 00 01 	l\.lws r1,1\(r1\)
+ 1b4:	88 35 bb 3a 	l\.lws r1,-17606\(r21\)
+ 1b8:	89 df 69 0b 	l\.lws r14,26891\(r31\)
+ 1bc:	89 00 6b a0 	l\.lws r8,27552\(r0\)
+
+000001c0 <l_lbz>:
+ 1c0:	8c 00 00 00 	l\.lbz r0,0\(r0\)
+ 1c4:	8f ff ff ff 	l\.lbz r31,-1\(r31\)
+ 1c8:	8e 10 80 00 	l\.lbz r16,-32768\(r16\)
+ 1cc:	8d ef 7f ff 	l\.lbz r15,32767\(r15\)
+ 1d0:	8c 21 00 01 	l\.lbz r1,1\(r1\)
+ 1d4:	8e 74 64 23 	l\.lbz r19,25635\(r20\)
+ 1d8:	8d e9 f2 a8 	l\.lbz r15,-3416\(r9\)
+ 1dc:	8c 61 45 54 	l\.lbz r3,17748\(r1\)
+
+000001e0 <l_lbs>:
+ 1e0:	90 00 00 00 	l\.lbs r0,0\(r0\)
+ 1e4:	93 ff ff ff 	l\.lbs r31,-1\(r31\)
+ 1e8:	92 10 80 00 	l\.lbs r16,-32768\(r16\)
+ 1ec:	91 ef 7f ff 	l\.lbs r15,32767\(r15\)
+ 1f0:	90 21 00 01 	l\.lbs r1,1\(r1\)
+ 1f4:	93 48 44 c6 	l\.lbs r26,17606\(r8\)
+ 1f8:	92 d0 86 a0 	l\.lbs r22,-31072\(r16\)
+ 1fc:	90 c9 44 20 	l\.lbs r6,17440\(r9\)
+
+00000200 <l_lhz>:
+ 200:	94 00 00 00 	l\.lhz r0,0\(r0\)
+ 204:	97 ff ff ff 	l\.lhz r31,-1\(r31\)
+ 208:	96 10 80 00 	l\.lhz r16,-32768\(r16\)
+ 20c:	95 ef 7f ff 	l\.lhz r15,32767\(r15\)
+ 210:	94 21 00 01 	l\.lhz r1,1\(r1\)
+ 214:	94 a4 e9 dd 	l\.lhz r5,-5667\(r4\)
+ 218:	97 04 16 d8 	l\.lhz r24,5848\(r4\)
+ 21c:	95 47 7b bb 	l\.lhz r10,31675\(r7\)
+
+00000220 <l_lhs>:
+ 220:	98 00 00 00 	l\.lhs r0,0\(r0\)
+ 224:	9b ff ff ff 	l\.lhs r31,-1\(r31\)
+ 228:	9a 10 80 00 	l\.lhs r16,-32768\(r16\)
+ 22c:	99 ef 7f ff 	l\.lhs r15,32767\(r15\)
+ 230:	98 21 00 01 	l\.lhs r1,1\(r1\)
+ 234:	98 cb ff 72 	l\.lhs r6,-142\(r11\)
+ 238:	9a 9d eb 46 	l\.lhs r20,-5306\(r29\)
+ 23c:	99 f5 10 52 	l\.lhs r15,4178\(r21\)
+
+00000240 <l_sw>:
+ 240:	d4 00 00 00 	l\.sw 0\(r0\),r0
+ 244:	d7 ff ff ff 	l\.sw -1\(r31\),r31
+ 248:	d6 10 80 00 	l\.sw -32768\(r16\),r16
+ 24c:	d5 ef 7f ff 	l\.sw 32767\(r15\),r15
+ 250:	d4 01 08 01 	l\.sw 1\(r1\),r1
+ 254:	d7 91 50 e1 	l\.sw -7967\(r17\),r10
+ 258:	d4 1e 57 20 	l\.sw 1824\(r30\),r10
+ 25c:	d5 ef 23 4e 	l\.sw 31566\(r15\),r4
+
+00000260 <l_sb>:
+ 260:	d8 00 00 00 	l\.sb 0\(r0\),r0
+ 264:	db ff ff ff 	l\.sb -1\(r31\),r31
+ 268:	da 10 80 00 	l\.sb -32768\(r16\),r16
+ 26c:	d9 ef 7f ff 	l\.sb 32767\(r15\),r15
+ 270:	d8 01 08 01 	l\.sb 1\(r1\),r1
+ 274:	d9 4a 06 b8 	l\.sb 22200\(r10\),r0
+ 278:	d8 90 df 0b 	l\.sb 9995\(r16\),r27
+ 27c:	da 4e f9 9c 	l\.sb -28260\(r14\),r31
+
+00000280 <l_sh>:
+ 280:	dc 00 00 00 	l\.sh 0\(r0\),r0
+ 284:	df ff ff ff 	l\.sh -1\(r31\),r31
+ 288:	de 10 80 00 	l\.sh -32768\(r16\),r16
+ 28c:	dd ef 7f ff 	l\.sh 32767\(r15\),r15
+ 290:	dc 01 08 01 	l\.sh 1\(r1\),r1
+ 294:	dc b5 c9 bd 	l\.sh 10685\(r21\),r25
+ 298:	df 3c 2c f6 	l\.sh -13066\(r28\),r5
+ 29c:	de 49 ef 50 	l\.sh -26800\(r9\),r29
+
+000002a0 <l_sll>:
+ 2a0:	e0 00 00 08 	l\.sll r0,r0,r0
+ 2a4:	e3 ff f8 08 	l\.sll r31,r31,r31
+ 2a8:	e2 10 80 08 	l\.sll r16,r16,r16
+ 2ac:	e1 ef 78 08 	l\.sll r15,r15,r15
+ 2b0:	e0 21 08 08 	l\.sll r1,r1,r1
+ 2b4:	e3 f0 40 08 	l\.sll r31,r16,r8
+ 2b8:	e3 f1 b0 08 	l\.sll r31,r17,r22
+ 2bc:	e1 ee 28 08 	l\.sll r15,r14,r5
+
+000002c0 <l_slli>:
+ 2c0:	b8 00 00 00 	l\.slli r0,r0,0x0
+ 2c4:	bb ff 00 3f 	l\.slli r31,r31,0x3f
+ 2c8:	ba 10 00 20 	l\.slli r16,r16,0x20
+ 2cc:	b9 ef 00 1f 	l\.slli r15,r15,0x1f
+ 2d0:	b8 21 00 01 	l\.slli r1,r1,0x1
+ 2d4:	b9 6e 00 31 	l\.slli r11,r14,0x31
+ 2d8:	b8 fb 00 17 	l\.slli r7,r27,0x17
+ 2dc:	bb d0 00 0b 	l\.slli r30,r16,0xb
+
+000002e0 <l_srl>:
+ 2e0:	e0 00 00 48 	l\.srl r0,r0,r0
+ 2e4:	e3 ff f8 48 	l\.srl r31,r31,r31
+ 2e8:	e2 10 80 48 	l\.srl r16,r16,r16
+ 2ec:	e1 ef 78 48 	l\.srl r15,r15,r15
+ 2f0:	e0 21 08 48 	l\.srl r1,r1,r1
+ 2f4:	e1 f9 68 48 	l\.srl r15,r25,r13
+ 2f8:	e2 60 88 48 	l\.srl r19,r0,r17
+ 2fc:	e1 a0 b8 48 	l\.srl r13,r0,r23
+
+00000300 <l_srli>:
+ 300:	b8 00 00 40 	l\.srli r0,r0,0x0
+ 304:	bb ff 00 7f 	l\.srli r31,r31,0x3f
+ 308:	ba 10 00 60 	l\.srli r16,r16,0x20
+ 30c:	b9 ef 00 5f 	l\.srli r15,r15,0x1f
+ 310:	b8 21 00 41 	l\.srli r1,r1,0x1
+ 314:	b9 fe 00 4d 	l\.srli r15,r30,0xd
+ 318:	b9 a3 00 7f 	l\.srli r13,r3,0x3f
+ 31c:	b8 52 00 5e 	l\.srli r2,r18,0x1e
+
+00000320 <l_sra>:
+ 320:	e0 00 00 88 	l\.sra r0,r0,r0
+ 324:	e3 ff f8 88 	l\.sra r31,r31,r31
+ 328:	e2 10 80 88 	l\.sra r16,r16,r16
+ 32c:	e1 ef 78 88 	l\.sra r15,r15,r15
+ 330:	e0 21 08 88 	l\.sra r1,r1,r1
+ 334:	e0 7a 00 88 	l\.sra r3,r26,r0
+ 338:	e3 b2 d8 88 	l\.sra r29,r18,r27
+ 33c:	e3 7d 18 88 	l\.sra r27,r29,r3
+
+00000340 <l_srai>:
+ 340:	b8 00 00 80 	l\.srai r0,r0,0x0
+ 344:	bb ff 00 bf 	l\.srai r31,r31,0x3f
+ 348:	ba 10 00 a0 	l\.srai r16,r16,0x20
+ 34c:	b9 ef 00 9f 	l\.srai r15,r15,0x1f
+ 350:	b8 21 00 81 	l\.srai r1,r1,0x1
+ 354:	b9 4b 00 9c 	l\.srai r10,r11,0x1c
+ 358:	ba ef 00 b0 	l\.srai r23,r15,0x30
+ 35c:	ba 0f 00 a6 	l\.srai r16,r15,0x26
+
+00000360 <l_ror>:
+ 360:	e0 00 00 c8 	l\.ror r0,r0,r0
+ 364:	e3 ff f8 c8 	l\.ror r31,r31,r31
+ 368:	e2 10 80 c8 	l\.ror r16,r16,r16
+ 36c:	e1 ef 78 c8 	l\.ror r15,r15,r15
+ 370:	e0 21 08 c8 	l\.ror r1,r1,r1
+ 374:	e3 ac 28 c8 	l\.ror r29,r12,r5
+ 378:	e2 46 20 c8 	l\.ror r18,r6,r4
+ 37c:	e0 50 88 c8 	l\.ror r2,r16,r17
+
+00000380 <l_rori>:
+ 380:	b8 00 00 c0 	l\.rori r0,r0,0x0
+ 384:	bb ff 00 ff 	l\.rori r31,r31,0x3f
+ 388:	ba 10 00 e0 	l\.rori r16,r16,0x20
+ 38c:	b9 ef 00 df 	l\.rori r15,r15,0x1f
+ 390:	b8 21 00 c1 	l\.rori r1,r1,0x1
+ 394:	ba 20 00 d7 	l\.rori r17,r0,0x17
+ 398:	ba 1f 00 ea 	l\.rori r16,r31,0x2a
+ 39c:	b9 b5 00 cc 	l\.rori r13,r21,0xc
+
+000003a0 <l_add>:
+ 3a0:	e0 00 00 00 	l\.add r0,r0,r0
+ 3a4:	e3 ff f8 00 	l\.add r31,r31,r31
+ 3a8:	e2 10 80 00 	l\.add r16,r16,r16
+ 3ac:	e1 ef 78 00 	l\.add r15,r15,r15
+ 3b0:	e0 21 08 00 	l\.add r1,r1,r1
+ 3b4:	e3 a7 20 00 	l\.add r29,r7,r4
+ 3b8:	e3 aa 90 00 	l\.add r29,r10,r18
+ 3bc:	e2 56 b8 00 	l\.add r18,r22,r23
+
+000003c0 <l_sub>:
+ 3c0:	e0 00 00 02 	l\.sub r0,r0,r0
+ 3c4:	e3 ff f8 02 	l\.sub r31,r31,r31
+ 3c8:	e2 10 80 02 	l\.sub r16,r16,r16
+ 3cc:	e1 ef 78 02 	l\.sub r15,r15,r15
+ 3d0:	e0 21 08 02 	l\.sub r1,r1,r1
+ 3d4:	e2 fa 70 02 	l\.sub r23,r26,r14
+ 3d8:	e1 58 78 02 	l\.sub r10,r24,r15
+ 3dc:	e1 64 90 02 	l\.sub r11,r4,r18
+
+000003e0 <l_and>:
+ 3e0:	e0 00 00 03 	l\.and r0,r0,r0
+ 3e4:	e3 ff f8 03 	l\.and r31,r31,r31
+ 3e8:	e2 10 80 03 	l\.and r16,r16,r16
+ 3ec:	e1 ef 78 03 	l\.and r15,r15,r15
+ 3f0:	e0 21 08 03 	l\.and r1,r1,r1
+ 3f4:	e0 1f c8 03 	l\.and r0,r31,r25
+ 3f8:	e3 c7 98 03 	l\.and r30,r7,r19
+ 3fc:	e2 62 d0 03 	l\.and r19,r2,r26
+
+00000400 <l_or>:
+ 400:	e0 00 00 04 	l\.or r0,r0,r0
+ 404:	e3 ff f8 04 	l\.or r31,r31,r31
+ 408:	e2 10 80 04 	l\.or r16,r16,r16
+ 40c:	e1 ef 78 04 	l\.or r15,r15,r15
+ 410:	e0 21 08 04 	l\.or r1,r1,r1
+ 414:	e2 2a 10 04 	l\.or r17,r10,r2
+ 418:	e0 f3 e8 04 	l\.or r7,r19,r29
+ 41c:	e0 71 88 04 	l\.or r3,r17,r17
+
+00000420 <l_xor>:
+ 420:	e0 00 00 05 	l\.xor r0,r0,r0
+ 424:	e3 ff f8 05 	l\.xor r31,r31,r31
+ 428:	e2 10 80 05 	l\.xor r16,r16,r16
+ 42c:	e1 ef 78 05 	l\.xor r15,r15,r15
+ 430:	e0 21 08 05 	l\.xor r1,r1,r1
+ 434:	e3 e5 88 05 	l\.xor r31,r5,r17
+ 438:	e2 c4 28 05 	l\.xor r22,r4,r5
+ 43c:	e3 d4 d0 05 	l\.xor r30,r20,r26
+
+00000440 <l_addc>:
+ 440:	e0 00 00 01 	l\.addc r0,r0,r0
+ 444:	e3 ff f8 01 	l\.addc r31,r31,r31
+ 448:	e2 10 80 01 	l\.addc r16,r16,r16
+ 44c:	e1 ef 78 01 	l\.addc r15,r15,r15
+ 450:	e0 21 08 01 	l\.addc r1,r1,r1
+ 454:	e1 1a c0 01 	l\.addc r8,r26,r24
+ 458:	e2 46 20 01 	l\.addc r18,r6,r4
+ 45c:	e3 a0 90 01 	l\.addc r29,r0,r18
+
+00000460 <l_mul>:
+ 460:	e0 00 03 06 	l\.mul r0,r0,r0
+ 464:	e3 ff fb 06 	l\.mul r31,r31,r31
+ 468:	e2 10 83 06 	l\.mul r16,r16,r16
+ 46c:	e1 ef 7b 06 	l\.mul r15,r15,r15
+ 470:	e0 21 0b 06 	l\.mul r1,r1,r1
+ 474:	e1 19 6b 06 	l\.mul r8,r25,r13
+ 478:	e1 15 eb 06 	l\.mul r8,r21,r29
+ 47c:	e3 63 8b 06 	l\.mul r27,r3,r17
+
+00000480 <l_mulu>:
+ 480:	e0 00 03 0b 	l\.mulu r0,r0,r0
+ 484:	e3 ff fb 0b 	l\.mulu r31,r31,r31
+ 488:	e2 10 83 0b 	l\.mulu r16,r16,r16
+ 48c:	e1 ef 7b 0b 	l\.mulu r15,r15,r15
+ 490:	e0 21 0b 0b 	l\.mulu r1,r1,r1
+ 494:	e3 4e 83 0b 	l\.mulu r26,r14,r16
+ 498:	e0 32 5b 0b 	l\.mulu r1,r18,r11
+ 49c:	e1 d2 8b 0b 	l\.mulu r14,r18,r17
+
+000004a0 <l_div>:
+ 4a0:	e0 00 03 09 	l\.div r0,r0,r0
+ 4a4:	e3 ff fb 09 	l\.div r31,r31,r31
+ 4a8:	e2 10 83 09 	l\.div r16,r16,r16
+ 4ac:	e1 ef 7b 09 	l\.div r15,r15,r15
+ 4b0:	e0 21 0b 09 	l\.div r1,r1,r1
+ 4b4:	e0 02 e3 09 	l\.div r0,r2,r28
+ 4b8:	e3 47 fb 09 	l\.div r26,r7,r31
+ 4bc:	e0 52 a3 09 	l\.div r2,r18,r20
+
+000004c0 <l_divu>:
+ 4c0:	e0 00 03 0a 	l\.divu r0,r0,r0
+ 4c4:	e3 ff fb 0a 	l\.divu r31,r31,r31
+ 4c8:	e2 10 83 0a 	l\.divu r16,r16,r16
+ 4cc:	e1 ef 7b 0a 	l\.divu r15,r15,r15
+ 4d0:	e0 21 0b 0a 	l\.divu r1,r1,r1
+ 4d4:	e0 a4 cb 0a 	l\.divu r5,r4,r25
+ 4d8:	e1 0b eb 0a 	l\.divu r8,r11,r29
+ 4dc:	e1 73 13 0a 	l\.divu r11,r19,r2
+
+000004e0 <l_addi>:
+ 4e0:	9c 00 00 00 	l\.addi r0,r0,0
+ 4e4:	9f ff ff ff 	l\.addi r31,r31,-1
+ 4e8:	9e 10 80 00 	l\.addi r16,r16,-32768
+ 4ec:	9d ef 7f ff 	l\.addi r15,r15,32767
+ 4f0:	9c 21 00 01 	l\.addi r1,r1,1
+ 4f4:	9d c0 1b 6c 	l\.addi r14,r0,7020
+ 4f8:	9d ae 37 33 	l\.addi r13,r14,14131
+ 4fc:	9d d0 97 3b 	l\.addi r14,r16,-26821
+
+00000500 <l_andi>:
+ 500:	a4 00 00 00 	l\.andi r0,r0,0x0
+ 504:	a7 ff ff ff 	l\.andi r31,r31,0xffff
+ 508:	a6 10 80 00 	l\.andi r16,r16,0x8000
+ 50c:	a5 ef 7f ff 	l\.andi r15,r15,0x7fff
+ 510:	a4 21 00 01 	l\.andi r1,r1,0x1
+ 514:	a7 75 2e 97 	l\.andi r27,r21,0x2e97
+ 518:	a6 b7 2f 1b 	l\.andi r21,r23,0x2f1b
+ 51c:	a7 de 83 c4 	l\.andi r30,r30,0x83c4
+
+00000520 <l_ori>:
+ 520:	a8 00 00 00 	l\.ori r0,r0,0x0
+ 524:	ab ff ff ff 	l\.ori r31,r31,0xffff
+ 528:	aa 10 80 00 	l\.ori r16,r16,0x8000
+ 52c:	a9 ef 7f ff 	l\.ori r15,r15,0x7fff
+ 530:	a8 21 00 01 	l\.ori r1,r1,0x1
+ 534:	aa db d8 81 	l\.ori r22,r27,0xd881
+ 538:	aa 3f 00 80 	l\.ori r17,r31,0x80
+ 53c:	a9 b4 cf 6d 	l\.ori r13,r20,0xcf6d
+
+00000540 <l_xori>:
+ 540:	ac 00 00 00 	l\.xori r0,r0,0
+ 544:	af ff ff ff 	l\.xori r31,r31,-1
+ 548:	ae 10 80 00 	l\.xori r16,r16,-32768
+ 54c:	ad ef 7f ff 	l\.xori r15,r15,32767
+ 550:	ac 21 00 01 	l\.xori r1,r1,1
+ 554:	ae 50 ff ff 	l\.xori r18,r16,-1
+ 558:	af 2d c0 35 	l\.xori r25,r13,-16331
+ 55c:	ad 9d 80 29 	l\.xori r12,r29,-32727
+
+00000560 <l_muli>:
+ 560:	b0 00 00 00 	l\.muli r0,r0,0
+ 564:	b3 ff ff ff 	l\.muli r31,r31,-1
+ 568:	b2 10 80 00 	l\.muli r16,r16,-32768
+ 56c:	b1 ef 7f ff 	l\.muli r15,r15,32767
+ 570:	b0 21 00 01 	l\.muli r1,r1,1
+ 574:	b3 67 ed 85 	l\.muli r27,r7,-4731
+ 578:	b0 f4 ff ff 	l\.muli r7,r20,-1
+ 57c:	b3 15 5a b3 	l\.muli r24,r21,23219
+
+00000580 <l_addic>:
+ 580:	a0 00 00 00 	l\.addic r0,r0,0
+ 584:	a3 ff ff ff 	l\.addic r31,r31,-1
+ 588:	a2 10 80 00 	l\.addic r16,r16,-32768
+ 58c:	a1 ef 7f ff 	l\.addic r15,r15,32767
+ 590:	a0 21 00 01 	l\.addic r1,r1,1
+ 594:	a0 d6 80 44 	l\.addic r6,r22,-32700
+ 598:	a2 69 ff ff 	l\.addic r19,r9,-1
+ 59c:	a3 7c 1a eb 	l\.addic r27,r28,6891
+
+000005a0 <l_sfgtu>:
+ 5a0:	e4 40 00 00 	l\.sfgtu r0,r0
+ 5a4:	e4 5f f8 00 	l\.sfgtu r31,r31
+ 5a8:	e4 50 80 00 	l\.sfgtu r16,r16
+ 5ac:	e4 4f 78 00 	l\.sfgtu r15,r15
+ 5b0:	e4 41 08 00 	l\.sfgtu r1,r1
+ 5b4:	e4 48 20 00 	l\.sfgtu r8,r4
+ 5b8:	e4 51 a8 00 	l\.sfgtu r17,r21
+ 5bc:	e4 46 28 00 	l\.sfgtu r6,r5
+
+000005c0 <l_sfgeu>:
+ 5c0:	e4 60 00 00 	l\.sfgeu r0,r0
+ 5c4:	e4 7f f8 00 	l\.sfgeu r31,r31
+ 5c8:	e4 70 80 00 	l\.sfgeu r16,r16
+ 5cc:	e4 6f 78 00 	l\.sfgeu r15,r15
+ 5d0:	e4 61 08 00 	l\.sfgeu r1,r1
+ 5d4:	e4 6e 60 00 	l\.sfgeu r14,r12
+ 5d8:	e4 76 38 00 	l\.sfgeu r22,r7
+ 5dc:	e4 6d 08 00 	l\.sfgeu r13,r1
+
+000005e0 <l_sfltu>:
+ 5e0:	e4 80 00 00 	l\.sfltu r0,r0
+ 5e4:	e4 9f f8 00 	l\.sfltu r31,r31
+ 5e8:	e4 90 80 00 	l\.sfltu r16,r16
+ 5ec:	e4 8f 78 00 	l\.sfltu r15,r15
+ 5f0:	e4 81 08 00 	l\.sfltu r1,r1
+ 5f4:	e4 81 68 00 	l\.sfltu r1,r13
+ 5f8:	e4 96 f0 00 	l\.sfltu r22,r30
+ 5fc:	e4 94 30 00 	l\.sfltu r20,r6
+
+00000600 <l_sfleu>:
+ 600:	e4 a0 00 00 	l\.sfleu r0,r0
+ 604:	e4 bf f8 00 	l\.sfleu r31,r31
+ 608:	e4 b0 80 00 	l\.sfleu r16,r16
+ 60c:	e4 af 78 00 	l\.sfleu r15,r15
+ 610:	e4 a1 08 00 	l\.sfleu r1,r1
+ 614:	e4 b3 40 00 	l\.sfleu r19,r8
+ 618:	e4 bb 78 00 	l\.sfleu r27,r15
+ 61c:	e4 bb 18 00 	l\.sfleu r27,r3
+
+00000620 <l_sfgts>:
+ 620:	e5 40 00 00 	l\.sfgts r0,r0
+ 624:	e5 5f f8 00 	l\.sfgts r31,r31
+ 628:	e5 50 80 00 	l\.sfgts r16,r16
+ 62c:	e5 4f 78 00 	l\.sfgts r15,r15
+ 630:	e5 41 08 00 	l\.sfgts r1,r1
+ 634:	e5 45 28 00 	l\.sfgts r5,r5
+ 638:	e5 5f 28 00 	l\.sfgts r31,r5
+ 63c:	e5 5e 90 00 	l\.sfgts r30,r18
+
+00000640 <l_sfges>:
+ 640:	e5 60 00 00 	l\.sfges r0,r0
+ 644:	e5 7f f8 00 	l\.sfges r31,r31
+ 648:	e5 70 80 00 	l\.sfges r16,r16
+ 64c:	e5 6f 78 00 	l\.sfges r15,r15
+ 650:	e5 61 08 00 	l\.sfges r1,r1
+ 654:	e5 71 90 00 	l\.sfges r17,r18
+ 658:	e5 60 48 00 	l\.sfges r0,r9
+ 65c:	e5 76 c8 00 	l\.sfges r22,r25
+
+00000660 <l_sflts>:
+ 660:	e5 80 00 00 	l\.sflts r0,r0
+ 664:	e5 9f f8 00 	l\.sflts r31,r31
+ 668:	e5 90 80 00 	l\.sflts r16,r16
+ 66c:	e5 8f 78 00 	l\.sflts r15,r15
+ 670:	e5 81 08 00 	l\.sflts r1,r1
+ 674:	e5 99 c0 00 	l\.sflts r25,r24
+ 678:	e5 97 68 00 	l\.sflts r23,r13
+ 67c:	e5 8f 40 00 	l\.sflts r15,r8
+
+00000680 <l_sfles>:
+ 680:	e5 a0 00 00 	l\.sfles r0,r0
+ 684:	e5 bf f8 00 	l\.sfles r31,r31
+ 688:	e5 b0 80 00 	l\.sfles r16,r16
+ 68c:	e5 af 78 00 	l\.sfles r15,r15
+ 690:	e5 a1 08 00 	l\.sfles r1,r1
+ 694:	e5 b1 68 00 	l\.sfles r17,r13
+ 698:	e5 be c8 00 	l\.sfles r30,r25
+ 69c:	e5 a0 60 00 	l\.sfles r0,r12
+
+000006a0 <l_sfgtui>:
+ 6a0:	bc 40 00 00 	l\.sfgtui r0,0
+ 6a4:	bc 5f ff ff 	l\.sfgtui r31,-1
+ 6a8:	bc 50 80 00 	l\.sfgtui r16,-32768
+ 6ac:	bc 4f 7f ff 	l\.sfgtui r15,32767
+ 6b0:	bc 41 00 01 	l\.sfgtui r1,1
+ 6b4:	bc 45 4b 21 	l\.sfgtui r5,19233
+ 6b8:	bc 57 91 22 	l\.sfgtui r23,-28382
+ 6bc:	bc 51 25 dd 	l\.sfgtui r17,9693
+
+000006c0 <l_sfgeui>:
+ 6c0:	bc 60 00 00 	l\.sfgeui r0,0
+ 6c4:	bc 7f ff ff 	l\.sfgeui r31,-1
+ 6c8:	bc 70 80 00 	l\.sfgeui r16,-32768
+ 6cc:	bc 6f 7f ff 	l\.sfgeui r15,32767
+ 6d0:	bc 61 00 01 	l\.sfgeui r1,1
+ 6d4:	bc 71 ec b6 	l\.sfgeui r17,-4938
+ 6d8:	bc 6f 40 13 	l\.sfgeui r15,16403
+ 6dc:	bc 66 f1 a4 	l\.sfgeui r6,-3676
+
+000006e0 <l_sfltui>:
+ 6e0:	bc 80 00 00 	l\.sfltui r0,0
+ 6e4:	bc 9f ff ff 	l\.sfltui r31,-1
+ 6e8:	bc 90 80 00 	l\.sfltui r16,-32768
+ 6ec:	bc 8f 7f ff 	l\.sfltui r15,32767
+ 6f0:	bc 81 00 01 	l\.sfltui r1,1
+ 6f4:	bc 83 cc af 	l\.sfltui r3,-13137
+ 6f8:	bc 98 4c fd 	l\.sfltui r24,19709
+ 6fc:	bc 8a 03 3e 	l\.sfltui r10,830
+
+00000700 <l_sfleui>:
+ 700:	bc a0 00 00 	l\.sfleui r0,0
+ 704:	bc bf ff ff 	l\.sfleui r31,-1
+ 708:	bc b0 80 00 	l\.sfleui r16,-32768
+ 70c:	bc af 7f ff 	l\.sfleui r15,32767
+ 710:	bc a1 00 01 	l\.sfleui r1,1
+ 714:	bc b7 9b 66 	l\.sfleui r23,-25754
+ 718:	bc b1 b6 d7 	l\.sfleui r17,-18729
+ 71c:	bc a9 a8 81 	l\.sfleui r9,-22399
+
+00000720 <l_sfgtsi>:
+ 720:	bd 40 00 00 	l\.sfgtsi r0,0
+ 724:	bd 5f ff ff 	l\.sfgtsi r31,-1
+ 728:	bd 50 80 00 	l\.sfgtsi r16,-32768
+ 72c:	bd 4f 7f ff 	l\.sfgtsi r15,32767
+ 730:	bd 41 00 01 	l\.sfgtsi r1,1
+ 734:	bd 4d b6 82 	l\.sfgtsi r13,-18814
+ 738:	bd 4d d6 5f 	l\.sfgtsi r13,-10657
+ 73c:	bd 5c 97 d5 	l\.sfgtsi r28,-26667
+
+00000740 <l_sfgesi>:
+ 740:	bd 60 00 00 	l\.sfgesi r0,0
+ 744:	bd 7f ff ff 	l\.sfgesi r31,-1
+ 748:	bd 70 80 00 	l\.sfgesi r16,-32768
+ 74c:	bd 6f 7f ff 	l\.sfgesi r15,32767
+ 750:	bd 61 00 01 	l\.sfgesi r1,1
+ 754:	bd 6c 09 48 	l\.sfgesi r12,2376
+ 758:	bd 69 7d 3b 	l\.sfgesi r9,32059
+ 75c:	bd 6d 50 d8 	l\.sfgesi r13,20696
+
+00000760 <l_sfltsi>:
+ 760:	bd 80 00 00 	l\.sfltsi r0,0
+ 764:	bd 9f ff ff 	l\.sfltsi r31,-1
+ 768:	bd 90 80 00 	l\.sfltsi r16,-32768
+ 76c:	bd 8f 7f ff 	l\.sfltsi r15,32767
+ 770:	bd 81 00 01 	l\.sfltsi r1,1
+ 774:	bd 9e 0b cd 	l\.sfltsi r30,3021
+ 778:	bd 85 93 5b 	l\.sfltsi r5,-27813
+ 77c:	bd 9c dd 90 	l\.sfltsi r28,-8816
+
+00000780 <l_sflesi>:
+ 780:	bd a0 00 00 	l\.sflesi r0,0
+ 784:	bd bf ff ff 	l\.sflesi r31,-1
+ 788:	bd b0 80 00 	l\.sflesi r16,-32768
+ 78c:	bd af 7f ff 	l\.sflesi r15,32767
+ 790:	bd a1 00 01 	l\.sflesi r1,1
+ 794:	bd b2 2c 4a 	l\.sflesi r18,11338
+ 798:	bd bd 49 b9 	l\.sflesi r29,18873
+ 79c:	bd bc 65 c2 	l\.sflesi r28,26050
+
+000007a0 <l_sfeq>:
+ 7a0:	e4 00 00 00 	l\.sfeq r0,r0
+ 7a4:	e4 1f f8 00 	l\.sfeq r31,r31
+ 7a8:	e4 10 80 00 	l\.sfeq r16,r16
+ 7ac:	e4 0f 78 00 	l\.sfeq r15,r15
+ 7b0:	e4 01 08 00 	l\.sfeq r1,r1
+ 7b4:	e4 1c d0 00 	l\.sfeq r28,r26
+ 7b8:	e4 0d 30 00 	l\.sfeq r13,r6
+ 7bc:	e4 1a 48 00 	l\.sfeq r26,r9
+
+000007c0 <l_sfeqi>:
+ 7c0:	bc 00 00 00 	l\.sfeqi r0,0
+ 7c4:	bc 1f ff ff 	l\.sfeqi r31,-1
+ 7c8:	bc 10 80 00 	l\.sfeqi r16,-32768
+ 7cc:	bc 0f 7f ff 	l\.sfeqi r15,32767
+ 7d0:	bc 01 00 01 	l\.sfeqi r1,1
+ 7d4:	bc 0a 65 1f 	l\.sfeqi r10,25887
+ 7d8:	bc 15 4d b6 	l\.sfeqi r21,19894
+ 7dc:	bc 12 cb 95 	l\.sfeqi r18,-13419
+
+000007e0 <l_sfne>:
+ 7e0:	e4 20 00 00 	l\.sfne r0,r0
+ 7e4:	e4 3f f8 00 	l\.sfne r31,r31
+ 7e8:	e4 30 80 00 	l\.sfne r16,r16
+ 7ec:	e4 2f 78 00 	l\.sfne r15,r15
+ 7f0:	e4 21 08 00 	l\.sfne r1,r1
+ 7f4:	e4 32 d8 00 	l\.sfne r18,r27
+ 7f8:	e4 26 90 00 	l\.sfne r6,r18
+ 7fc:	e4 20 f0 00 	l\.sfne r0,r30
+
+00000800 <l_sfnei>:
+ 800:	bc 20 00 00 	l\.sfnei r0,0
+ 804:	bc 3f ff ff 	l\.sfnei r31,-1
+ 808:	bc 30 80 00 	l\.sfnei r16,-32768
+ 80c:	bc 2f 7f ff 	l\.sfnei r15,32767
+ 810:	bc 21 00 01 	l\.sfnei r1,1
+ 814:	bc 28 2c 92 	l\.sfnei r8,11410
+ 818:	bc 26 b4 d9 	l\.sfnei r6,-19239
+ 81c:	bc 34 a7 01 	l\.sfnei r20,-22783
+
+00000820 <l_lo>:
+ 820:	9c 21 be ef 	l\.addi r1,r1,-16657
+
+00000824 <l_hi>:
+ 824:	18 20 de ad 	l\.movhi r1,0xdead
+
+00000828 <l_mac>:
+ 828:	c4 01 10 01 	l.mac r1,r2
+
+0000082c <l_maci>:
+ 82c:	4c 01 00 00 	l\.maci r1,0
+ 830:	4c 02 ff ff 	l\.maci r2,-1
+ 834:	4c 02 7f ff 	l\.maci r2,32767
+ 838:	4c 02 80 00 	l\.maci r2,-32768
--- /dev/null
+++ b/or1k/allinsn.exp
@@ -0,0 +1,5 @@
+# OR1K assembler testsuite. -*- Tcl -*-
+
+if [istarget or1k*-*-*] {
+        run_dump_tests [lsort [glob -nocomplain $srcdir/$subdir/*.d]]
+}
--- /dev/null
+++ b/or1k/allinsn.s
@@ -0,0 +1,677 @@
+        .data
+localdata:
+        .word 42
+        .text
+localtext:
+        l.nop
+        .data
+        .global globaldata
+globaldata:
+        .word 43
+	.text
+        .global globaltext
+globaltext:
+        l.nop
+        
+l_j:
+	l.j -4
+	l.j 4
+	l.j 0
+        l.j localtext
+	l.j localdata
+	l.j globaltext
+        l.j globaldata
+	l.j l_j
+        l.j l_jal
+	.text
+l_jal:
+	l.jal -4
+	l.jal 4
+	l.jal 0
+        l.jal localtext
+	l.jal localdata
+	l.jal globaltext
+        l.jal globaldata
+	l.jal l_j
+        l.jal l_jal
+	.text
+l_jr:
+	l.jr r0
+	l.jr r31
+	l.jr r16
+	l.jr r15
+	l.jr r1
+	l.jr r27
+	l.jr r14
+	l.jr r22
+	.text
+l_jalr:
+	l.jalr r0
+	l.jalr r31
+	l.jalr r16
+	l.jalr r15
+	l.jalr r1
+	l.jalr r27
+	l.jalr r14
+	l.jalr r22
+	.text
+l_bnf:
+	l.bnf -4
+	l.bnf 4
+	l.bnf 0
+        l.bnf localtext
+	l.bnf localdata
+	l.bnf globaltext
+        l.bnf globaldata
+	l.bnf l_j
+        l.bnf l_jal
+	.text
+l_bf:
+	l.bf -4
+	l.bf 4
+	l.bf 0
+        l.bf localtext
+	l.bf localdata
+	l.bf globaltext
+        l.bf globaldata
+	l.bf l_j
+        l.bf l_jal
+	.text
+l_trap:
+	l.trap 0
+	l.trap 65535
+	l.trap 32768
+	l.trap 32767
+	l.trap 1
+	l.trap 53583
+	l.trap 32636
+	l.trap 53834
+	.text
+l_sys:
+	l.sys 0
+	l.sys 65535
+	l.sys 32768
+	l.sys 32767
+	l.sys 1
+	l.sys 53893
+	l.sys 58133
+	l.sys 33018
+	.text
+l_rfe:
+	l.rfe
+	.text
+l_nop:
+	l.nop
+	.text
+l_movhi:
+	l.movhi r0,0
+	l.movhi r31,-1
+	l.movhi r16,-32768
+	l.movhi r15,32767
+	l.movhi r1,1
+	l.movhi r28,-32306
+	l.movhi r23,-5972
+	l.movhi r19,-10048
+	.text
+l_mfspr:
+	l.mfspr r0,r0,0
+	l.mfspr r31,r31,65535
+	l.mfspr r16,r16,32768
+	l.mfspr r15,r15,32767
+	l.mfspr r1,r1,1
+	l.mfspr r23,r29,54424
+	l.mfspr r19,r20,4481
+	l.mfspr r26,r2,63446
+	.text
+l_mtspr:
+	l.mtspr r0,r0,0
+	l.mtspr r31,r31,-1
+	l.mtspr r16,r16,-32768
+	l.mtspr r15,r15,32767
+	l.mtspr r1,r1,1
+	l.mtspr r30,r6,15223
+	l.mtspr r9,r7,-21300
+	l.mtspr r25,r7,-645
+	.text
+l_lwz:
+	l.lwz r0,0(r0)
+	l.lwz r31,-1(r31)
+	l.lwz r16,-32768(r16)
+	l.lwz r15,32767(r15)
+	l.lwz r1,1(r1)
+	l.lwz r15,2933(r25)
+	l.lwz r17,-799(r21)
+	l.lwz r0,-17595(r18)
+	.text
+l_lws:
+	l.lws r0,0(r0)
+	l.lws r31,-1(r31)
+	l.lws r16,-32768(r16)
+	l.lws r15,32767(r15)
+	l.lws r1,1(r1)
+	l.lws r1,-17606(r21)
+	l.lws r14,26891(r31)
+	l.lws r8,27552(r0)
+	.text
+l_lbz:
+	l.lbz r0,0(r0)
+	l.lbz r31,-1(r31)
+	l.lbz r16,-32768(r16)
+	l.lbz r15,32767(r15)
+	l.lbz r1,1(r1)
+	l.lbz r19,25635(r20)
+	l.lbz r15,-3416(r9)
+	l.lbz r3,17748(r1)
+	.text
+l_lbs:
+	l.lbs r0,0(r0)
+	l.lbs r31,-1(r31)
+	l.lbs r16,-32768(r16)
+	l.lbs r15,32767(r15)
+	l.lbs r1,1(r1)
+	l.lbs r26,17606(r8)
+	l.lbs r22,-31072(r16)
+	l.lbs r6,17440(r9)
+	.text
+l_lhz:
+	l.lhz r0,0(r0)
+	l.lhz r31,-1(r31)
+	l.lhz r16,-32768(r16)
+	l.lhz r15,32767(r15)
+	l.lhz r1,1(r1)
+	l.lhz r5,-5667(r4)
+	l.lhz r24,5848(r4)
+	l.lhz r10,31675(r7)
+	.text
+l_lhs:
+	l.lhs r0,0(r0)
+	l.lhs r31,-1(r31)
+	l.lhs r16,-32768(r16)
+	l.lhs r15,32767(r15)
+	l.lhs r1,1(r1)
+	l.lhs r6,-142(r11)
+	l.lhs r20,-5306(r29)
+	l.lhs r15,4178(r21)
+	.text
+l_sw:
+	l.sw 0(r0),r0
+	l.sw -1(r31),r31
+	l.sw -32768(r16),r16
+	l.sw 32767(r15),r15
+	l.sw 1(r1),r1
+	l.sw -7967(r17),r10
+	l.sw 1824(r30),r10
+	l.sw 31566(r15),r4
+	.text
+l_sb:
+	l.sb 0(r0),r0
+	l.sb -1(r31),r31
+	l.sb -32768(r16),r16
+	l.sb 32767(r15),r15
+	l.sb 1(r1),r1
+	l.sb 22200(r10),r0
+	l.sb 9995(r16),r27
+	l.sb -28260(r14),r31
+	.text
+l_sh:
+	l.sh 0(r0),r0
+	l.sh -1(r31),r31
+	l.sh -32768(r16),r16
+	l.sh 32767(r15),r15
+	l.sh 1(r1),r1
+	l.sh 10685(r21),r25
+	l.sh -13066(r28),r5
+	l.sh -26800(r9),r29
+	.text
+l_sll:
+	l.sll r0,r0,r0
+	l.sll r31,r31,r31
+	l.sll r16,r16,r16
+	l.sll r15,r15,r15
+	l.sll r1,r1,r1
+	l.sll r31,r16,r8
+	l.sll r31,r17,r22
+	l.sll r15,r14,r5
+	.text
+l_slli:
+	l.slli r0,r0,0
+	l.slli r31,r31,63
+	l.slli r16,r16,32
+	l.slli r15,r15,31
+	l.slli r1,r1,1
+	l.slli r11,r14,49
+	l.slli r7,r27,23
+	l.slli r30,r16,11
+	.text
+l_srl:
+	l.srl r0,r0,r0
+	l.srl r31,r31,r31
+	l.srl r16,r16,r16
+	l.srl r15,r15,r15
+	l.srl r1,r1,r1
+	l.srl r15,r25,r13
+	l.srl r19,r0,r17
+	l.srl r13,r0,r23
+	.text
+l_srli:
+	l.srli r0,r0,0
+	l.srli r31,r31,63
+	l.srli r16,r16,32
+	l.srli r15,r15,31
+	l.srli r1,r1,1
+	l.srli r15,r30,13
+	l.srli r13,r3,63
+	l.srli r2,r18,30
+	.text
+l_sra:
+	l.sra r0,r0,r0
+	l.sra r31,r31,r31
+	l.sra r16,r16,r16
+	l.sra r15,r15,r15
+	l.sra r1,r1,r1
+	l.sra r3,r26,r0
+	l.sra r29,r18,r27
+	l.sra r27,r29,r3
+	.text
+l_srai:
+	l.srai r0,r0,0
+	l.srai r31,r31,63
+	l.srai r16,r16,32
+	l.srai r15,r15,31
+	l.srai r1,r1,1
+	l.srai r10,r11,28
+	l.srai r23,r15,48
+	l.srai r16,r15,38
+	.text
+l_ror:
+	l.ror r0,r0,r0
+	l.ror r31,r31,r31
+	l.ror r16,r16,r16
+	l.ror r15,r15,r15
+	l.ror r1,r1,r1
+	l.ror r29,r12,r5
+	l.ror r18,r6,r4
+	l.ror r2,r16,r17
+	.text
+l_rori:
+	l.rori r0,r0,0
+	l.rori r31,r31,63
+	l.rori r16,r16,32
+	l.rori r15,r15,31
+	l.rori r1,r1,1
+	l.rori r17,r0,23
+	l.rori r16,r31,42
+	l.rori r13,r21,12
+	.text
+l_add:
+	l.add r0,r0,r0
+	l.add r31,r31,r31
+	l.add r16,r16,r16
+	l.add r15,r15,r15
+	l.add r1,r1,r1
+	l.add r29,r7,r4
+	l.add r29,r10,r18
+	l.add r18,r22,r23
+	.text
+l_sub:
+	l.sub r0,r0,r0
+	l.sub r31,r31,r31
+	l.sub r16,r16,r16
+	l.sub r15,r15,r15
+	l.sub r1,r1,r1
+	l.sub r23,r26,r14
+	l.sub r10,r24,r15
+	l.sub r11,r4,r18
+	.text
+l_and:
+	l.and r0,r0,r0
+	l.and r31,r31,r31
+	l.and r16,r16,r16
+	l.and r15,r15,r15
+	l.and r1,r1,r1
+	l.and r0,r31,r25
+	l.and r30,r7,r19
+	l.and r19,r2,r26
+	.text
+l_or:
+	l.or r0,r0,r0
+	l.or r31,r31,r31
+	l.or r16,r16,r16
+	l.or r15,r15,r15
+	l.or r1,r1,r1
+	l.or r17,r10,r2
+	l.or r7,r19,r29
+	l.or r3,r17,r17
+	.text
+l_xor:
+	l.xor r0,r0,r0
+	l.xor r31,r31,r31
+	l.xor r16,r16,r16
+	l.xor r15,r15,r15
+	l.xor r1,r1,r1
+	l.xor r31,r5,r17
+	l.xor r22,r4,r5
+	l.xor r30,r20,r26
+	.text
+l_addc:
+	l.addc r0,r0,r0
+	l.addc r31,r31,r31
+	l.addc r16,r16,r16
+	l.addc r15,r15,r15
+	l.addc r1,r1,r1
+	l.addc r8,r26,r24
+	l.addc r18,r6,r4
+	l.addc r29,r0,r18
+	.text
+l_mul:
+	l.mul r0,r0,r0
+	l.mul r31,r31,r31
+	l.mul r16,r16,r16
+	l.mul r15,r15,r15
+	l.mul r1,r1,r1
+	l.mul r8,r25,r13
+	l.mul r8,r21,r29
+	l.mul r27,r3,r17
+	.text
+l_mulu:
+	l.mulu r0,r0,r0
+	l.mulu r31,r31,r31
+	l.mulu r16,r16,r16
+	l.mulu r15,r15,r15
+	l.mulu r1,r1,r1
+	l.mulu r26,r14,r16
+	l.mulu r1,r18,r11
+	l.mulu r14,r18,r17
+	.text
+l_div:
+	l.div r0,r0,r0
+	l.div r31,r31,r31
+	l.div r16,r16,r16
+	l.div r15,r15,r15
+	l.div r1,r1,r1
+	l.div r0,r2,r28
+	l.div r26,r7,r31
+	l.div r2,r18,r20
+	.text
+l_divu:
+	l.divu r0,r0,r0
+	l.divu r31,r31,r31
+	l.divu r16,r16,r16
+	l.divu r15,r15,r15
+	l.divu r1,r1,r1
+	l.divu r5,r4,r25
+	l.divu r8,r11,r29
+	l.divu r11,r19,r2
+	.text
+l_addi:
+	l.addi r0,r0,0
+	l.addi r31,r31,-1
+	l.addi r16,r16,-32768
+	l.addi r15,r15,32767
+	l.addi r1,r1,1
+	l.addi r14,r0,7020
+	l.addi r13,r14,14131
+	l.addi r14,r16,-26821
+	.text
+l_andi:
+	l.andi r0,r0,0
+	l.andi r31,r31,-1
+	l.andi r16,r16,-32768
+	l.andi r15,r15,32767
+	l.andi r1,r1,1
+	l.andi r27,r21,11927
+	l.andi r21,r23,12059
+	l.andi r30,r30,-31804
+	.text
+l_ori:
+	l.ori r0,r0,0
+	l.ori r31,r31,-1
+	l.ori r16,r16,-32768
+	l.ori r15,r15,32767
+	l.ori r1,r1,1
+	l.ori r22,r27,-10111
+	l.ori r17,r31,128
+	l.ori r13,r20,-12435
+	.text
+l_xori:
+	l.xori r0,r0,0
+	l.xori r31,r31,-1
+	l.xori r16,r16,-32768
+	l.xori r15,r15,32767
+	l.xori r1,r1,1
+	l.xori r18,r16,65535
+	l.xori r25,r13,-16331
+	l.xori r12,r29,-32727
+	.text
+l_muli:
+	l.muli r0,r0,0
+	l.muli r31,r31,-1
+	l.muli r16,r16,-32768
+	l.muli r15,r15,32767
+	l.muli r1,r1,1
+	l.muli r27,r7,-4731
+	l.muli r7,r20,65535
+	l.muli r24,r21,23219
+	.text
+l_addic:
+	l.addic r0,r0,0
+	l.addic r31,r31,-1
+	l.addic r16,r16,-32768
+	l.addic r15,r15,32767
+	l.addic r1,r1,1
+	l.addic r6,r22,-32700
+	l.addic r19,r9,65535
+	l.addic r27,r28,6891
+	.text
+l_sfgtu:
+	l.sfgtu r0,r0
+	l.sfgtu r31,r31
+	l.sfgtu r16,r16
+	l.sfgtu r15,r15
+	l.sfgtu r1,r1
+	l.sfgtu r8,r4
+	l.sfgtu r17,r21
+	l.sfgtu r6,r5
+	.text
+l_sfgeu:
+	l.sfgeu r0,r0
+	l.sfgeu r31,r31
+	l.sfgeu r16,r16
+	l.sfgeu r15,r15
+	l.sfgeu r1,r1
+	l.sfgeu r14,r12
+	l.sfgeu r22,r7
+	l.sfgeu r13,r1
+	.text
+l_sfltu:
+	l.sfltu r0,r0
+	l.sfltu r31,r31
+	l.sfltu r16,r16
+	l.sfltu r15,r15
+	l.sfltu r1,r1
+	l.sfltu r1,r13
+	l.sfltu r22,r30
+	l.sfltu r20,r6
+	.text
+l_sfleu:
+	l.sfleu r0,r0
+	l.sfleu r31,r31
+	l.sfleu r16,r16
+	l.sfleu r15,r15
+	l.sfleu r1,r1
+	l.sfleu r19,r8
+	l.sfleu r27,r15
+	l.sfleu r27,r3
+	.text
+l_sfgts:
+	l.sfgts r0,r0
+	l.sfgts r31,r31
+	l.sfgts r16,r16
+	l.sfgts r15,r15
+	l.sfgts r1,r1
+	l.sfgts r5,r5
+	l.sfgts r31,r5
+	l.sfgts r30,r18
+	.text
+l_sfges:
+	l.sfges r0,r0
+	l.sfges r31,r31
+	l.sfges r16,r16
+	l.sfges r15,r15
+	l.sfges r1,r1
+	l.sfges r17,r18
+	l.sfges r0,r9
+	l.sfges r22,r25
+	.text
+l_sflts:
+	l.sflts r0,r0
+	l.sflts r31,r31
+	l.sflts r16,r16
+	l.sflts r15,r15
+	l.sflts r1,r1
+	l.sflts r25,r24
+	l.sflts r23,r13
+	l.sflts r15,r8
+	.text
+l_sfles:
+	l.sfles r0,r0
+	l.sfles r31,r31
+	l.sfles r16,r16
+	l.sfles r15,r15
+	l.sfles r1,r1
+	l.sfles r17,r13
+	l.sfles r30,r25
+	l.sfles r0,r12
+	.text
+l_sfgtui:
+	l.sfgtui r0,0
+	l.sfgtui r31,65535
+	l.sfgtui r16,32768
+	l.sfgtui r15,32767
+	l.sfgtui r1,1
+	l.sfgtui r5,19233
+	l.sfgtui r23,37154
+	l.sfgtui r17,9693
+	.text
+l_sfgeui:
+	l.sfgeui r0,0
+	l.sfgeui r31,65535
+	l.sfgeui r16,32768
+	l.sfgeui r15,32767
+	l.sfgeui r1,1
+	l.sfgeui r17,60598
+	l.sfgeui r15,16403
+	l.sfgeui r6,61860
+	.text
+l_sfltui:
+	l.sfltui r0,0
+	l.sfltui r31,65535
+	l.sfltui r16,32768
+	l.sfltui r15,32767
+	l.sfltui r1,1
+	l.sfltui r3,52399
+	l.sfltui r24,19709
+	l.sfltui r10,830
+	.text
+l_sfleui:
+	l.sfleui r0,0
+	l.sfleui r31,65535
+	l.sfleui r16,32768
+	l.sfleui r15,32767
+	l.sfleui r1,1
+	l.sfleui r23,39782
+	l.sfleui r17,46807
+	l.sfleui r9,43137
+	.text
+l_sfgtsi:
+	l.sfgtsi r0,0
+	l.sfgtsi r31,-1
+	l.sfgtsi r16,-32768
+	l.sfgtsi r15,32767
+	l.sfgtsi r1,1
+	l.sfgtsi r13,-18814
+	l.sfgtsi r13,-10657
+	l.sfgtsi r28,-26667
+	.text
+l_sfgesi:
+	l.sfgesi r0,0
+	l.sfgesi r31,-1
+	l.sfgesi r16,-32768
+	l.sfgesi r15,32767
+	l.sfgesi r1,1
+	l.sfgesi r12,2376
+	l.sfgesi r9,32059
+	l.sfgesi r13,20696
+	.text
+l_sfltsi:
+	l.sfltsi r0,0
+	l.sfltsi r31,-1
+	l.sfltsi r16,-32768
+	l.sfltsi r15,32767
+	l.sfltsi r1,1
+	l.sfltsi r30,3021
+	l.sfltsi r5,-27813
+	l.sfltsi r28,-8816
+	.text
+l_sflesi:
+	l.sflesi r0,0
+	l.sflesi r31,-1
+	l.sflesi r16,-32768
+	l.sflesi r15,32767
+	l.sflesi r1,1
+	l.sflesi r18,11338
+	l.sflesi r29,18873
+	l.sflesi r28,26050
+	.text
+l_sfeq:
+	l.sfeq r0,r0
+	l.sfeq r31,r31
+	l.sfeq r16,r16
+	l.sfeq r15,r15
+	l.sfeq r1,r1
+	l.sfeq r28,r26
+	l.sfeq r13,r6
+	l.sfeq r26,r9
+	.text
+l_sfeqi:
+	l.sfeqi r0,0
+	l.sfeqi r31,-1
+	l.sfeqi r16,-32768
+	l.sfeqi r15,32767
+	l.sfeqi r1,1
+	l.sfeqi r10,25887
+	l.sfeqi r21,19894
+	l.sfeqi r18,-13419
+	.text
+l_sfne:
+	l.sfne r0,r0
+	l.sfne r31,r31
+	l.sfne r16,r16
+	l.sfne r15,r15
+	l.sfne r1,r1
+	l.sfne r18,r27
+	l.sfne r6,r18
+	l.sfne r0,r30
+	.text
+l_sfnei:
+	l.sfnei r0,0
+	l.sfnei r31,-1
+	l.sfnei r16,-32768
+	l.sfnei r15,32767
+	l.sfnei r1,1
+	l.sfnei r8,11410
+	l.sfnei r6,-19239
+	l.sfnei r20,-22783
+
+l_lo:
+	l.addi	r1, r1, lo(0xdeadbeef)
+l_hi:	
+	l.movhi	r1, hi(0xdeadbeef)
+
+l_mac:
+        l.mac r1,r2
+l_maci:
+        l.maci r1,0
+        l.maci r2,-1
+        l.maci r2,32767
+        l.maci r2,-32768
